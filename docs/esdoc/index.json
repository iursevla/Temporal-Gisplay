[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Gisplay/Gisplay.js",
    "content": "import { Choropleth } from './Maps/Choropleth';\r\nimport { DotMap } from './Maps/DotMap';\r\n// import { ChangeMap } from './Maps/ChangeMap';\r\nimport { ProportionalSymbolsMap } from './Maps/ProportionalSymbolsMap';\r\nimport { FiguresMap } from './Maps/FiguresMap';\r\nimport { LinesMap } from './Maps/LinesMap';\r\nimport { ChangeMap } from './Maps/ChangeMap';\r\n\r\n/**\r\n * Gisplay API entry point with one method for each map available.\r\n */\r\nexport class Gisplay {\r\n    /**\r\n     * Creates a new map of type Choropleth.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeChoropleth(parsingOptions, mappingOptions, globalOptions) {\r\n        new Choropleth(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Dot Map.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeDotMap(parsingOptions, mappingOptions, globalOptions) {\r\n        new DotMap(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Proportional Symbols Map. \r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeProportionalSymbolsMap(parsingOptions, mappingOptions, globalOptions) {\r\n        new ProportionalSymbolsMap(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Figures Map. \r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeFiguresMap(parsingOptions, mappingOptions, globalOptions) {\r\n        new FiguresMap(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Lines Map. \r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeLinesMap(parsingOptions, mappingOptions, globalOptions) {\r\n        new LinesMap(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Lines Map. \r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @static\r\n     * @memberof Gisplay\r\n     */\r\n    static makeChangeMap(parsingOptions, mappingOptions, globalOptions) {\r\n        new ChangeMap(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Gisplay.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Gisplay",
    "memberof": "src/Gisplay/Gisplay.js",
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Gisplay.js",
    "importStyle": "{Gisplay}",
    "description": "Gisplay API entry point with one method for each map available.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "method",
    "name": "makeChoropleth",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeChoropleth",
    "access": "public",
    "description": "Creates a new map of type Choropleth.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "method",
    "name": "makeDotMap",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeDotMap",
    "access": "public",
    "description": "Creates a new Dot Map.",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "makeProportionalSymbolsMap",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeProportionalSymbolsMap",
    "access": "public",
    "description": "Creates a new Proportional Symbols Map. ",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "makeFiguresMap",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeFiguresMap",
    "access": "public",
    "description": "Creates a new Figures Map. ",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "makeLinesMap",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeLinesMap",
    "access": "public",
    "description": "Creates a new Lines Map. ",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "makeChangeMap",
    "memberof": "src/Gisplay/Gisplay.js~Gisplay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Gisplay.js~Gisplay.makeChangeMap",
    "access": "public",
    "description": "Creates a new Lines Map. ",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/Gisplay/GisplayDefaults.js",
    "content": "import defaultsFile from './defaults.json';\r\nimport { GisplayError } from './GisplayError';\r\n\r\n/**\r\n * Class that exports the Gisplay default values.\r\n * @export\r\n * @class GisplayDefaults\r\n */\r\nexport class GisplayDefaults {\r\n\r\n    /**\r\n     * Returns the available class break methods.\r\n     * @returns {string[]} - All available class break methods under Gisplay API.\r\n     * @memberOf GisplayOptions\r\n     */\r\n    static getAvailableClassBreaksMethods() {\r\n        return defaultsFile.availableClasssBreakMethods; //[\"quantiles\", \"equalintervals\", \"k-means\"];\r\n    }\r\n\r\n    /**\r\n     * Returns a list of available background map providers.\r\n     * @returns {string[]} - All available background map providers under Gisplay API.\r\n     * @memberof GisplayOptions\r\n     */\r\n    static getAvailableBackgroundProviders() {\r\n        return defaultsFile.bgmapsProviders;/*['Google Maps', 'GM', //All variants of Google Maps\r\n            'Mapbox', 'MB', //All variants of Mapbox\r\n            'Here Maps', 'HM',\r\n            'Bing Maps', 'BM'];*/\r\n    }\r\n\r\n    /**\r\n     * Returns the default class method to calculate classes for continuous variables.\r\n     * @static\r\n     * @returns {string} - Returns quantiles, the default method for class calculation.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultClassBreakMethod() {\r\n        return defaultsFile.defaultClassBreakMethod;//'equalintervals';\r\n    }\r\n\r\n    /**\r\n     * Returns the list of available granularities.\r\n     * @static\r\n     * @returns \r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getAvailableGranularities() {\r\n        return ['monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour', 'year', 'month', 'day', 'value'];\r\n    }\r\n\r\n    /**\r\n     * Returns the available color brewer methods.\r\n     * @returns {Array<string>} - the available color brewer methods.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getAvailableColorBrewerMethods() {\r\n        return [\r\n            'colorbrewer-' + GisplayDefaults.SEQUENTIAL().toLocaleLowerCase(),\r\n            'colorbrewer-' + GisplayDefaults.DIVERGENT().toLocaleLowerCase(),\r\n            'colorbrewer-' + GisplayDefaults.QUALITATIVE().toLocaleLowerCase()\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Convert the time string to the granularity we want.\r\n     * @param {string} timeString - The time as it was read from the file. \r\n     * @returns {number} - The granul\r\n     * @memberof CSVDataWorker\r\n     */\r\n    static getGranule(timeString) {\r\n        let value;\r\n        // console.warn(timeString, this.timeGranularity);\r\n        /*\r\n            //if cyclic then ...\r\n            day of year -> dayOfYear (n temos )\r\n            month of year -> monthOfYear (temos)\r\n            day of month -> dayOfMonth (temos)\r\n            hour of day -> hourOfDay (temos)\r\n            minute of hour -> minuteOfHour (temos)\r\n            \r\n            //else continuous\r\n            year -> 2015, 2016 ...\r\n            month -> 2015_01, 2015_02 ... 2016_01 etc\r\n            day -> 2015_01_01, 2015_01_02 ...\r\n            hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n            minute\r\n            value\r\n        */\r\n        switch (this.timeGranularity) {\r\n            //CYCLIC\r\n            case 'monthOfYear': //Mes do ano\r\n                value = (new Date(timeString).getMonth() + 1); //GOOD\r\n                break;\r\n            case 'dayOfYear':\r\n                value = -1; //CHANGE to calculate day of year\r\n                break;\r\n            case 'dayOfMonth':\r\n                value = new Date(timeString).getDate(); //GOOD\r\n                break;\r\n            case 'hourOfDay':\r\n                value = new Date(timeString).getHours(); //GOOD\r\n                break;\r\n            case 'minuteOfHour':\r\n                value = new Date(timeString).getMinutes(); //GOOD\r\n                break;\r\n\r\n            //CONTINUOUS\r\n            case 'year':\r\n                value = new Date(timeString).getFullYear();\r\n                break;\r\n            case 'month': //Mes do ano\r\n                value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\r\n                break;\r\n            case 'day':\r\n                value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\r\n                // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\r\n                break;\r\n            case 'value':\r\n                value = +timeString;\r\n                break;\r\n        }\r\n        // console.log(value);\r\n        return value;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     VISUAL VARIABLES   ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * The color visual variable.\r\n     * @static\r\n     * @returns {string} - the string 'color'.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static COLOR() {\r\n        return defaultsFile.visualVariables.COLOR;\r\n    }\r\n\r\n    /**\r\n     * The saturation visual variable.\r\n     * @static \r\n     * @returns {string} - The saturation visual variable string. \r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static OPACITY() {\r\n        return defaultsFile.visualVariables.OPACITY;\r\n    }\r\n\r\n    /**\r\n     * The shape visual variable.\r\n     * @static\r\n     * @returns {string} - The shape visual  variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static SHAPE() {\r\n        return defaultsFile.visualVariables.SHAPE;\r\n    }\r\n\r\n    /**\r\n     * The position visual variable.\r\n     * @static\r\n     * @returns {string} - The position visual variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static POSITION() {\r\n        return defaultsFile.visualVariables.POSITION;\r\n    }\r\n\r\n    /**\r\n     * The variable that is used to hold the matrix projection \r\n     * @static\r\n     * @returns {string} - the projection matrix variable name on all shaders.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static MPROJ() {\r\n        return defaultsFile.defaultShadersVariables.projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * The texture visual variable.\r\n     * @static\r\n     * @returns {string} - The texture visual variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static TEXTURE() {\r\n        return defaultsFile.visualVariables.TEXTURE;\r\n    }\r\n\r\n    /**\r\n     * The size visual variable.\r\n     * @static\r\n     * @returns {string} - The size visual variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static SIZE() {\r\n        return defaultsFile.visualVariables.SIZE;\r\n    }\r\n\r\n    /**\r\n     * The orientation visual variable.\r\n     * @static\r\n     * @returns {string} - The orientation visual  variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static ORIENTATION() {\r\n        return defaultsFile.visualVariables.ORIENTATION;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given shape.\r\n     * @static\r\n     * @param {string} shapeName - The name of the given shape.\r\n     * @returns {number} - the index of the given shape.\r\n     * @throws {GisplayError} - If the given shape does not exist.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static findShapeIndex(shapeName) {\r\n        // console.warn(shapeTextureName);\r\n        let shapeIndex = defaultsFile.shapes[shapeName];\r\n        if (shapeIndex >= 0)\r\n            return shapeIndex;\r\n        throw new GisplayError(`Shape with name: ${shapeName}, not found.`);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given pattern.\r\n     * @static\r\n     * @param {string} patternName - The name of the given pattern.\r\n     * @returns {number} - the index of the given pattern.\r\n     * @throws {GisplayError} - If the given pattern does not exist.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static findPatternIndex(patternName) {\r\n        let patternIndex = defaultsFile.patterns[patternName];\r\n        if (patternIndex >= 0)\r\n            return patternIndex;\r\n        throw new GisplayError(`Pattern with name: ${patternName}, not found.`);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given figure name.\r\n     * @static\r\n     * @param {string} figureName - The figure name. \r\n     * @returns {number} - the index of the given figure name.\r\n     * @throws {GisplayError} - If the given figure does not exist.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static findFigureIndex(figureName) {\r\n        let figureIndex = defaultsFile.figures[figureName];\r\n        if (figureIndex >= 0)\r\n            return figureIndex;\r\n        throw new GisplayError(`Figure with name: ${figureName}, not found.`);\r\n    }\r\n\r\n    /**\r\n     * Returns the default color.\r\n     * @static\r\n     * @returns {Array<number>}  - the default color. \r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultColor() {\r\n        return defaultsFile.defaultColor;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the default shape.\r\n     * @static\r\n     * @returns {number} - the index of the default shape .\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultShapeIndex() {\r\n        return this.findShapeIndex(defaultsFile.defaultShape); //GisplayDefaults.CIRCLE_FULL.name);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the default texture.\r\n     * @static\r\n     * @returns {number} - the index of the default texture.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultTextureIndex() {\r\n        return this.findShapeIndex(defaultsFile.defaultTexture);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the default figure.\r\n     * @static\r\n     * @returns {number} - the index of the default figure.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultFigureIndex() {\r\n        return this.findFigureIndex(defaultsFile.defaultFigure);\r\n    }\r\n\r\n    /**\r\n     * Returns the default size of a point for the Gisplay API.\r\n     * @static\r\n     * @returns {number=15} - the default size of a point for the Gisplay API.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultSizeValue() {\r\n        return defaultsFile.defaultSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the minimum size for points.\r\n     * @static\r\n     * @returns {number} -  the minimum size for points.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getMinSizeValue() {\r\n        return defaultsFile.minSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum size for points.\r\n     * @static\r\n     * @returns {number} -  the maximum size for points.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getMaxSizeValue() {\r\n        return defaultsFile.maxSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the default orientation of a figure or shape in the Gisplay API.\r\n     * @static\r\n     * @returns {number=0} - the default orientation of a figure or shape in the Gisplay API. \r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultOrientationValue() {\r\n        return defaultsFile.defaultOrientation;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     IMAGE DEFAUTLS     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the size of the any shape image.\r\n     * @static\r\n     * @returns {number} - the size of the any shape image.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getShapeImageSize() {\r\n        return defaultsFile.shapesImageSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the any pattern image.\r\n     * @static\r\n     * @returns {number} - the size of the any pattern image.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getPatternImageSize() {\r\n        return defaultsFile.patternsImageSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the any figure image.\r\n     * @static\r\n     * @returns {number} - the size of the any figure image.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getFigureImageSize() {\r\n        return defaultsFile.figuresImageSize;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     WEBGL DEFAUTLS     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * The default alpha value for the \r\n     * @returns \r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultAlphaValue() {\r\n        return defaultsFile.defaultAlpha;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bytes for each element of a Float32Array.\r\n     * @static\r\n     * @returns {number} - the number of bytes for each element of a Float32Array.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getFloat32BytesPerElement() {\r\n        return Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    /**\r\n     * The number of bytes for each element of a Uint8Array (Unsigned int).\r\n     * @static\r\n     * @returns {number} - the number of bytes for each element of a Uint8Array (Unsigned int).\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getUint8BytesPerElement() {\r\n        return Uint8Array.BYTES_PER_ELEMENTM;\r\n    }\r\n\r\n    /**\r\n     * Returns the names of the borders files (vertex and fragment shaders).\r\n     * @static\r\n     * @returns {{borderVertexFileName: string, borderFragmentFileName:string}}\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getBordersShadersFileNames() {\r\n        return { borderVertexFileName: 'borders.vert', borderFragmentFileName: 'borders.frag' };\r\n    }\r\n\r\n    /**\r\n     * Returns the default color for the borders.\r\n     * @static\r\n     * @returns {Array<number>} - the default color for the borders.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getDefaultBordersColor() {\r\n        return [0, 0, 0];\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     WEBGL SIZE     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * The min data name to be used in all shaders that use size as a visual variable.\r\n     * @static\r\n     * @returns {string} - min data name to be used in all shaders that use size as a visual variable.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getMinSizeDataName() {\r\n        return 'minData';\r\n    }\r\n\r\n    /**\r\n     * The max data name to be used in all shaders that use size as a visual variable.\r\n     * @static\r\n     * @returns {string} - max data name to be used in all shaders that use size as a visual variable.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getMaxSizeDataName() {\r\n        return 'maxData';\r\n    }\r\n\r\n    static getMinSizePixels() {\r\n        return { name: 'minPixels', value: defaultsFile.minSize };\r\n    }\r\n\r\n    static getMaxSizePixels() {\r\n        return { name: 'maxPixels', value: defaultsFile.maxSize };\r\n    }\r\n\r\n    /**\r\n     * Returns the type of primitive we want.\r\n     * @static\r\n     * @returns \r\n     * @memberof GisplayDefaults\r\n     */\r\n    static getPrimitive() {\r\n        return {\r\n            POINT: 0,\r\n            POLYGON: 1,\r\n            LINE: 2,\r\n            CSVPOINT: 3,\r\n            CSVIDS: 4\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given primitive is polygon.\r\n     * @static\r\n     * @param {number} geoPrimitive - The identifier of the primitive. \r\n     * @returns {boolean} - true if the given primitive is polygon.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static hasPolygons(geoPrimitive) {\r\n        return geoPrimitive === this.getPrimitive().POLYGON;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given primitive is line.\r\n     * @static\r\n     * @param {number} geoPrimitive - The identifier of the primitive. \r\n     * @returns {boolean} - true if the given primitive is line.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static hasLines(geoPrimitive) {\r\n        return geoPrimitive === this.getPrimitive().LINE;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given primitive is line.\r\n     * @static\r\n     * @param {number} geoPrimitive - The identifier of the primitive. \r\n     * @returns {boolean} - true if the given primitive is line.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static hasPoints(geoPrimitive) {\r\n        return geoPrimitive === this.getPrimitive().POINT;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given primitive is points coming from the CSV Parser.\r\n     * @static\r\n     * @param {number} geoPrimitive - The identifier of the primitive. \r\n     * @returns {boolean} - true if the given primitive is points coming from the CSV Parser.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static hasCSVPoints(geoPrimitive) {\r\n        return geoPrimitive === this.getPrimitive().CSVPOINT;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################      WEBGL PICKING     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Convert the given RGBA color color to it's respective integer value. \r\n     * @param {number} r - The red value.\r\n     * @param {number} g - The green value.\r\n     * @param {number} b - The blue value.\r\n     * @param {number} a - The alpha value.\r\n     * @returns {number} - the integer value converted from the given RGBA value.\r\n     * @see https://github.com/mcwhittemore/rgb-to-int/blob/master/index.js\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static RGBAToNumber(r, g, b, a) {\r\n        // return r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a;\r\n        return r * Math.pow(256, 3) + (g << 16 | b << 8 | a); // g<<16 === g * 2^16\r\n    }\r\n\r\n    /**\r\n     * Convert the given number to it's RGBA representation.\r\n     * @static\r\n     * @param {number} num - The number to be converted. \r\n     * @returns {Array<number>} - the RGBA representation of the given number.\r\n     * @see https://math.stackexchange.com/a/1636055\r\n     * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static numberToRGBA(num) {\r\n        let r = Math.floor(num / Math.pow(256, 3));\r\n        let g = Math.floor(num / Math.pow(256, 2) % 256);\r\n        let b = Math.floor(num / 256 % 256);\r\n        let a = num - (Math.pow(256, 3) * r + Math.pow(256, 2) * g + 256 * b);\r\n        return [r, g, b, a];\r\n    }\r\n\r\n    /**\r\n     * The name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n     * @static\r\n     * @returns {string} - he name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static isPickingName() {\r\n        return 'isPicking';\r\n    }\r\n\r\n    /**\r\n     * The name of the variable that holds the RGBA colors used for picking.\r\n     * @static\r\n     * @returns {string} - the name of the variable that holds the RGBA colors used for picking.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static pickingColorName() {\r\n        return 'pickingColor';\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the picking identifier for the MVC/TG.\r\n     * @static\r\n     * @returns {string} - the name of the picking identifier for the MVC/TG.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static pickingMVCTGIdentifierName() {\r\n        return \"MVCTGPickingColor\";\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     TIME DEFAUTLS     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the instant time variable.\r\n     * @static\r\n     * @returns {string} - the instant time variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static INSTANT() {\r\n        return defaultsFile.timeVariables.INSTANT;\r\n    }\r\n\r\n    /**\r\n     * Returns the interval time variable.\r\n     * @static\r\n     * @returns {string} -  the interval time variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static INTERVAL() {\r\n        return defaultsFile.timeVariables.INTERVAL;\r\n    }\r\n\r\n    /**\r\n     * The animation time variable.\r\n     * @static\r\n     * @returns {string} - the animation time variable.\r\n     * @memberOf GisplayDefaults\r\n     */\r\n    static ANIMATION() {\r\n        return defaultsFile.timeVariables.ANIMATION;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     DATA NATURE     ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the sequential data nature.\r\n     * @static\r\n     * @returns {string} - the sequential data nature.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static SEQUENTIAL() {\r\n        return 'sequential';\r\n    }\r\n\r\n    /**\r\n     * Returns the divergent data nature.\r\n     * @static\r\n     * @returns {string} - the divergent data nature.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static DIVERGENT() {\r\n        return 'divergent';\r\n    }\r\n\r\n    /**\r\n     * Returns the qualitative data nature.\r\n     * @static\r\n     * @returns {string} - the qualitative data nature.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static QUALITATIVE() {\r\n        return 'qualitative';\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     MESSAGES CSV       ######################\r\n    #####################################################################\r\n    */\r\n    static MESSAGES_CSV() {\r\n        return {\r\n            TO_START: 'start', //From TP to Ws to start processing their part\r\n            END_START: 'end_start', //FROM each W to TP flag that the W as terminated its part\r\n\r\n            /*  TO_REMAINING_ROWS11: 'remaining_rows', //FROM TP to first W to process remaining rows\r\n             END_REMAINING_ROWS1: 'end_remaining_rows', //FROM first W to TP to flag worker processed remaining rows */\r\n\r\n            TO_LIMITS_CAT: 'limits_categories', //FROM TP to Ws to get the min and max and categories for each cat and cont vars \r\n            END_LIMITS_CAT: 'end_limits_categories', //FROM each W to TP with min/max and categories\r\n\r\n            TO_LIMITS_CAT_RES: 'limits_categories_res', //FROM TP to Ws with the resulting classes/categories and time granules\r\n            END_LIMITS_CAT_RES: 'end_limits_categories_res', //FROM each W to TP meaning the W has all the MVCs and TGs in place\r\n\r\n            TO_JOIN_DATA: 'join_data', //FROM TP To Ws with information about MVCs and TGs in order to join the final rows\r\n            END_JOIN_DATA: 'end_join_data', //FROM Ws To TP as a flag to receive data\r\n\r\n            TO_GENERATE_RGBA: 'generate_rgba',//FROM TP To Ws to generate RGBA information for each row\r\n            END_GENERATE_RGBA: 'end_generate_rgba', //FROM each W to TP meaning the W generated all RGBA values\r\n\r\n            TO_SEND_DATA: 'send_data', //FROM TP to one W at a time to receive its data\r\n            END_SEND_DATA: 'end_send_data' //FROM W to TP with the MVCs and TGs created \r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clone a nested array in Javascript.\r\n     * @static\r\n     * @param {Array<any>} arr - The given array. \r\n     * @returns {Array<any>} - the cloned nested array.\r\n     * @memberof GisplayDefaults\r\n     */\r\n    static cloneNestedArray(arr) {\r\n        let i, copy;\r\n        if (Array.isArray(arr)) {\r\n            copy = arr.slice(0);\r\n            for (let i = 0; i < copy.length; i++)\r\n                copy[i] = this.cloneNestedArray(copy[i]);\r\n            return copy;\r\n        } else if (typeof arr === 'object')\r\n            throw new Error('Cannot clone array containing an object!');\r\n        else\r\n            return arr;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/GisplayDefaults.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "GisplayDefaults",
    "memberof": "src/Gisplay/GisplayDefaults.js",
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayDefaults.js",
    "importStyle": "{GisplayDefaults}",
    "description": "Class that exports the Gisplay default values.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GisplayDefaults"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "getAvailableClassBreaksMethods",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getAvailableClassBreaksMethods",
    "access": "public",
    "description": "Returns the available class break methods.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string[]} - All available class break methods under Gisplay API."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayOptions"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "All available class break methods under Gisplay API."
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "getAvailableBackgroundProviders",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getAvailableBackgroundProviders",
    "access": "public",
    "description": "Returns a list of available background map providers.",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string[]} - All available background map providers under Gisplay API."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "All available background map providers under Gisplay API."
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "getDefaultClassBreakMethod",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultClassBreakMethod",
    "access": "public",
    "description": "Returns the default class method to calculate classes for continuous variables.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - Returns quantiles, the default method for class calculation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Returns quantiles, the default method for class calculation."
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "getAvailableGranularities",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getAvailableGranularities",
    "access": "public",
    "description": "Returns the list of available granularities.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "getAvailableColorBrewerMethods",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getAvailableColorBrewerMethods",
    "access": "public",
    "description": "Returns the available color brewer methods.",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the available color brewer methods."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the available color brewer methods."
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "getGranule",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getGranule",
    "access": "public",
    "description": "Convert the time string to the granularity we want.",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The granul"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "timeString",
        "description": "The time as it was read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The granul"
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "COLOR",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.COLOR",
    "access": "public",
    "description": "The color visual variable.",
    "lineNumber": 138,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the string 'color'."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the string 'color'."
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "OPACITY",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.OPACITY",
    "access": "public",
    "description": "The saturation visual variable.",
    "lineNumber": 148,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The saturation visual variable string. "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The saturation visual variable string."
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "SHAPE",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.SHAPE",
    "access": "public",
    "description": "The shape visual variable.",
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The shape visual  variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The shape visual  variable."
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "POSITION",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.POSITION",
    "access": "public",
    "description": "The position visual variable.",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The position visual variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The position visual variable."
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "MPROJ",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.MPROJ",
    "access": "public",
    "description": "The variable that is used to hold the matrix projection ",
    "lineNumber": 178,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the projection matrix variable name on all shaders."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the projection matrix variable name on all shaders."
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "TEXTURE",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.TEXTURE",
    "access": "public",
    "description": "The texture visual variable.",
    "lineNumber": 188,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The texture visual variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The texture visual variable."
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "SIZE",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.SIZE",
    "access": "public",
    "description": "The size visual variable.",
    "lineNumber": 198,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The size visual variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The size visual variable."
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "ORIENTATION",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.ORIENTATION",
    "access": "public",
    "description": "The orientation visual variable.",
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The orientation visual  variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The orientation visual  variable."
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "findShapeIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.findShapeIndex",
    "access": "public",
    "description": "Returns the index of the given shape.",
    "lineNumber": 220,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given shape."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "shapeName",
        "description": "The name of the given shape."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given shape."
    },
    "throws": [
      {
        "types": [
          "GisplayError"
        ],
        "description": "If the given shape does not exist."
      }
    ]
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "findPatternIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.findPatternIndex",
    "access": "public",
    "description": "Returns the index of the given pattern.",
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given pattern."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "patternName",
        "description": "The name of the given pattern."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given pattern."
    },
    "throws": [
      {
        "types": [
          "GisplayError"
        ],
        "description": "If the given pattern does not exist."
      }
    ]
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "findFigureIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.findFigureIndex",
    "access": "public",
    "description": "Returns the index of the given figure name.",
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given figure name."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "figureName",
        "description": "The figure name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given figure name."
    },
    "throws": [
      {
        "types": [
          "GisplayError"
        ],
        "description": "If the given figure does not exist."
      }
    ]
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "getDefaultColor",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultColor",
    "access": "public",
    "description": "Returns the default color.",
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>}  - the default color. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the default color."
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "getDefaultShapeIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultShapeIndex",
    "access": "public",
    "description": "Returns the index of the default shape.",
    "lineNumber": 274,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the default shape ."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the default shape ."
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "getDefaultTextureIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultTextureIndex",
    "access": "public",
    "description": "Returns the index of the default texture.",
    "lineNumber": 284,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the default texture."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the default texture."
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "getDefaultFigureIndex",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultFigureIndex",
    "access": "public",
    "description": "Returns the index of the default figure.",
    "lineNumber": 294,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the default figure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the default figure."
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "getDefaultSizeValue",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultSizeValue",
    "access": "public",
    "description": "Returns the default size of a point for the Gisplay API.",
    "lineNumber": 304,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number=15} - the default size of a point for the Gisplay API."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number=15"
      ],
      "spread": false,
      "description": "the default size of a point for the Gisplay API."
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "getMinSizeValue",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMinSizeValue",
    "access": "public",
    "description": "Returns the minimum size for points.",
    "lineNumber": 314,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} -  the minimum size for points."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minimum size for points."
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "getMaxSizeValue",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMaxSizeValue",
    "access": "public",
    "description": "Returns the maximum size for points.",
    "lineNumber": 324,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} -  the maximum size for points."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the maximum size for points."
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "getDefaultOrientationValue",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultOrientationValue",
    "access": "public",
    "description": "Returns the default orientation of a figure or shape in the Gisplay API.",
    "lineNumber": 334,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number=0} - the default orientation of a figure or shape in the Gisplay API. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number=0"
      ],
      "spread": false,
      "description": "the default orientation of a figure or shape in the Gisplay API."
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "getShapeImageSize",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getShapeImageSize",
    "access": "public",
    "description": "Returns the size of the any shape image.",
    "lineNumber": 349,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size of the any shape image."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size of the any shape image."
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "getPatternImageSize",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getPatternImageSize",
    "access": "public",
    "description": "Returns the size of the any pattern image.",
    "lineNumber": 359,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size of the any pattern image."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size of the any pattern image."
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "getFigureImageSize",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getFigureImageSize",
    "access": "public",
    "description": "Returns the size of the any figure image.",
    "lineNumber": 369,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size of the any figure image."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size of the any figure image."
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "getDefaultAlphaValue",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultAlphaValue",
    "access": "public",
    "description": "The default alpha value for the ",
    "lineNumber": 383,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "getFloat32BytesPerElement",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getFloat32BytesPerElement",
    "access": "public",
    "description": "Returns the number of bytes for each element of a Float32Array.",
    "lineNumber": 393,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the number of bytes for each element of a Float32Array."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of bytes for each element of a Float32Array."
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "getUint8BytesPerElement",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getUint8BytesPerElement",
    "access": "public",
    "description": "The number of bytes for each element of a Uint8Array (Unsigned int).",
    "lineNumber": 403,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the number of bytes for each element of a Uint8Array (Unsigned int)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of bytes for each element of a Uint8Array (Unsigned int)."
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "getBordersShadersFileNames",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getBordersShadersFileNames",
    "access": "public",
    "description": "Returns the names of the borders files (vertex and fragment shaders).",
    "lineNumber": 413,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{borderVertexFileName: string, borderFragmentFileName:string}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{borderVertexFileName: string, borderFragmentFileName:string}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "getDefaultBordersColor",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getDefaultBordersColor",
    "access": "public",
    "description": "Returns the default color for the borders.",
    "lineNumber": 423,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the default color for the borders."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the default color for the borders."
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "getMinSizeDataName",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMinSizeDataName",
    "access": "public",
    "description": "The min data name to be used in all shaders that use size as a visual variable.",
    "lineNumber": 438,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - min data name to be used in all shaders that use size as a visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "min data name to be used in all shaders that use size as a visual variable."
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "getMaxSizeDataName",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMaxSizeDataName",
    "access": "public",
    "description": "The max data name to be used in all shaders that use size as a visual variable.",
    "lineNumber": 448,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - max data name to be used in all shaders that use size as a visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "max data name to be used in all shaders that use size as a visual variable."
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "getMinSizePixels",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMinSizePixels",
    "access": "public",
    "description": null,
    "lineNumber": 452,
    "undocument": true
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "getMaxSizePixels",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getMaxSizePixels",
    "access": "public",
    "description": null,
    "lineNumber": 456,
    "undocument": true
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "getPrimitive",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.getPrimitive",
    "access": "public",
    "description": "Returns the type of primitive we want.",
    "lineNumber": 466,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "hasPolygons",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.hasPolygons",
    "access": "public",
    "description": "Returns true if the given primitive is polygon.",
    "lineNumber": 483,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the given primitive is polygon."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geoPrimitive",
        "description": "The identifier of the primitive."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given primitive is polygon."
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "hasLines",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.hasLines",
    "access": "public",
    "description": "Returns true if the given primitive is line.",
    "lineNumber": 494,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the given primitive is line."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geoPrimitive",
        "description": "The identifier of the primitive."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given primitive is line."
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "hasPoints",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.hasPoints",
    "access": "public",
    "description": "Returns true if the given primitive is line.",
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the given primitive is line."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geoPrimitive",
        "description": "The identifier of the primitive."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given primitive is line."
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "hasCSVPoints",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.hasCSVPoints",
    "access": "public",
    "description": "Returns true if the given primitive is points coming from the CSV Parser.",
    "lineNumber": 516,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the given primitive is points coming from the CSV Parser."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geoPrimitive",
        "description": "The identifier of the primitive."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the given primitive is points coming from the CSV Parser."
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "RGBAToNumber",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.RGBAToNumber",
    "access": "public",
    "description": "Convert the given RGBA color color to it's respective integer value. ",
    "see": [
      "https://github.com/mcwhittemore/rgb-to-int/blob/master/index.js"
    ],
    "lineNumber": 535,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the integer value converted from the given RGBA value."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "The red value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "g",
        "description": "The green value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "The blue value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "The alpha value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the integer value converted from the given RGBA value."
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "numberToRGBA",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.numberToRGBA",
    "access": "public",
    "description": "Convert the given number to it's RGBA representation.",
    "see": [
      "https://math.stackexchange.com/a/1636055",
      "https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"
    ],
    "lineNumber": 549,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the RGBA representation of the given number."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "The number to be converted."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the RGBA representation of the given number."
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "isPickingName",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.isPickingName",
    "access": "public",
    "description": "The name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.",
    "lineNumber": 563,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - he name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "he name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw."
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "pickingColorName",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.pickingColorName",
    "access": "public",
    "description": "The name of the variable that holds the RGBA colors used for picking.",
    "lineNumber": 573,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the variable that holds the RGBA colors used for picking."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the variable that holds the RGBA colors used for picking."
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "pickingMVCTGIdentifierName",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.pickingMVCTGIdentifierName",
    "access": "public",
    "description": "Returns the name of the picking identifier for the MVC/TG.",
    "lineNumber": 583,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the picking identifier for the MVC/TG."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the picking identifier for the MVC/TG."
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "INSTANT",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.INSTANT",
    "access": "public",
    "description": "Returns the instant time variable.",
    "lineNumber": 598,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the instant time variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the instant time variable."
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "INTERVAL",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.INTERVAL",
    "access": "public",
    "description": "Returns the interval time variable.",
    "lineNumber": 608,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} -  the interval time variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the interval time variable."
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "ANIMATION",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.ANIMATION",
    "access": "public",
    "description": "The animation time variable.",
    "lineNumber": 618,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the animation time variable."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDefaults"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the animation time variable."
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "SEQUENTIAL",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.SEQUENTIAL",
    "access": "public",
    "description": "Returns the sequential data nature.",
    "lineNumber": 633,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the sequential data nature."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the sequential data nature."
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "DIVERGENT",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.DIVERGENT",
    "access": "public",
    "description": "Returns the divergent data nature.",
    "lineNumber": 643,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the divergent data nature."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the divergent data nature."
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "QUALITATIVE",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.QUALITATIVE",
    "access": "public",
    "description": "Returns the qualitative data nature.",
    "lineNumber": 653,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the qualitative data nature."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the qualitative data nature."
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "MESSAGES_CSV",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.MESSAGES_CSV",
    "access": "public",
    "description": null,
    "lineNumber": 662,
    "undocument": true
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "cloneNestedArray",
    "memberof": "src/Gisplay/GisplayDefaults.js~GisplayDefaults",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/GisplayDefaults.js~GisplayDefaults.cloneNestedArray",
    "access": "public",
    "description": "Clone a nested array in Javascript.",
    "lineNumber": 694,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<any>} - the cloned nested array."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<any>"
        ],
        "spread": false,
        "optional": false,
        "name": "arr",
        "description": "The given array."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<any>"
      ],
      "spread": false,
      "description": "the cloned nested array."
    }
  },
  {
    "__docId__": 113,
    "kind": "file",
    "name": "src/Gisplay/GisplayDynamicLoader.js",
    "content": "import shadersFile from './Shaders/shaders.json';\r\nimport defaultsFile from './defaults.json';\r\nconst vertexShadersFiles = require.context(\"./Shaders\", false, /^\\.\\/.*\\.vert$/); //All .vert files\r\nconst fragmentShadersFiles = require.context(\"./Shaders\", false, /^\\.\\/.*\\.frag$/); //All .frag files\r\nimport shapesImage from '../img/novas.png'; //Shapes\r\nimport patternsImage from '../img/patterns.png'; //Patterns\r\nimport figuresImage from '../img/figures.png'; //Figures\r\n\r\nimport loader from '../css/loader.css'; //Gisplay Loader \r\nimport fonts from '../css/fonts.css'; //Fonts to use\r\nimport errorModal from '../css/error.css'; //The error modal CSS\r\nimport noUiSlider from '../lib/noUiSlider/nouislider.css'; //Time Control Slider CSS\r\n\r\nimport balloonCSS from '../lib/balloon.css/balloon.css'; //CSS for Tooltips\r\n\r\nimport { ShadersInfo } from './Shaders/ShadersInfo';\r\n\r\n/**\r\n * Gisplay Dynamic Loader implementation.\r\n * @export\r\n * @class GisplayDynamicLoader\r\n */\r\nexport class GisplayDynamicLoader {\r\n    constructor(libraryName, vertexShaderFileName, fragmentShaderFileName) {\r\n        // console.log(libraryName, vertexShaderFileName, fragmentShaderFileName);\r\n        /**\r\n         * The number of expected elements to load.\r\n         * E.g. Mapbox has 1 CSS element and 1 JS element and none was already loaded then we 2 elements to load. \r\n         * @type {number}\r\n         */\r\n        this.numLibraryElemsToLoad = 0;\r\n        if (!this._isLibraryLoaded(libraryName))\r\n            this.loadLibrary(libraryName);\r\n        else\r\n            this.libraryElementLoaded();\r\n\r\n        /**\r\n         * The image with shapes.\r\n         * @type {HTMLImageElement}\r\n         */\r\n        this.shapesImage = this.loadImage(shapesImage, 'shapesImageLoaded');//this.loadShapesImage();\r\n        /**\r\n         * The image with patterns.\r\n         * @type {HTMLImageElement}\r\n         */\r\n        this.patternsImage = this.loadImage(patternsImage, 'patternsImageLoaded');//this.loadPatternsImage();\r\n        /**\r\n         * The image with figures.\r\n         * @type {HTMLImageElement}\r\n         */\r\n        this.figuresImage = this.loadImage(figuresImage, 'figuresImageLoaded');\r\n\r\n        /**\r\n         * The information about the shader.\r\n         * @type {ShadersInfo}\r\n         */\r\n        this.shadersInfo = this.loadShadersOptionsFile(vertexShaderFileName, fragmentShaderFileName);\r\n    }\r\n\r\n    /**\r\n     * Verifies if the library CSS and JS are loaded into the HTML. If they are then there's no need to load it again\r\n     * so this will return true, otherwise, returns false.\r\n     * @param {string} libraryName - The name of the library (e.g.  Mapbox). \r\n     * @returns {boolean} - true if the js and css (if any) of the library were already loaded by the user, false, otherwise.\r\n     * @see https://stackoverflow.com/a/37820644\r\n     * @see https://css-tricks.com/snippets/javascript/async-script-loader-with-callback/\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    _isLibraryLoaded(libraryName) {\r\n        let scriptsSource = this.loadDefaultsFile().bgmapsUrls[libraryName].js;\r\n        let stylesSource = this.loadDefaultsFile().bgmapsUrls[libraryName].css;\r\n        if (stylesSource)\r\n            this.numLibraryElemsToLoad += stylesSource.length;\r\n        if (scriptsSource)\r\n            this.numLibraryElemsToLoad += scriptsSource.length;\r\n        // console.warn(this.numLibraryElemsToLoad);\r\n        switch (libraryName) {\r\n            case 'MB':\r\n                return this._hasScript(scriptsSource) && this._hasStyle(stylesSource);\r\n            case 'GM':\r\n                return this._hasScript(libraryName);\r\n            case 'HM':\r\n                {\r\n                    for (let src of scriptsSource)\r\n                        if (!this._hasScript(src))\r\n                            return false;\r\n                    return true;\r\n                }\r\n            case 'BM':\r\n                return this._hasScript(scriptsSource);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given the script source, verifies if it exists on the DOM or not.\r\n     * @param {string} scriptSource - The source of the script.\r\n     * @returns {boolean} - true, if the script exists in the DOM, false, otherwise.\r\n     * @private\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    _hasScript(scriptSource) {\r\n        return document.querySelectorAll(`[src='${scriptSource}']`).length === 1;\r\n    }\r\n\r\n    /**\r\n     * Given the source for the stylesheet, verifies if it exists on the DOM or not.\r\n     * @param {string} libraryName - The source of the stylesheet.\r\n     * @returns {boolean} - true, if the style exists in the DOM, false, otherwise.\r\n     * @private\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    _hasStyle(styleSource) {\r\n        return document.querySelectorAll(`[href='${styleSource}']`).length === 1;\r\n    }\r\n\r\n    /**\r\n     * This method should be used to asynchronously or synchronously load the library for Mapbox, Google etc\r\n     * so this way we won't need to load it on the main html file.\r\n     * @param {string} libraryName - Name of the library to load. \r\n     * @memberOf LayoutManager\r\n     */\r\n    loadLibrary(libraryName) {\r\n        // console.error(\"Load Library >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\r\n        let scriptsSource = this.loadDefaultsFile().bgmapsUrls[libraryName].js;\r\n        let stylesSource = this.loadDefaultsFile().bgmapsUrls[libraryName].css;\r\n        switch (libraryName) {\r\n            case 'MB':\r\n            case 'MBGL':\r\n                {\r\n                    this._loadStyleSheet(stylesSource[0]);\r\n                    this._loadScript(scriptsSource[0]);\r\n                }\r\n                break;\r\n            case 'GM':\r\n                this._loadScript(scriptsSource[0]);\r\n                break;\r\n            case 'HM':\r\n                this._loadHereMapsRecursive(this.loadDefaultsFile().bgmapsUrls[libraryName].js, this.numLibraryElemsToLoad);\r\n                break;\r\n            case 'BM':\r\n                this._loadScript(scriptsSource[0]);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load script dynamically.\r\n     * @param {string} scriptSource - The script source.\r\n     * @private\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    _loadScript(scriptSource) {\r\n        let js = document.createElement('script');\r\n        js.src = scriptSource;\r\n        js.onload = (e) => { this.libraryElementLoaded(e); };\r\n        document.head.appendChild(js);\r\n    }\r\n\r\n    /**\r\n     * Load stylesheet dynamically.\r\n     * @param {string} styleSheetSource - The stylesheet source. \r\n     * @private\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    _loadStyleSheet(styleSheetSource) {\r\n        let css = document.createElement(\"link\");\r\n        css.rel = \"stylesheet\";\r\n        css.type = \"text/css\";\r\n        css.href = styleSheetSource;\r\n        css.onload = (e) => { this.libraryElementLoaded(e); };\r\n        document.head.appendChild(css);\r\n    }\r\n\r\n    /**\r\n     * Recursive method to load Here Maps library scripts. This method is recursive because the three scripts for here maps \r\n     * must be loaded in order.\r\n     * @param {Array<string>} jsFiles -  The src for each of the js files for here maps.\r\n     * @private\r\n     * @see https://stackoverflow.com/a/38841736\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    _loadHereMapsRecursive(jsFiles, numberOfScripts) {\r\n        let js = document.createElement('script');\r\n        js.src = jsFiles[0];\r\n        js.onload = (e) => {\r\n            this.libraryElementLoaded(e);\r\n            jsFiles = jsFiles.slice(1, numberOfScripts);\r\n            if (jsFiles.length > 0)\r\n                this._loadHereMapsRecursive(jsFiles);\r\n        };\r\n        document.head.appendChild(js);\r\n    }\r\n\r\n    /**\r\n     * Callback for the load event of the CSS or JS library elements.\r\n     * @param {Event} e - The load callback event.\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    libraryElementLoaded(e) {\r\n        // console.error(e);\r\n        if (--this.numLibraryElemsToLoad <= 0) {\r\n            console.warn(\"All library elements loaded\");\r\n            document.dispatchEvent(new CustomEvent(\"libraryLoaded\", {}));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads the json file with shaders options.\r\n     * @returns {ShadersInfo} - the json file with shaders options.\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    loadShadersOptionsFile(vertexShaderFileName, fragmentShaderFileName) {\r\n        // console.log(shadersFile, vertexShaderFileName, fragmentShaderFileName);\r\n        let vertexKeys = shadersFile.vertex[vertexShaderFileName];\r\n        let fragmentKeys = shadersFile.fragment[fragmentShaderFileName];\r\n        return new ShadersInfo(vertexKeys, fragmentKeys);\r\n    }\r\n\r\n    /**\r\n     * Returns the information about the shader.\r\n     * @returns {ShaderInfo} - the information about the shader.\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    getShadersInfo() {\r\n        return this.shadersInfo;\r\n    }\r\n\r\n    /**\r\n     * Given the name of the vertex shader and the fragment shader then loads their content into memory.\r\n     * @param {string} vertexShaderFileName - The name of the vertex shader file.\r\n     * @param {string} fragmentShaderFileName - The name of the fragment shader file.\r\n     * @returns {{vertexShaderCode:string, fragmentShaderCode:string}} - the vertex and fragment shaders code.\r\n     * @see https://stackoverflow.com/a/41410938\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    loadShaders(vertexShaderFileName, fragmentShaderFileName) {\r\n        // console.log(vertexShaderFileName, fragmentShaderFileName);\r\n        // this.loadShadersOptionsFile(vertexShaderFileName, fragmentShaderFileName);\r\n        let vertexShaderCode = '';\r\n        let fragmentShaderCode = '';\r\n        for (let vertexShaderName of vertexShadersFiles.keys()) {\r\n            // console.log(vertexShaderName);\r\n            if (vertexShaderName.split('./')[1] === vertexShaderFileName)\r\n                vertexShaderCode = vertexShadersFiles(vertexShaderName);\r\n        }\r\n        if (!vertexShaderCode)\r\n            throw new Error(`The file name: ${vertexShaderFileName}, for the vertex shader wasn\\'t  found on the Shaders directory.`);\r\n\r\n        for (let fragmenShaderName of fragmentShadersFiles.keys()) {\r\n            // console.log(fragmenShaderName);\r\n            if (fragmenShaderName.split('./')[1] === fragmentShaderFileName)\r\n                fragmentShaderCode = fragmentShadersFiles(fragmenShaderName);\r\n        }\r\n        if (!fragmentShaderCode)\r\n            throw new Error(`The file name: ${fragmentShaderFileName}, for the fragment shader wasn\\'t  found on the Shaders directory.`);\r\n\r\n        //Create Shaders class based on the fileName\r\n        return { vertexShaderCode, fragmentShaderCode };\r\n    }\r\n\r\n    /**\r\n     * Load the given image and then fire the given event.\r\n     * @param {string} srcImage - The src of the image to load. \r\n     * @param {string} eventToFire - The name of the event to fire after loading the image. \r\n     * @returns {Image} - the loaded image.\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    loadImage(srcImage, eventToFire) {\r\n        let resImage = new Image();\r\n        // console.log(srcImage);\r\n        resImage.src = srcImage;\r\n        resImage.onload = () => { document.dispatchEvent(new CustomEvent(eventToFire, {})); };\r\n        return resImage;\r\n    }\r\n\r\n    /**\r\n     * Loads the json file with the default values.\r\n     * @returns {JSON} - the json file with the default values.\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    loadDefaultsFile() {\r\n        return defaultsFile;\r\n    }\r\n\r\n    /**\r\n     * Returns the image with the shapes.\r\n     * @returns {HTMLImageElement}\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    getShapesImage() {\r\n        return this.shapesImage;\r\n    }\r\n\r\n    /**\r\n     * Returns the image with the patterns.\r\n     * @returns {HTMLImageElement}\r\n     * @memberOf GisplayDynamicLoader\r\n     */\r\n    getPatternsImage() {\r\n        return this.patternsImage;\r\n    }\r\n\r\n    /**\r\n     * Returns the image with the figures.\r\n     * @returns {Image} - the image with the figures.\r\n     * @memberof GisplayDynamicLoader\r\n     */\r\n    getFiguresImage() {\r\n        return this.figuresImage;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/GisplayDynamicLoader.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "name": "vertexShadersFiles",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js",
    "static": true,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~vertexShadersFiles",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayDynamicLoader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 115,
    "kind": "variable",
    "name": "fragmentShadersFiles",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js",
    "static": true,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~fragmentShadersFiles",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayDynamicLoader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 116,
    "kind": "class",
    "name": "GisplayDynamicLoader",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js",
    "static": true,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayDynamicLoader.js",
    "importStyle": "{GisplayDynamicLoader}",
    "description": "Gisplay Dynamic Loader implementation.",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 117,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "numLibraryElemsToLoad",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#numLibraryElemsToLoad",
    "access": "public",
    "description": "The number of expected elements to load.\nE.g. Mapbox has 1 CSS element and 1 JS element and none was already loaded then we 2 elements to load. ",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "shapesImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#shapesImage",
    "access": "public",
    "description": "The image with shapes.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "HTMLImageElement"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "patternsImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#patternsImage",
    "access": "public",
    "description": "The image with patterns.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "HTMLImageElement"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "figuresImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#figuresImage",
    "access": "public",
    "description": "The image with figures.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "HTMLImageElement"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "shadersInfo",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#shadersInfo",
    "access": "public",
    "description": "The information about the shader.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "ShadersInfo"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "_isLibraryLoaded",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_isLibraryLoaded",
    "access": "private",
    "description": "Verifies if the library CSS and JS are loaded into the HTML. If they are then there's no need to load it again\nso this will return true, otherwise, returns false.",
    "see": [
      "https://stackoverflow.com/a/37820644",
      "https://css-tricks.com/snippets/javascript/async-script-loader-with-callback/"
    ],
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the js and css (if any) of the library were already loaded by the user, false, otherwise."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryName",
        "description": "The name of the library (e.g.  Mapbox)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the js and css (if any) of the library were already loaded by the user, false, otherwise."
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "_hasScript",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_hasScript",
    "access": "private",
    "description": "Given the script source, verifies if it exists on the DOM or not.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if the script exists in the DOM, false, otherwise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "scriptSource",
        "description": "The source of the script."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if the script exists in the DOM, false, otherwise."
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "_hasStyle",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_hasStyle",
    "access": "private",
    "description": "Given the source for the stylesheet, verifies if it exists on the DOM or not.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if the style exists in the DOM, false, otherwise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryName",
        "description": "The source of the stylesheet."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if the style exists in the DOM, false, otherwise."
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "loadLibrary",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#loadLibrary",
    "access": "public",
    "description": "This method should be used to asynchronously or synchronously load the library for Mapbox, Google etc\nso this way we won't need to load it on the main html file.",
    "lineNumber": 122,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "LayoutManager"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryName",
        "description": "Name of the library to load."
      }
    ]
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_loadScript",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_loadScript",
    "access": "private",
    "description": "Load script dynamically.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "scriptSource",
        "description": "The script source."
      }
    ]
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_loadStyleSheet",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_loadStyleSheet",
    "access": "private",
    "description": "Load stylesheet dynamically.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "styleSheetSource",
        "description": "The stylesheet source."
      }
    ]
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "_loadHereMapsRecursive",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#_loadHereMapsRecursive",
    "access": "private",
    "description": "Recursive method to load Here Maps library scripts. This method is recursive because the three scripts for here maps \nmust be loaded in order.",
    "see": [
      "https://stackoverflow.com/a/38841736"
    ],
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "jsFiles",
        "description": "The src for each of the js files for here maps."
      }
    ]
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "libraryElementLoaded",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#libraryElementLoaded",
    "access": "public",
    "description": "Callback for the load event of the CSS or JS library elements.",
    "lineNumber": 199,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Event"
        ],
        "spread": false,
        "optional": false,
        "name": "e",
        "description": "The load callback event."
      }
    ]
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "loadShadersOptionsFile",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#loadShadersOptionsFile",
    "access": "public",
    "description": "Loads the json file with shaders options.",
    "lineNumber": 212,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ShadersInfo} - the json file with shaders options."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ShadersInfo"
      ],
      "spread": false,
      "description": "the json file with shaders options."
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "getShadersInfo",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#getShadersInfo",
    "access": "public",
    "description": "Returns the information about the shader.",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ShaderInfo} - the information about the shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ShaderInfo"
      ],
      "spread": false,
      "description": "the information about the shader."
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "loadShaders",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#loadShaders",
    "access": "public",
    "description": "Given the name of the vertex shader and the fragment shader then loads their content into memory.",
    "see": [
      "https://stackoverflow.com/a/41410938"
    ],
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderCode:string, fragmentShaderCode:string}} - the vertex and fragment shaders code."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexShaderFileName",
        "description": "The name of the vertex shader file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fragmentShaderFileName",
        "description": "The name of the fragment shader file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderCode:string, fragmentShaderCode:string}"
      ],
      "spread": false,
      "description": "the vertex and fragment shaders code."
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "loadImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#loadImage",
    "access": "public",
    "description": "Load the given image and then fire the given event.",
    "lineNumber": 268,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Image} - the loaded image."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "srcImage",
        "description": "The src of the image to load."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventToFire",
        "description": "The name of the event to fire after loading the image."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Image"
      ],
      "spread": false,
      "description": "the loaded image."
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "loadDefaultsFile",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#loadDefaultsFile",
    "access": "public",
    "description": "Loads the json file with the default values.",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{JSON} - the json file with the default values."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "the json file with the default values."
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "getShapesImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#getShapesImage",
    "access": "public",
    "description": "Returns the image with the shapes.",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{HTMLImageElement}"
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HTMLImageElement"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "getPatternsImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#getPatternsImage",
    "access": "public",
    "description": "Returns the image with the patterns.",
    "lineNumber": 299,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{HTMLImageElement}"
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayDynamicLoader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HTMLImageElement"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "getFiguresImage",
    "memberof": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader#getFiguresImage",
    "access": "public",
    "description": "Returns the image with the figures.",
    "lineNumber": 308,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Image} - the image with the figures."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Image"
      ],
      "spread": false,
      "description": "the image with the figures."
    }
  },
  {
    "__docId__": 141,
    "kind": "file",
    "name": "src/Gisplay/GisplayError.js",
    "content": "\r\n/**\r\n * Custom Error to create a popup message to inform the user about a particular problem.\r\n * @export\r\n * @class GisplayError\r\n * @extends {Error}\r\n * @see https://medium.com/@xjamundx/custom-javascript-errors-in-es6-aa891b173f87\r\n */\r\nexport class GisplayError extends Error {\r\n\r\n    /**\r\n     * Creates an instance of GisplayError.\r\n     * @param {string} message - The message to provide to the user.\r\n     * @see https://github.com/codrops/ModalWindowEffects\r\n     * @see https://codepen.io/SMLMRKHLMS/pen/rVYRLQ \r\n     * @memberof GisplayError\r\n     */\r\n    constructor(message) {\r\n        super(message);\r\n        // Error.captureStackTrace(this, GisplayError);\r\n        console.error(\"GisplayError\");\r\n        // document.getElementById('head').innerHTML = '';\r\n\r\n        // this.createErrorDialog(message);\r\n        /*  let modal = document.createElement('div');\r\n         modal.className = 'modal';\r\n         let content = document.createElement('div');\r\n         content.className = 'content';\r\n         content.innerHTML = message;\r\n \r\n         modal.appendChild(content);\r\n         document.body.appendChild(modal); */\r\n\r\n        let modal = document.createElement('div');\r\n        modal.className = 'gisplayModal';\r\n\r\n        let overlay = document.createElement('div');\r\n        overlay.className = 'gisplayModalOverlay';\r\n\r\n        let content = document.createElement('div');\r\n        content.className = 'gisplayModalContent';\r\n\r\n        let contentTitle = document.createElement('div'); //Title\r\n        let errorFoundParagraph = document.createElement('p'); //Paragraph in title\r\n        errorFoundParagraph.innerHTML = 'Error found:';\r\n        contentTitle.appendChild(errorFoundParagraph);\r\n        let contentMessage = document.createElement('p'); //Content message\r\n        contentMessage.innerHTML = message;\r\n        let checkDevTools = document.createElement('button'); //Open devtools button\r\n        checkDevTools.innerHTML = 'Open Developer tools for more information';\r\n\r\n        content.appendChild(contentTitle);\r\n        content.appendChild(contentMessage);\r\n        content.appendChild(checkDevTools);\r\n\r\n        modal.appendChild(overlay);\r\n        modal.appendChild(content);\r\n        document.body.appendChild(modal);\r\n    }\r\n\r\n\r\n    createErrorDialog(message) {\r\n        console.log(\"wut\");\r\n        let modal = document.createElement('div');\r\n        modal.className = 'modal';\r\n        let content = document.createElement('div');\r\n        content.className = 'content';\r\n        content.innerHTML = message;\r\n\r\n        modal.appendChild(content);\r\n        document.body.appendChild(modal);\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/GisplayError.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 142,
    "kind": "class",
    "name": "GisplayError",
    "memberof": "src/Gisplay/GisplayError.js",
    "static": true,
    "longname": "src/Gisplay/GisplayError.js~GisplayError",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayError.js",
    "importStyle": "{GisplayError}",
    "description": "Custom Error to create a popup message to inform the user about a particular problem.",
    "see": [
      "https://medium.com/@xjamundx/custom-javascript-errors-in-es6-aa891b173f87"
    ],
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GisplayError"
      }
    ],
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 143,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/GisplayError.js~GisplayError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayError.js~GisplayError#constructor",
    "access": "public",
    "description": "Creates an instance of GisplayError.",
    "see": [
      "https://github.com/codrops/ModalWindowEffects",
      "https://codepen.io/SMLMRKHLMS/pen/rVYRLQ "
    ],
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message to provide to the user."
      }
    ]
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "createErrorDialog",
    "memberof": "src/Gisplay/GisplayError.js~GisplayError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayError.js~GisplayError#createErrorDialog",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true
  },
  {
    "__docId__": 145,
    "kind": "file",
    "name": "src/Gisplay/GisplayErrorChecker.js",
    "content": "import defaultsFile from './defaults.json';\r\n\r\n/**\r\n * NOT YET IMPLEMENTED\r\n * Used to verify all errors that can be checked from the given options and the defaults and shaders files.\r\n * @export\r\n * @class GisplayErrorChecker\r\n */\r\nexport class GisplayErrorChecker {\r\n\r\n    constructor(options) {\r\n\r\n    }\r\n\r\n    /**\r\n     * Verifies if the parsing, mapping and global options exist.\r\n     * @param {Object} parsingOptions \r\n     * @param {Object} mappingOptions \r\n     * @param {Object} globalOptions \r\n     * @memberOf GisplayErrorChecker\r\n     */\r\n    checkMainOptions(parsingOptions, mappingOptions, globalOptions) {\r\n        if (!parsingOptions)\r\n            this.alertAndThrowError('Parsing options not found');\r\n        if (!mappingOptions)\r\n            this.alertAndThrowError('Mapping options not found');\r\n        if (!globalOptions)\r\n            this.alertAndThrowError('Global options not found');\r\n    }\r\n\r\n    // ############################################# OLD METHODS #############################################\r\n    /**\r\n     * Used to check errors on the given userOptions.\r\n     * @memberof GisplayOptions\r\n     */\r\n    checkPreErrors(userOptions) {\r\n        if ((!userOptions.bounds && userOptions.layout)) {\r\n            this.alertError();\r\n            throw new Error(\"Invalid bounds and/or layout options\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is fired after the constructor is done and should check for all types of erros \r\n     * that are possible to catch at this stage (eg. did the user provide an attribute?)\r\n     * @memberof GisplayOptions\r\n     */\r\n    checkPossibleErrors() {\r\n        //Errors:\r\n        //1 sum of layout sizes higher than 100\r\n        // this.checkBounds();\r\n        this.checkExistingGisplayId(this.container.id);\r\n        this.checkValidLayoutRec(this.layout);\r\n    }\r\n\r\n    checkExistingGisplayId(gisplayId) {\r\n        if (document.querySelectorAll('#' + gisplayId).length > 1) {\r\n            this.alertError();\r\n            throw new Error(\"Gisplay identifier given: \" + gisplayId + \" already exists\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the given layout.\r\n     * Now checks: size of each descendant does not exceeds 100 per cent and the id exists on the bounds object. \r\n     * @param {any} obj \r\n     * @memberof GisplayOptions\r\n     */\r\n    checkValidLayoutRec(obj) {\r\n        let orientation = obj.vertical || obj.horizontal;\r\n        this.checkSizes(orientation);\r\n        for (let i = 0; i < orientation.sizes.length; i++)\r\n            if (typeof orientation.descendants[i] === 'string') //Leaf found\t\r\n                this.checkExistingBound(orientation.descendants[i]);\r\n            else\r\n                this.checkValidLayoutRec(orientation.descendants[i]);\r\n    }\r\n\r\n    /**\r\n     * Validates the sum of all sizes for this orientation.\r\n     * @param {Object} orientation - The vertical/horizontal object. \r\n     * @memberof GisplayOptions\r\n     */\r\n    checkSizes(orientation) {\r\n        let sum = 0;\r\n        for (let size of orientation.sizes)\r\n            sum += size;\r\n        if (sum !== 100) {//sum > 100 || sum < 100)\r\n            this.alertError();\r\n            throw new Error(\"Sum of sizes exceeds 100 per cent at: \" + JSON.stringify(orientation));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The id of the bound to check the existence on the bounds object.\r\n     * @param {string} boundId - The bounds id. \r\n     * @memberof GisplayOptions\r\n     */\r\n    checkExistingBound(boundId) {\r\n        // if (!boundId)\r\n        if (!this.bounds[boundId]) {\r\n            this.alertError();\r\n            throw new Error(\"Bound named: \" + boundId + \" does not exist. Available bounds are: [\" + Object.keys(this.bounds) + \"]\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send an alert to the user and throw the error given.\r\n     * @param {string} errorString - The error to throw.\r\n     * @memberOf GisplayErrorChecker\r\n     */\r\n    alertAndThrowError(errorString) {\r\n        this.alertError();\r\n        throw new Error(errorString);\r\n    }\r\n\r\n    //\r\n    /**\r\n     * This method fires an alert because the user provider wrong or conflicting options.\r\n     * @memberof GisplayOptions\r\n     */\r\n    alertError() {\r\n        alert(\"Error on Options object found. Check browser console for more details.\");\r\n    }\r\n\r\n    // ############################################# DEPRECATED\r\n    /**\r\n     * @deprecated It's not used because the visual variables already hold all information of parsing Options.\r\n     * Returns the mapping options.\r\n     * @returns {Object} - the mapping options.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    getMappingOptions() {\r\n        return this.mappingOptions;\r\n    }\r\n\r\n    /**\r\n     * @deprecated \r\n     * Process options for mapping of visual variables.\r\n     * @param {Object} mappingOptions - Mapping options given by the user.\r\n     * @returns {Array<Object>} - The resulting options after processing.\r\n     * @property {string} legendTitle - The title of the legend\r\n     * @property {string} visualVariable - The type of visual variable for each option.\r\n     * @property {Array<Object|string|number>} mapping - The mapping between each class/category of the variable and it's value. \r\n     * @memberof NewGisplayOptions\r\n     */\r\n    processMappingOptions(mappingOptions) {\r\n        let mappingOptionsVariables = [];\r\n        for (let externalName of Object.keys(mappingOptions)) {\r\n            let value = mappingOptions[externalName];\r\n            let mappingInfoVariable = {\r\n                externalName: externalName,\r\n                legendTitle: value.legendTitle || externalName,\r\n                visualVariable: value.visualVariable,\r\n                mapping: value.mapping\r\n            };\r\n            mappingOptionsVariables.push(mappingInfoVariable);\r\n\r\n            this.optionsMap.set(externalName, { parsing: this._findParsingVariable(externalName), mapping: mappingInfoVariable }); //For each visual variable create: externalName -> options\r\n        }\r\n\r\n        // this.optionsMap = map; //For each visual variable create: externalName -> options\r\n        //TODO: verify errors for mapping\r\n        //1. Should have as many keys as the sum of this.parsinOptions.categoricalVars + sequentialVars\r\n        return mappingOptionsVariables;\r\n    }\r\n\r\n    /**\r\n     * @deprecated \r\n     * Finds the variable on the parsing options.\r\n     * @param {string} externalName - External name.\r\n     * @returns {Object} - The parsing options for the variable with the given name.\r\n     * @private \r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _findParsingVariable(externalName) {\r\n        let cat = this.parsingOptions.categoricalVars;\r\n        let seq = this.parsingOptions.sequentialVars;\r\n        for (let i = 0; i < cat.length; i++)\r\n            if (cat[i].externalName === externalName)\r\n                return cat[i];\r\n\r\n        for (let i = 0; i < seq.length; i++)\r\n            if (seq[i].externalName === externalName)\r\n                return seq[i];\r\n        return null; //TODO: throw new Error('Name not found on the parsing options.')\r\n    }\r\n\r\n    /**\r\n     * @deprecated \r\n     * @param {any} externalName \r\n     * @returns \r\n     * @memberof GisplayOptions\r\n     */\r\n    _findMappingVariable(externalName) {\r\n        let mappingOpts = this.mappingOptions;\r\n        for (let i = 0; i < mappingOpts.length; i++)\r\n            if (mappingOpts[i].externalName === externalName)\r\n                return mappingOpts[i];\r\n        return null; //TODO: throw new Error('Name not found on the parsing options.')\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/GisplayErrorChecker.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 146,
    "kind": "class",
    "name": "GisplayErrorChecker",
    "memberof": "src/Gisplay/GisplayErrorChecker.js",
    "static": true,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayErrorChecker.js",
    "importStyle": "{GisplayErrorChecker}",
    "description": "NOT YET IMPLEMENTED\nUsed to verify all errors that can be checked from the given options and the defaults and shaders files.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GisplayErrorChecker"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 147,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "checkMainOptions",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkMainOptions",
    "access": "public",
    "description": "Verifies if the parsing, mapping and global options exist.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayErrorChecker"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "checkPreErrors",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkPreErrors",
    "access": "public",
    "description": "Used to check errors on the given userOptions.",
    "lineNumber": 36
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "checkPossibleErrors",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkPossibleErrors",
    "access": "public",
    "description": "This method is fired after the constructor is done and should check for all types of erros \nthat are possible to catch at this stage (eg. did the user provide an attribute?)",
    "lineNumber": 48
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "checkExistingGisplayId",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkExistingGisplayId",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "checkValidLayoutRec",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkValidLayoutRec",
    "access": "public",
    "description": "Validates the given layout.\nNow checks: size of each descendant does not exceeds 100 per cent and the id exists on the bounds object. ",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "checkSizes",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkSizes",
    "access": "public",
    "description": "Validates the sum of all sizes for this orientation.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "orientation",
        "description": "The vertical/horizontal object."
      }
    ]
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "checkExistingBound",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#checkExistingBound",
    "access": "public",
    "description": "The id of the bound to check the existence on the bounds object.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "boundId",
        "description": "The bounds id."
      }
    ]
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "alertAndThrowError",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#alertAndThrowError",
    "access": "public",
    "description": "Send an alert to the user and throw the error given.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "GisplayErrorChecker"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "errorString",
        "description": "The error to throw."
      }
    ]
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "alertError",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#alertError",
    "access": "public",
    "description": "This method fires an alert because the user provider wrong or conflicting options.",
    "lineNumber": 122
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "getMappingOptions",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#getMappingOptions",
    "access": "public",
    "description": "",
    "lineNumber": 133,
    "deprecated": "It's not used because the visual variables already hold all information of parsing Options.\nReturns the mapping options.",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - the mapping options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the mapping options."
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "processMappingOptions",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#processMappingOptions",
    "access": "public",
    "description": "",
    "lineNumber": 147,
    "deprecated": "Process options for mapping of visual variables.",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Object>} - The resulting options after processing."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "Mapping options given by the user."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "legendTitle",
        "description": "The title of the legend"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVariable",
        "description": "The type of visual variable for each option."
      },
      {
        "nullable": null,
        "types": [
          "Array<Object|string|number>"
        ],
        "spread": false,
        "optional": false,
        "name": "mapping",
        "description": "The mapping between each class/category of the variable and it's value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Object>"
      ],
      "spread": false,
      "description": "The resulting options after processing."
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "_findParsingVariable",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#_findParsingVariable",
    "access": "private",
    "description": "",
    "lineNumber": 176,
    "deprecated": "Finds the variable on the parsing options.",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The parsing options for the variable with the given name."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "External name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The parsing options for the variable with the given name."
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "_findMappingVariable",
    "memberof": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker#_findMappingVariable",
    "access": "private",
    "description": "",
    "lineNumber": 195,
    "deprecated": true,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 161,
    "kind": "file",
    "name": "src/Gisplay/GisplayOptions.js",
    "content": "// import { GisplayMap } from './Maps/GisplayMap';\r\n\r\nimport { URLVariable } from './VVs/URLVariable';\r\nimport { DataVariable } from './VVs/DataVariable';\r\nimport { TimeVariable } from './VVs/TimeVariable';\r\nimport { CategoricalVariable } from './VVs/CategoricalVariable';\r\nimport { ContinuousVariable } from './VVs/ContinuousVariable';\r\n\r\nimport { GisplayError } from './GisplayError';\r\nimport { GisplayDefaults } from './GisplayDefaults';\r\nimport { ColorBrewer } from './Helpers/ColorBrewer';\r\n\r\n/**\r\n * This class will contain all the options available on the Gisplay API.\r\n * @see Diogo's thesis page 50-52\r\n */\r\nexport class GisplayOptions {\r\n    /**\r\n     * Creates an instance of GisplayOptions.\r\n     * @param {Object} parsingOptions - The parsing options object. \r\n     * @param {Object} variableUsage - The variable usage options.\r\n     * @param {Object} globalOptions - The global options object.\r\n     * @param {GisplayMap} gisplayMap - The GisplayMap object.\r\n     * @memberof GisplayOptions\r\n     */\r\n    constructor(parsingOptions, variableUsage, globalOptions, gisplayMap) {\r\n        this.parsingOptions = parsingOptions;\r\n\r\n        /**\r\n         * The time variable.\r\n         * @type {TimeVariable}\r\n         */\r\n        this.timeVariable = this.processTimeVariable(variableUsage, globalOptions, gisplayMap);\r\n        /**\r\n         * The url variable.\r\n         * @type {URLVariable}\r\n         */\r\n        this.urlVariable = this.processURLOptions(parsingOptions.urls);\r\n        /**\r\n         * The CSV parser information.\r\n         * @type {{chunkSize: number, numWorkers: number}}\r\n         */\r\n        this.csv = this.loadCSVParserOptions(parsingOptions.csv);\r\n        /**\r\n         * The global options.\r\n         * @type {Object}\r\n         */\r\n        this.globalOptions = this.processGlobalOptions(globalOptions);\r\n        /**\r\n         * The geometry variables (longitude and latitude).\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.geometryVariables = this.processGeometryVariables(variableUsage);\r\n\r\n        //Opcionais sao as q n estiverem no variableUsage\r\n\r\n        /**\r\n         * The map variables.\r\n         * @type {Array<MapVariable>}\r\n         */\r\n        this.thematicVariables = this.processThematicVariables(variableUsage, gisplayMap);\r\n\r\n        //@TODO OPTIONAL VARIABLES\r\n        /**\r\n         * The optional variables.\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.optionalVariables = this.processOptionalVariables();\r\n\r\n\r\n        console.log(this);\r\n    }\r\n\r\n    /**\r\n     * Process the time variable and return the created time variable. \r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {{temporalInformation: Object}} variableUsage - The information about the variables.\r\n     * @param {Object} globalOptions - The global options. \r\n     * @param {GisplayMap} gisplayMap - The thematic map. \r\n     * @returns {TimeVariable|undefined} - the time variable if given by the programmer, otherwise undefined.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    processTimeVariable(variableUsage, globalOptions, gisplayMap) {\r\n        if (!variableUsage.temporalInformation)\r\n            return undefined;\r\n        let internalName = variableUsage.temporalInformation.internalName;\r\n        let granularity = variableUsage.temporalInformation.granularity;\r\n        if (!granularity) //No granularity given\r\n            throw new GisplayError('No granularity was given');\r\n        else if (GisplayDefaults.getAvailableGranularities().indexOf(granularity) === -1) //The given granularity does not exist\r\n            throw new GisplayError(`The given granularity: ${granularity} doesn't belong to the list of available granularities: ${GisplayDefaults.getAvailableGranularities()}.`);\r\n        else if (!this._findVariableDeclaration(internalName)) //internal name not defined in the \r\n            throw new GisplayError(`The given internalName: ${internalName} doesn't exist in the list of variable declarations.`);\r\n\r\n        let variable = this._findVariableDeclaration(internalName);\r\n        let timeControl = globalOptions.timeControl;\r\n        if (!timeControl)\r\n            timeControl = gisplayMap.getAvailableTemporalControls()[0];\r\n        return new TimeVariable(variable.externalName, internalName, granularity, timeControl);\r\n    }\r\n\r\n    /**\r\n     * Process URL options.\r\n     * @param {{dataURL: string, geospatialURL: string, idOnDataURL: string, idOnGeoSpatialURL: string}} urls - The urls options given by the programmer. \r\n     * @returns {URLVariable} - the URLVariable that holds the reference to the URLs and ids.\r\n     * @see https://stackoverflow.com/a/15979390/\r\n     * https://stackoverflow.com/questions/12460378/how-to-get-json-from-url-in-javascript\r\n     * @memberof GisplayOptions\r\n     */\r\n    processURLOptions(urls) {\r\n        //Needs to see if the url is a local url(file) or not\r\n        let dataURL;\r\n        if (!urls.dataURL)\r\n            throw new GisplayError(`The data URL was not given, and it is mandatory.`);\r\n        else {\r\n            if (urls.dataURL.includes('http') || urls.dataURL.includes('https'))\r\n                dataURL = urls.dataURL;\r\n            else {\r\n                dataURL = document.getElementById(urls.dataURL);\r\n                if (dataURL && dataURL.files[0]) {\r\n                    dataURL = dataURL.files[0];\r\n                    this._validateFileExtension(dataURL.name);\r\n                }\r\n                else\r\n                    throw new GisplayError(`No file was selected.`);\r\n            }\r\n        }\r\n\r\n        let geospatialURL;\r\n        if (urls.geospatialURL !== undefined) {\r\n            if (urls.geospatialURL.includes('http') || urls.geospatialURL.includes('https'))\r\n                geospatialURL = urls.geospatialURL;\r\n            else {\r\n                geospatialURL = document.getElementById(urls.geospatialURL);\r\n                if (geospatialURL && geospatialURL.files[0])\r\n                    geospatialURL = geospatialURL.files[0];\r\n                if (geospatialURL)\r\n                    this._validateFileExtension(geospatialURL.name);\r\n            }\r\n        }\r\n        return new URLVariable(dataURL, geospatialURL, urls.idOnDataURL, urls.idOnGeoSpatialURL);\r\n    }\r\n\r\n    /**\r\n     * Validate the file extension \r\n     * @param {string} fileName - The name of the file to validate.\r\n     * @returns {boolean} - true if the filename is valid, otherwise will throw an Error.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _validateFileExtension(fileName) {\r\n        if (fileName === undefined)\r\n            throw new GisplayError('The given file has a type this is not parseable by the Temporal Gisplay API.');\r\n        fileName = fileName.toLowerCase();\r\n        if (fileName.endsWith('.csv') || fileName.endsWith('.json') || fileName.endsWith('.geojson'))\r\n            return true;\r\n        else\r\n            throw new GisplayError('The given file has a type that isn\\'t parseable by the Temporal Gisplay API.');\r\n    }\r\n\r\n    /**\r\n     * Find the variable declaration in the parsing options.\r\n     * @param {{variableDeclarations: Object, urls:Object}} parsingOptions - The parsing options.\r\n     * @param {string} internalName - The internal name to look for in the variable declarations.\r\n     * @returns {{internalName?:string, externalName: string}|boolean} - the variable declared in the parsing options.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _findVariableDeclaration(internalName) {\r\n        let variables = this.parsingOptions.variableDeclarations;\r\n        if (!variables)\r\n            throw new GisplayError(\"Declaration of variables not found.\");\r\n        for (const variable of variables)\r\n            if (variable.internalName === internalName || variable.externalName === internalName) //If the internal name is found in the declarations then return the variable\r\n                return variable;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Loads parser options.\r\n     * @param {Object} userOptions - User defined options.\r\n     * @returns {{chunkSize: number, numWorkers: number}} - Options for the parser.\r\n     * @memberof GisplayOptions\r\n     */\r\n    loadCSVParserOptions(userOptions) {\r\n        if (!userOptions)\r\n            userOptions = {};\r\n        return {\r\n            /**\r\n             * Size of each chunk that each worker will read at a time.\r\n             * @type {number}\r\n             */\r\n            chunkSize: userOptions.chunkSize, //UserDef or 10MB\r\n            /** \r\n             * Number of workers that will process the data file.\r\n             * @type {number}\r\n             */\r\n            numWorkers: userOptions.numWorkers, //Worker threads \r\n        };\r\n    }\r\n\r\n    /**\r\n     * Process global options for the Gisplay API.\r\n     * @param {{bounds: Object, layout: Object, container: string, provider: string, showLoader: boolean, mapOnClickFunction: Function, timeControl: string}} globalOptions - The global options. \r\n     * @returns {{bounds: Object, layout: Object, container: string, provider: string, showLoader: boolean, mapOnClickFunction: Function, timeControl: string}} - the global options.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    processGlobalOptions(globalOptions) {\r\n        //@TODO: verify errors for global opts\r\n        return {\r\n            bounds: globalOptions.bounds,\r\n            layout: globalOptions.layout || this._completeLayout(globalOptions.bounds),\r\n            container: globalOptions.container,\r\n            provider: globalOptions.provider || 'MB',\r\n            showLoader: globalOptions.showLoader || true,\r\n            mapOnClickFunction: globalOptions.mapOnClickFunction,\r\n            legendOnClickFunction: globalOptions.legendOnClickFunction,\r\n            timeControl: globalOptions.timeControl\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Complete layout when there's one bound given and no layout for the said bound.\r\n     * @returns {Object} - The layout for the bound.\r\n     * @private\r\n     * @memberof GisplayOptions\r\n     */\r\n    _completeLayout(bounds) {\r\n        if (Object.keys(bounds).length === 1) {\r\n            return {\r\n                vertical: {\r\n                    sizes: [100],\r\n                    descendants: [Object.keys(bounds)[0]]\r\n                }\r\n            };\r\n        }\r\n        else\r\n            throw new GisplayError(\"Layout is lacking in the options object.\");\r\n    }\r\n\r\n    /**\r\n     * Creates the geometry variables. These are used in CSV parsing to parse the latitude and longitude.\r\n     * @param {any} variableUsage - The usage of the declared variables.\r\n     * @param {any} parsingOptions - The parsing options. \r\n     * @returns {Array<DataVariable>} - the geometry variables (lng, lat) in an array, where the first element will contiain the longitude DataVariable and the second the latitude.\r\n     * @memberof GisplayOptions\r\n     */\r\n    processGeometryVariables(variableUsage) {\r\n        let geometryVariables = [];\r\n        let geoVars = variableUsage.spatialInformation;\r\n        if (geoVars && Object.keys(geoVars).length === 2) {\r\n            let longitudeInternalName = geoVars.longitude ? geoVars.longitude.internalName : undefined;\r\n            let latitudeInternalName = geoVars.latitude ? geoVars.latitude.internalName : undefined;\r\n            if (longitudeInternalName && latitudeInternalName) {\r\n                let longitudeVariable = this._findVariableDeclaration(longitudeInternalName);\r\n                let latitudeVariable = this._findVariableDeclaration(latitudeInternalName);\r\n                if (!latitudeVariable || !longitudeVariable)\r\n                    throw new GisplayError('Latitude or longitude weren\\'t correctly given.');\r\n                else {\r\n                    geometryVariables.push(new DataVariable(longitudeVariable.externalName, longitudeInternalName));\r\n                    geometryVariables.push(new DataVariable(latitudeVariable.externalName, latitudeInternalName));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (geometryVariables.length < 2 && !this.getURLVariable().dataFileIsGeoJSON() && !this.getURLVariable().hasIds())\r\n            throw new GisplayError('No longitude/latitude given but they are required.');\r\n        return geometryVariables;\r\n    }\r\n\r\n    /**\r\n     * Process the themaic variables and create the respective (categorical or continous) class object.\r\n     * @param {any} variableUsage \r\n     * @param {GisplayMap} gisplayMap - The Gisplay map.\r\n     * @returns {Array<CategoricalVariable|ContinuousVariable>}\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    processThematicVariables(variableUsage, gisplayMap) {\r\n        let shaderVariablesMap = gisplayMap.getShadersInfo().getShaderVariablesMap();\r\n        let categoricalVVs = [];\r\n        let continuousVVs = [];\r\n\r\n        let thematicVariables = variableUsage.thematicInformation;\r\n        let vvs = Object.keys(thematicVariables);\r\n        for (const visualVarName of vvs) {\r\n            console.warn(visualVarName, thematicVariables[visualVarName]); //DELETE\r\n\r\n            let vvOptions = thematicVariables[visualVarName];\r\n            let variable = this._findVariableDeclaration(vvOptions.internalName);\r\n            if (!vvOptions.internalName || !variable)\r\n                throw new GisplayError(`Internal name for visual variable: ${visualVarName}, not given or not declared in variable declarations.`);\r\n\r\n            let vvMapping = vvOptions.mapping;\r\n            if (visualVarName === GisplayDefaults.COLOR()) {\r\n                let mappingMethod = vvOptions.mappingMethod; //e.g. colorbrewer-sequential\r\n                if (!vvMapping && !mappingMethod)\r\n                    throw new GisplayError(`No mapping given nor mapping method. When the visual variable is color then is mandatory to provide a mapping method or the mapping.`);\r\n                if (mappingMethod && ((typeof mappingMethod === 'string' && GisplayDefaults.getAvailableColorBrewerMethods().indexOf(mappingMethod.toLocaleLowerCase()) === -1) || typeof mappingMethod !== 'string'))\r\n                    throw new GisplayError(`The mapping method: ${mappingMethod} is not available`);\r\n\r\n                if (vvMapping) { //has mapping: some value\r\n                    if (Array.isArray(vvMapping)) {\r\n                        if (vvMapping[0].value) // Categorical >>>>>>>>>>>>\r\n                            categoricalVVs.push(this._createCategoricalVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap));\r\n                        else   //                  Continuous >>>>>>>>>>>>\r\n                            continuousVVs.push(this._createContinuousVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap, undefined));\r\n                    } else\r\n                        throw new GisplayError('Given mapping object is not an array of values hence not valid');\r\n                } else {\r\n                    if (mappingMethod) {\r\n                        if (mappingMethod.toLowerCase().includes(GisplayDefaults.QUALITATIVE().toLowerCase())) // Categorical >>>>>>>>>>>>\r\n                            categoricalVVs.push(this._createCategoricalVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap));\r\n                        else  //                                                                                  Continuous >>>>>>>>>>>>\r\n                            continuousVVs.push(this._createContinuousVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap, mappingMethod.split('-')[1]));\r\n                    } else\r\n                        throw new GisplayError(`Wrong options provided for visual variable: ${visualVarName}.`);\r\n                }\r\n            }\r\n            else {\r\n                if (!vvMapping) //No mapping then error\r\n                    throw new GisplayError(`The visual variable: ${visualVarName}, needs to include it's mapping in the given options.`);\r\n                else if (!Array.isArray(vvMapping))\r\n                    throw new GisplayError(`The mapping for the visual variable: ${visualVarName}, isn't provided in array format.`);\r\n                else {\r\n                    if (vvMapping[0].value)   // If mapping[0] has value key then its categorical\r\n                        categoricalVVs.push(this._createCategoricalVariable(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName));\r\n                    else  //                     Otherwise its continuous\r\n                        continuousVVs.push(this._createContinuousVariable(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap));\r\n                }\r\n            }\r\n            console.log(\"----------------------------------\"); //DELETE\r\n        }\r\n        return [categoricalVVs, continuousVVs];\r\n    }\r\n\r\n    /**\r\n     * Returns the continuous variable created using the provided parameters.\r\n     * @param {any} vvOptions - The options for this visual variable inside the thematicInformation object.\r\n     * @param {Array<string>} vvMapping - The mapping between the values and their visual value (e.g. [20,40, 80] or ['#121212', '#000000']).\r\n     * @param {Map<string, {name: string, type: number, qualifier: string}>} shaderVariablesMap - The shaders for the current map.\r\n     * @param {{externalName: string, internalName: string}} variable - The variable in the  variable declarations.\r\n     * @param {string} visualVarName - The name of the visual variable. \r\n     * @param {GisplayMap} gisplayMap - The Gisplay map.\r\n     * @returns {ContinuousVariable} - the continuous variable created using the provided parameters.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _createContinuousVariable(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap) {\r\n        let numberOfClasses = vvOptions.numberOfClasses;\r\n        let classBreaks = vvOptions.classBreaks;\r\n\r\n        if (numberOfClasses !== undefined) {\r\n            if (+numberOfClasses !== +numberOfClasses)\r\n                throw new GisplayError('The numberOfClasses key must be a number');\r\n            else if (numberOfClasses <= 1)\r\n                throw new GisplayError('The number of classes must be a number and higher than 1.');\r\n            else if (numberOfClasses !== vvMapping.length)\r\n                throw new GisplayError('The number of classes is not equal to the number of mappings');\r\n        }\r\n        numberOfClasses = vvMapping.length;\r\n\r\n        if (classBreaks !== undefined) {\r\n            if (!Array.isArray(classBreaks))\r\n                throw new GisplayError('classBreaks key must be an array.');\r\n            else if (!classBreaks.every((e) => +e === +e))\r\n                throw new GisplayError('classBreaks must be an array of numbers.');\r\n            else if (classBreaks.length !== numberOfClasses - 1)\r\n                throw new GisplayError('The classBreaks don\\'t match the number of classes.');\r\n        }\r\n\r\n        let classBreaksMethod = vvOptions.classBreaksMethod;\r\n        let params = vvOptions.params;\r\n        if (classBreaksMethod && typeof classBreaksMethod === 'string' && GisplayDefaults.getAvailableClassBreaksMethods().indexOf(classBreaksMethod.toLowerCase()) === -1)\r\n            throw new GisplayError(`The class break method: ${classBreaksMethod} is not available.`);\r\n\r\n        console.error(classBreaks, classBreaksMethod);\r\n        if (!classBreaks && !classBreaksMethod)\r\n            throw new GisplayError(`Neither class breaks nor class breaks method were given for the variable with internal name: ${vvOptions.internalName} and visual variable: ${visualVarName}.`);\r\n\r\n        return new ContinuousVariable(\r\n            variable.externalName,\r\n            vvOptions.internalName,\r\n            visualVarName,\r\n            shaderVariablesMap.get(visualVarName).qualifier,\r\n            vvMapping,\r\n            classBreaks,\r\n            numberOfClasses,\r\n            classBreaksMethod,\r\n            params\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the continuous variable when the visual variable is color.\r\n     * @param {any} vvOptions - The options for this visual variable inside the thematicInformation object.\r\n     * @param {Array<string>} vvMapping - The mapping between the values and their visual value (e.g. [20,40, 80] or ['#121212', '#000000']).\r\n     * @param {Map<string, {name: string, type: number, qualifier: string}>} shaderVariablesMap - The shaders for the current map.\r\n     * @param {{externalName: string, internalName: string}} variable - The variable in the  variable declarations.\r\n     * @param {string} visualVarName - The name of the visual variable. \r\n     * @param {GisplayMap} gisplayMap - The Gisplay map.\r\n     * @param {string} mappingMethod - The color brewer mapping method.\r\n     * @returns {ContinuousVariable} - the continuous variable when the visual variable is color.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _createContinuousVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap, dataNature) {\r\n        let numberOfClasses = vvOptions.numberOfClasses;\r\n        let numClassesIsNumber = +numberOfClasses === +numberOfClasses;\r\n        let classBreaks = vvOptions.classBreaks;\r\n\r\n        if (vvMapping !== undefined) {\r\n            if (numberOfClasses !== undefined) {\r\n                if (!numClassesIsNumber)\r\n                    throw new GisplayError('The number of classes must be a number');\r\n                else if (numberOfClasses <= 1)\r\n                    throw new GisplayError('The number of classes must be a number and higher than 1.');\r\n                else if (numberOfClasses !== vvMapping.length)\r\n                    throw new GisplayError('The number of classes is not equal to the number of mappings');\r\n            }\r\n\r\n            if (vvMapping.every((color) => color.split('#').length !== 2)) //'#a'.split('#').length = 2\r\n                throw new GisplayError(`The mapping color given aren't in the hexadecimal format but it's mandatory to do so for continuous variables.`);\r\n            else { //Get the colors from GisplayMap\r\n                let rgbColors = [];\r\n                for (let hexColor of vvMapping)\r\n                    rgbColors.push(ColorBrewer.convertHexColorToRGB(hexColor));\r\n                vvMapping = rgbColors;\r\n            }\r\n            numberOfClasses = vvMapping.length;\r\n        } else {\r\n            if (classBreaks) {\r\n                numberOfClasses = classBreaks.length - 1; //@TODO Change HERE for new class breaks calculation\r\n                numClassesIsNumber = true;\r\n            }\r\n            vvMapping = gisplayMap.getDefaultColors(numClassesIsNumber ? numberOfClasses : gisplayMap.defaults().color.numberOfClasses, dataNature);\r\n            // numberOfClasses = vvMapping.length;\r\n        }\r\n\r\n        if (classBreaks !== undefined) {\r\n            if (!Array.isArray(classBreaks))\r\n                throw new GisplayError('classBreaks key must be an array.');\r\n            else if (!classBreaks.every((e) => +e === +e))\r\n                throw new GisplayError('classBreaks must be an array of numbers.');\r\n            else if (classBreaks.length !== numberOfClasses + 1) //Possible problem here when is color\r\n                throw new GisplayError('The classBreaks don\\'t match the number of classes.');\r\n        }\r\n\r\n        let classBreaksMethod = vvOptions.classBreaksMethod;\r\n        let params = vvOptions.params;\r\n        if (classBreaksMethod && typeof classBreaksMethod === 'string' && GisplayDefaults.getAvailableClassBreaksMethods().indexOf(classBreaksMethod.toLowerCase()) === -1)\r\n            throw new GisplayError(`The class break method: ${classBreaksMethod} is not available.`);\r\n\r\n        return new ContinuousVariable(\r\n            variable.externalName,\r\n            vvOptions.internalName,\r\n            visualVarName,\r\n            shaderVariablesMap.get(visualVarName).qualifier,\r\n            vvMapping,\r\n            classBreaks,\r\n            numberOfClasses,\r\n            classBreaksMethod,\r\n            params\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the categorical variable created using the provided parameters.\r\n     * @param {any} vvOptions - The options for this visual variable inside the thematicInformation object.\r\n     * @param {Array<{value: string, visual:string}>} vvMapping - The mapping between the values and their visual value (e.g. \"Y\"-> \"red\").\r\n     * @param {Map<string, {name: string, type: number, qualifier: string}>} shaderVariablesMap - The shaders for the current map.\r\n     * @param {{externalName: string, internalName: string}} variable - The variable in the  variable declarations.\r\n     * @param {string} visualVarName - The name of the visual variable. \r\n     * @returns {CategoricalVariable} - the categorical variable created using the provided parameters.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _createCategoricalVariable(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName) {\r\n        let vvMappingMap = new Map();\r\n        for (let mappingValue of vvMapping) {\r\n            if (visualVarName === GisplayDefaults.ORIENTATION())\r\n                vvMappingMap.set(mappingValue.value, +mappingValue.visual); //+mappingValue.visual is to MAKE sure it's a number\r\n            else\r\n                vvMappingMap.set(mappingValue.value, mappingValue.visual);\r\n        }\r\n        return new CategoricalVariable(variable.externalName, vvOptions.internalName, visualVarName, shaderVariablesMap.get(visualVarName).qualifier, vvMappingMap);\r\n    }\r\n\r\n    /**\r\n     * Returns the categorical variable when the visual variable is color.\r\n     * @param {any} vvOptions - The options for this visual variable inside the thematicInformation object.\r\n     * @param {Array<{value: string, visual:string}>} vvMapping - The mapping between the values and their visual value (e.g. \"Y\"-> \"red\").\r\n     * @param {Map<string, {name: string, type: number, qualifier: string}>} shaderVariablesMap - The shaders for the current map.\r\n     * @param {{externalName: string, internalName: string}} variable - The variable in the  variable declarations.\r\n     * @param {string} visualVarName - The name of the visual variable. \r\n     * @param {GisplayMap} gisplayMap - The name of the visual variable. \r\n     * @returns {CategoricalVariable} - the categorical variable created using the provided parameters.\r\n     * @memberof NewGisplayOptions\r\n     */\r\n    _createCategoricalVariableColor(vvOptions, vvMapping, shaderVariablesMap, variable, visualVarName, gisplayMap) {\r\n        console.log(\"CATEGORICAL\", gisplayMap);\r\n        let vvMappingMap = new Map();\r\n        if (vvMapping) {\r\n            for (let mappingValue of vvMapping) {\r\n                let rgbColor;\r\n                let givenColor = mappingValue.visual;\r\n                if (givenColor.split('#').length === 2) // Hexadecimal color\r\n                    rgbColor = ColorBrewer.convertHexColorToRGB(givenColor);\r\n                else //                               Named color\r\n                    rgbColor = ColorBrewer.convertNameToRGB(givenColor);\r\n                vvMappingMap.set(mappingValue.value, rgbColor);\r\n            }\r\n        }\r\n        console.log(vvMappingMap);\r\n        return new CategoricalVariable(variable.externalName, vvOptions.internalName, visualVarName, shaderVariablesMap.get(visualVarName).qualifier, vvMappingMap, gisplayMap);\r\n    }\r\n\r\n    /**\r\n     * Return the array of optional variables.  \r\n     * @param {Array<Object>} optionalVariables - The optional variables array given by the programmer. \r\n     * @returns {Array<DataVariable>} - the array of optional variables.\r\n     * @memberof GisplayOptions\r\n     */\r\n    processOptionalVariables() {\r\n        let optionalVariables = [];\r\n\r\n        let allVariables = this.parsingOptions.variableDeclarations;\r\n        for (let variable of allVariables) {\r\n            let externalName = variable.externalName;\r\n            let internalName = variable.internalName || externalName;\r\n\r\n            //Look into spatial + thematic + temporal to see if the variable is one of them\r\n            let foundVariable = false;\r\n            for (let geoVar of this.geometryVariables)\r\n                if (geoVar.getExternalName() === externalName)\r\n                    foundVariable = true;\r\n\r\n            let catVars = this.getCategoricalVariables();\r\n            for (let catVar of catVars)\r\n                if (catVar.getExternalName() === externalName)\r\n                    foundVariable = true;\r\n\r\n            let contVars = this.getContinousVariables();\r\n            for (let contVar of contVars)\r\n                if (contVar.getExternalName() === externalName)\r\n                    foundVariable = true;\r\n\r\n            let timeVar = this.getTimeVariable();\r\n            if (timeVar && timeVar.getExternalName() === externalName)\r\n                foundVariable = true;\r\n\r\n            if (!foundVariable)\r\n                optionalVariables.push(new DataVariable(externalName, internalName));\r\n        }\r\n        // for (let optionalVar of optionalVariables)\r\n        // resOptsVariables.push(new DataVariable(optionalVar.externalName, optionalVar.internalName || optionalVar.externalName));\r\n        return optionalVariables;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    ######################     UTILITY METHODS      #####################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the URLVariable instance. \r\n     * @returns {URLVariable} - the URLVariable instance. \r\n     * @memberof GisplayOptions\r\n     */\r\n    getURLVariable() {\r\n        return this.urlVariable;\r\n    }\r\n\r\n    /**\r\n     * Returns an array with all the categorical variables that were created with the given options.\r\n     * @returns {Array<CategoricalVariable>} - all the categorical variables that were created with the given options.\r\n     * @memberof GisplayOptions\r\n     */\r\n    getCategoricalVariables() {\r\n        return this.thematicVariables[0];\r\n    }\r\n\r\n    /**\r\n     * Returns an array with all the continuous variables that were created with the given options.\r\n     * @returns {Array<CategoricalVariable>} - all the continuous variables that were created with the given options.\r\n     * @memberof GisplayOptions\r\n     */\r\n    getContinousVariables() {\r\n        return this.thematicVariables[1];\r\n    }\r\n\r\n    /**\r\n     * Returns the TimeVariable instance. \r\n     * @returns {TimeVariable} - the time variable, or null if time wasn't given. \r\n     * @memberof GisplayOptions\r\n     */\r\n    getTimeVariable() {\r\n        return this.timeVariable;\r\n    }\r\n\r\n    /**\r\n     * Returns an array with extra variables used mainly for picking information (click on map).\r\n     * @returns {Array<DataVariable>} - an array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable.\r\n     * @memberof GisplayOptions\r\n     */\r\n    getOptionalVariables() {\r\n        return this.optionalVariables;\r\n    }\r\n\r\n    /**\r\n     * Returns the global options.\r\n     * @returns {Object} - the global options. \r\n     * @memberof NewGisplayOptions\r\n     */\r\n    getGlobalOptions() {\r\n        return this.globalOptions;\r\n    }\r\n\r\n    /**\r\n     * Returns the CSV options object.\r\n     * @returns {Object} - the CSV options object.\r\n     * @memberof GisplayOptions\r\n     */\r\n    getCSV() {\r\n        return this.csv;\r\n    }\r\n\r\n    /**\r\n     * Returns the geometry variables.\r\n     * @returns {Array<DataVariable>} - the geometry variables.\r\n     * @memberof GisplayOptions\r\n     */\r\n    getGeometryVariables() {\r\n        return this.geometryVariables;\r\n    }\r\n}   \r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/GisplayOptions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 162,
    "kind": "class",
    "name": "GisplayOptions",
    "memberof": "src/Gisplay/GisplayOptions.js",
    "static": true,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/GisplayOptions.js",
    "importStyle": "{GisplayOptions}",
    "description": "This class will contain all the options available on the Gisplay API.",
    "see": [
      "Diogo's thesis page 50-52"
    ],
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 163,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#constructor",
    "access": "public",
    "description": "Creates an instance of GisplayOptions.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options object."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "variableUsage",
        "description": "The variable usage options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The global options object."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The GisplayMap object."
      }
    ]
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "parsingOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#parsingOptions",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "timeVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#timeVariable",
    "access": "public",
    "description": "The time variable.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "TimeVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "urlVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#urlVariable",
    "access": "public",
    "description": "The url variable.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "URLVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 167,
    "kind": "member",
    "name": "csv",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#csv",
    "access": "public",
    "description": "The CSV parser information.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "{chunkSize: number, numWorkers: number}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "globalOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#globalOptions",
    "access": "public",
    "description": "The global options.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "geometryVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#geometryVariables",
    "access": "public",
    "description": "The geometry variables (longitude and latitude).",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "thematicVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#thematicVariables",
    "access": "public",
    "description": "The map variables.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "Array<MapVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "optionalVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#optionalVariables",
    "access": "public",
    "description": "The optional variables.",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "processTimeVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processTimeVariable",
    "access": "public",
    "description": "Process the time variable and return the created time variable. ",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TimeVariable|undefined} - the time variable if given by the programmer, otherwise undefined."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "{temporalInformation: Object}"
        ],
        "spread": false,
        "optional": false,
        "name": "variableUsage",
        "description": "The information about the variables."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The global options."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The thematic map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TimeVariable",
        "undefined"
      ],
      "spread": false,
      "description": "the time variable if given by the programmer, otherwise undefined."
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "processURLOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processURLOptions",
    "access": "public",
    "description": "Process URL options.",
    "see": [
      "https://stackoverflow.com/a/15979390/\nhttps://stackoverflow.com/questions/12460378/how-to-get-json-from-url-in-javascript"
    ],
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{URLVariable} - the URLVariable that holds the reference to the URLs and ids."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{dataURL: string, geospatialURL: string, idOnDataURL: string, idOnGeoSpatialURL: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "urls",
        "description": "The urls options given by the programmer."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "URLVariable"
      ],
      "spread": false,
      "description": "the URLVariable that holds the reference to the URLs and ids."
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "_validateFileExtension",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_validateFileExtension",
    "access": "private",
    "description": "Validate the file extension ",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the filename is valid, otherwise will throw an Error."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fileName",
        "description": "The name of the file to validate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the filename is valid, otherwise will throw an Error."
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "_findVariableDeclaration",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_findVariableDeclaration",
    "access": "private",
    "description": "Find the variable declaration in the parsing options.",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{internalName?:string, externalName: string}|boolean} - the variable declared in the parsing options."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{variableDeclarations: Object, urls:Object}"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name to look for in the variable declarations."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{internalName?:string, externalName: string}|boolean"
      ],
      "spread": false,
      "description": "the variable declared in the parsing options."
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "loadCSVParserOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#loadCSVParserOptions",
    "access": "public",
    "description": "Loads parser options.",
    "lineNumber": 183,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{chunkSize: number, numWorkers: number}} - Options for the parser."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "userOptions",
        "description": "User defined options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{chunkSize: number, numWorkers: number}"
      ],
      "spread": false,
      "description": "Options for the parser."
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "processGlobalOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processGlobalOptions",
    "access": "public",
    "description": "Process global options for the Gisplay API.",
    "lineNumber": 206,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{bounds: Object, layout: Object, container: string, provider: string, showLoader: boolean, mapOnClickFunction: Function, timeControl: string}} - the global options."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{bounds: Object, layout: Object, container: string, provider: string, showLoader: boolean, mapOnClickFunction: Function, timeControl: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The global options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{bounds: Object, layout: Object, container: string, provider: string, showLoader: boolean, mapOnClickFunction: Function, timeControl: string}"
      ],
      "spread": false,
      "description": "the global options."
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "_completeLayout",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_completeLayout",
    "access": "private",
    "description": "Complete layout when there's one bound given and no layout for the said bound.",
    "lineNumber": 226,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The layout for the bound."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The layout for the bound."
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "processGeometryVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processGeometryVariables",
    "access": "public",
    "description": "Creates the geometry variables. These are used in CSV parsing to parse the latitude and longitude.",
    "lineNumber": 246,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<DataVariable>} - the geometry variables (lng, lat) in an array, where the first element will contiain the longitude DataVariable and the second the latitude."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "variableUsage",
        "description": "The usage of the declared variables."
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": "the geometry variables (lng, lat) in an array, where the first element will contiain the longitude DataVariable and the second the latitude."
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "processThematicVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processThematicVariables",
    "access": "public",
    "description": "Process the themaic variables and create the respective (categorical or continous) class object.",
    "lineNumber": 276,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<CategoricalVariable|ContinuousVariable>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "variableUsage",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The Gisplay map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable|ContinuousVariable>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_createContinuousVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_createContinuousVariable",
    "access": "private",
    "description": "Returns the continuous variable created using the provided parameters.",
    "lineNumber": 345,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ContinuousVariable} - the continuous variable created using the provided parameters."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "vvOptions",
        "description": "The options for this visual variable inside the thematicInformation object."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "vvMapping",
        "description": "The mapping between the values and their visual value (e.g. [20,40, 80] or ['#121212', '#000000'])."
      },
      {
        "nullable": null,
        "types": [
          "Map<string, {name: string, type: number, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariablesMap",
        "description": "The shaders for the current map."
      },
      {
        "nullable": null,
        "types": [
          "{externalName: string, internalName: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "variable",
        "description": "The variable in the  variable declarations."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVarName",
        "description": "The name of the visual variable."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The Gisplay map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ContinuousVariable"
      ],
      "spread": false,
      "description": "the continuous variable created using the provided parameters."
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "_createContinuousVariableColor",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_createContinuousVariableColor",
    "access": "private",
    "description": "Returns the continuous variable when the visual variable is color.",
    "lineNumber": 402,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ContinuousVariable} - the continuous variable when the visual variable is color."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "vvOptions",
        "description": "The options for this visual variable inside the thematicInformation object."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "vvMapping",
        "description": "The mapping between the values and their visual value (e.g. [20,40, 80] or ['#121212', '#000000'])."
      },
      {
        "nullable": null,
        "types": [
          "Map<string, {name: string, type: number, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariablesMap",
        "description": "The shaders for the current map."
      },
      {
        "nullable": null,
        "types": [
          "{externalName: string, internalName: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "variable",
        "description": "The variable in the  variable declarations."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVarName",
        "description": "The name of the visual variable."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The Gisplay map."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingMethod",
        "description": "The color brewer mapping method."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ContinuousVariable"
      ],
      "spread": false,
      "description": "the continuous variable when the visual variable is color."
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "_createCategoricalVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_createCategoricalVariable",
    "access": "private",
    "description": "Returns the categorical variable created using the provided parameters.",
    "lineNumber": 472,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CategoricalVariable} - the categorical variable created using the provided parameters."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "vvOptions",
        "description": "The options for this visual variable inside the thematicInformation object."
      },
      {
        "nullable": null,
        "types": [
          "Array<{value: string, visual:string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "vvMapping",
        "description": "The mapping between the values and their visual value (e.g. \"Y\"-> \"red\")."
      },
      {
        "nullable": null,
        "types": [
          "Map<string, {name: string, type: number, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariablesMap",
        "description": "The shaders for the current map."
      },
      {
        "nullable": null,
        "types": [
          "{externalName: string, internalName: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "variable",
        "description": "The variable in the  variable declarations."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVarName",
        "description": "The name of the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CategoricalVariable"
      ],
      "spread": false,
      "description": "the categorical variable created using the provided parameters."
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "_createCategoricalVariableColor",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#_createCategoricalVariableColor",
    "access": "private",
    "description": "Returns the categorical variable when the visual variable is color.",
    "lineNumber": 494,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CategoricalVariable} - the categorical variable created using the provided parameters."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "vvOptions",
        "description": "The options for this visual variable inside the thematicInformation object."
      },
      {
        "nullable": null,
        "types": [
          "Array<{value: string, visual:string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "vvMapping",
        "description": "The mapping between the values and their visual value (e.g. \"Y\"-> \"red\")."
      },
      {
        "nullable": null,
        "types": [
          "Map<string, {name: string, type: number, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariablesMap",
        "description": "The shaders for the current map."
      },
      {
        "nullable": null,
        "types": [
          "{externalName: string, internalName: string}"
        ],
        "spread": false,
        "optional": false,
        "name": "variable",
        "description": "The variable in the  variable declarations."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVarName",
        "description": "The name of the visual variable."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The name of the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CategoricalVariable"
      ],
      "spread": false,
      "description": "the categorical variable created using the provided parameters."
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "processOptionalVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#processOptionalVariables",
    "access": "public",
    "description": "Return the array of optional variables.  ",
    "lineNumber": 518,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<DataVariable>} - the array of optional variables."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "optionalVariables",
        "description": "The optional variables array given by the programmer."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": "the array of optional variables."
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "getURLVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getURLVariable",
    "access": "public",
    "description": "Returns the URLVariable instance. ",
    "lineNumber": 564,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{URLVariable} - the URLVariable instance. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "URLVariable"
      ],
      "spread": false,
      "description": "the URLVariable instance."
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "getCategoricalVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getCategoricalVariables",
    "access": "public",
    "description": "Returns an array with all the categorical variables that were created with the given options.",
    "lineNumber": 573,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<CategoricalVariable>} - all the categorical variables that were created with the given options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable>"
      ],
      "spread": false,
      "description": "all the categorical variables that were created with the given options."
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "getContinousVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getContinousVariables",
    "access": "public",
    "description": "Returns an array with all the continuous variables that were created with the given options.",
    "lineNumber": 582,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<CategoricalVariable>} - all the continuous variables that were created with the given options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable>"
      ],
      "spread": false,
      "description": "all the continuous variables that were created with the given options."
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "getTimeVariable",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getTimeVariable",
    "access": "public",
    "description": "Returns the TimeVariable instance. ",
    "lineNumber": 591,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TimeVariable} - the time variable, or null if time wasn't given. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TimeVariable"
      ],
      "spread": false,
      "description": "the time variable, or null if time wasn't given."
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "getOptionalVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getOptionalVariables",
    "access": "public",
    "description": "Returns an array with extra variables used mainly for picking information (click on map).",
    "lineNumber": 600,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<DataVariable>} - an array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": "an array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable."
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "getGlobalOptions",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getGlobalOptions",
    "access": "public",
    "description": "Returns the global options.",
    "lineNumber": 609,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - the global options. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the global options."
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "getCSV",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getCSV",
    "access": "public",
    "description": "Returns the CSV options object.",
    "lineNumber": 618,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - the CSV options object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the CSV options object."
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "getGeometryVariables",
    "memberof": "src/Gisplay/GisplayOptions.js~GisplayOptions",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/GisplayOptions.js~GisplayOptions#getGeometryVariables",
    "access": "public",
    "description": "Returns the geometry variables.",
    "lineNumber": 627,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<DataVariable>} - the geometry variables."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": "the geometry variables."
    }
  },
  {
    "__docId__": 194,
    "kind": "file",
    "name": "src/Gisplay/Helpers/ColorBrewer.js",
    "content": "import { GisplayDefaults } from \"../GisplayDefaults\";\r\nimport { GisplayError } from \"../GisplayError\";\r\n\r\n/**\r\n * This class will contain all ColorBrewer color schemes and methods to query said color schemes.\r\n * These queries can be: by their type(Diverging, Qualitative and Sequential), name(Spectral, RdYlGn, etc etc) and number of classes(3,4...). \r\n * @class ColorBrewerHelper\r\n * @see https://github.com/axismaps/colorbrewer/blob/master/colorbrewer_schemes.js\r\n * @see  https://colorbrewer2.org/\r\n */\r\nexport class ColorBrewer {\r\n\r\n    /**\r\n     * Returns an array with numOfClasses elements that are the colors for the given type of color scheme and it's name.\r\n     * @static\r\n     * @param {string} type - The type of color scheme (Options are: Sequential, Diverging and Qualitative).\r\n     * @param {string} name - Name of the color scheme to search.\r\n     * @param {number} numOfClasses - Number of classes to search.\r\n     * @returns {Array<RGB>} - Array with the colors given by Color Brewer.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getColorScheme(type, name, numOfClasses) {\r\n        let colorBrewer = this.getColorBrewerVariable();\r\n        return colorBrewer[type][name][numOfClasses];\r\n    }\r\n\r\n    /**\r\n     * Returns all the ColorBrewer diverging color schemes. \r\n     * @static\r\n     * @returns {Object} - all the ColorBrewer diverging color schemes. \r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getDivergingColorSchemes() {\r\n        return this.getColorBrewerVariable().Diverging;\r\n    }\r\n\r\n    /**\r\n     * Returns all the ColorBrewer qualitative color schemes.\r\n     * @static\r\n     * @returns {Object} - all the ColorBrewer qualitative color schemes.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getQualitativeColorSchemes() {\r\n        return this.getColorBrewerVariable().Qualitative;\r\n    }\r\n\r\n    /**\r\n     * Returns all the ColorBrewer the sequential color schemes.\r\n     * @static\r\n     * @returns {Object} - all the ColorBrewer sequential color schemes.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getSequentialColorSchemes() {\r\n        return this.getColorBrewerVariable().Sequential;\r\n    }\r\n\r\n    /**\r\n     * This is just an alias for the method getColorSchemesByName(name).\r\n     * @static\r\n     * @param {string} name \r\n     * @returns {Object} an object with multiple color schemes for each number of classes associated with the color scheme given as input.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static byName(name) {\r\n        return this.getColorSchemesByName(name);\r\n    }\r\n\r\n    /**\r\n     * Return an object with multiple color schemes for each number of classes associated with the color scheme given as input.\r\n     * @static\r\n     * @param {string} name \r\n     * @returns {Object} an object with multiple color schemes for each number of classes associated with the color scheme given as input.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getColorSchemesByName(name) {\r\n        let colorSchemes = this.getColorBrewerVariable();\r\n        for (const key of Object.keys(colorSchemes))\r\n            if (colorSchemes[key][name])\r\n                return colorSchemes[key][name];\r\n        throw new GisplayError(\"Name of Color Scheme not found on ColorBrewer list of available colors schemes.\");\r\n    }\r\n\r\n    /**\r\n     * Returns all ColorSchemes that contain the number of class given as input.\r\n     * @static\r\n     * @param {number} numberOfClasses - number of classes to search for.\r\n     * @returns {Object} - Object with \r\n     * @memberOf ColorBrewer\r\n     */\r\n    static byNumber(numberOfClasses) {\r\n        return this.getAllColorSchemesByNumberOfClasses(numberOfClasses);\r\n    }\r\n\r\n    /**\r\n     * Returns an object of color schemes with only those the objects for the specified number of classes.\r\n     * @static\r\n     * @param {number} numberOfClasses \r\n     * @returns {Object} - an object of color schemes with only those the objects for the specified number of classes.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getAllColorSchemesByNumberOfClasses(numberOfClasses) {\r\n        let colorSchemes = this.getColorBrewerVariable();\r\n        let res = {};\r\n        for (const cs of Object.keys(colorSchemes)) //Create {Diverging: {}, Qualitative: ...}\r\n            res[cs] = {};\r\n        for (const cs of Object.keys(colorSchemes))\r\n            for (const name of Object.keys(colorSchemes[cs]))\r\n                if (colorSchemes[cs][name][numberOfClasses] !== undefined)\r\n                    res[cs][name] = colorSchemes[cs][name][numberOfClasses];//(colorSchemes[cs][name][numberOfClasses]);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * For the given color scheme name and number of classes returns the RGB colors associated with them.\r\n     * @static \r\n     * @param {string} name \r\n     * @param {number} numberOfClasses \r\n     * @returns {Array<RGB>} Array of colors associated with color scheme name and number of classes.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static byNameAndNumber(name, numberOfClasses) {\r\n        let res = this.byName(name)[numberOfClasses];\r\n        if (res === undefined)\r\n            throw new GisplayError(\"Illegal number of classes provided.\");\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @static\r\n     * @param {number} numberOfClasses \r\n     * @returns {Array<Object>}\r\n     * @deprecated Use byNumber(n) or getAllColorSchemesByNumberOfClasses(n) instead.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getAllColorSchemesByNumberOfClassesAsArray(numberOfClasses) {\r\n        let colorSchemes = this.getColorBrewerVariable();\r\n        let res = [];\r\n        for (const cs of Object.keys(colorSchemes))\r\n            for (const name of Object.keys(colorSchemes[cs]))\r\n                if (colorSchemes[cs][name][numberOfClasses] !== undefined)\r\n                    res.push(colorSchemes[cs][name][numberOfClasses]);\r\n        if (res.length === 0)\r\n            throw new GisplayError(\"Number of classes provided:\", numberOfClasses, \"does not exist in ColorBrewer.\");\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Given the color scheme name and the number of classes returns an Array of colors associated with the given name and number of classes. \r\n     * @static\r\n     * @param {string} name - color name\r\n     * @param {number} numberOfClasses - number of classes\r\n     * @returns {Array<Array<number>>} Colors of the color scheme. As many as number of classes given.  \r\n     * @see http://stackoverflow.com/a/10971090/\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getColors(name, numberOfClasses) {\r\n        let res = new Array();\r\n        let allColors = ColorBrewer.byNameAndNumber(name, numberOfClasses);\r\n        for (const color of allColors)\r\n            res.push(color.replace(/[^\\d,]/g, '').split(','));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Given the color scheme name and the number of classes returns an Array of colors associated with the given name and number of classes. \r\n     * @static\r\n     * @param {string} name - color name\r\n     * @param {number} numberOfClasses - number of classes\r\n     * @returns {Array<Array<string>>} Colors of the color scheme in hexacedimal format.  \r\n     * @see http://stackoverflow.com/a/57805/5869289\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getColorsHex(name, numberOfClasses) {\r\n        let res = new Array();\r\n        let allColors = ColorBrewer.byNameAndNumber(name, numberOfClasses);\r\n        for (const color of allColors)\r\n            res.push(color.replace(/[^\\d,]/g, '').split(','));\r\n\r\n        let hexColors = new Array();\r\n        for (let color of res) {\r\n            let [r, g, b] = color;\r\n            let hexColor = '#' + (r << 16 | g << 8 | b).toString(16);\r\n            hexColors.push(hexColor);\r\n        }\r\n        return hexColors;\r\n    }\r\n\r\n    /** ########################     DEFAULTS       ####################################### */\r\n    /**\r\n     * Returns the defaults for each map, given it's name, number of classes and nature of the data.\r\n     * @static\r\n     * @param {string} mapName - The name of the map. \r\n     * @param {number} numClasses - The number of classes to build.\r\n     * @param {string} dataNature - The nature of the data.\r\n     * @returns {Array<number>} - the defaults for each map, given it's name, number of classes and nature of the data.\r\n     * \r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getDefautls(mapName, numClasses, dataNature) {\r\n        // dataNature = dataNature.toLowerCase();\r\n        let seq = [GisplayDefaults.SEQUENTIAL(), 'Seq', 'S'];\r\n        // seq = seq.map((s) => s.toLowerCase());\r\n        let div = [GisplayDefaults.DIVERGENT(), 'Div', 'D'];\r\n        // div = div.map((d) => d.toLowerCase());\r\n        let qua = [GisplayDefaults.QUALITATIVE(), 'Qua', 'Q'];\r\n        // qua = qua.map((q) => q.toLowerCase());\r\n        if (numClasses > 12)\r\n            throw new GisplayError(\"Number of classes is higher than 12. It is not recommended to use more than 12 classes in any map visualization.\");\r\n        else if (numClasses >= 10 && seq.indexOf(dataNature) > -1)\r\n            throw new GisplayError(`Number of classes is ${numClasses}. Sequential data types only allow a maximum of 9 data classes.`);\r\n        else if (numClasses === 12 && div.indexOf(dataNature) > -1)\r\n            throw new GisplayError(\"Number of classes is 12. Divergent data types only allow a maximum of 11 data classes.\");\r\n\r\n        switch (mapName) {\r\n            case 'Choropleth':\r\n                if (seq.indexOf(dataNature) > -1)\r\n                    return this.convertRGBStrToNum(this.getChoroplethDefaults(dataNature, numClasses));\r\n                else //if (div.indexOf(dataNature) > -1 || qua.indexOf(dataNature) > -1)\r\n                    throw new GisplayError(\"Choropleth Map defaults for Divergent or Qualitative data are currently not set.\");\r\n            case 'ChangeMap':\r\n                if (div.indexOf(dataNature) > -1)\r\n                    return this.convertRGBStrToNum(this.getChangeMapDefaults(dataNature, numClasses));\r\n                else //if (seq.indexOf(dataNature) > -1 || qua.indexOf(dataNature) > -1)\r\n                    throw new GisplayError(\"Change Map defaults for Sequential or Qualitative data are currently not set.\");\r\n            case 'DotMap':\r\n                if (seq.indexOf(dataNature) > -1 || qua.indexOf(dataNature) > -1)\r\n                    return this.convertRGBStrToNum(this.getDotMapDefaults(dataNature, numClasses));\r\n                else //if (div.indexOf(dataNature) > -1)\r\n                    throw new GisplayError(\"Dot Map defaults for Divergent data are currently not set.\");\r\n            case 'ProportionalSymbols':\r\n                if (seq.indexOf(dataNature) > -1)\r\n                    return this.convertRGBStrToNum(this.getProportionalSymbolsDefaults(dataNature, numClasses));\r\n                else //if (div.indexOf(dataNature) > -1 || qua.indexOf(dataNature) > -1)\r\n                    throw new GisplayError(\"ProportionalSymbols defaults for Divergent or Qualitative data are currently not set.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the default color for Choropleth Maps taking in consideration the given number of classes and nature of data currently being used.\r\n     * @static\r\n     * @param { string } dataNature - The type of data.\r\n     * @param { number } numClasses - The number of classes.\r\n     * @returns { Array<number>} the default color for the given number of classes and nature of data currently being used.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getChoroplethDefaults(dataNature, numClasses) {\r\n        let res = [];\r\n        switch (dataNature) {\r\n            case GisplayDefaults.SEQUENTIAL():\r\n                switch (numClasses) {\r\n                    case 2: {\r\n                        let colors = ColorBrewer.getColors('YlOrRd', 3);\r\n                        res[0] = colors[0];\r\n                        res[1] = colors[2];\r\n                        break;\r\n                    }\r\n                    case 3:\r\n                    case 4:\r\n                    case 5:\r\n                    case 6:\r\n                        res = ColorBrewer.getColors('YlOrRd', numClasses);\r\n                        break;\r\n                    case 7:\r\n                    case 8:\r\n                        res = ColorBrewer.getColors('YlGnBu', numClasses);\r\n                        break;\r\n                    case 9:\r\n                        res = ColorBrewer.getColors('GnBu', numClasses);\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns the default color for Change Maps taking in consideration the given number of classes and nature of data currently being used.\r\n     * @static\r\n     * @param { string } dataNature - The type of data.\r\n     * @param { number } numClasses - The number of classes.\r\n     * @returns { Array<number>} the default color for the given number of classes and nature of data currently being used.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getChangeMapDefaults(dataNature, numClasses) {\r\n        let res = [];\r\n        switch (dataNature) {\r\n            case GisplayDefaults.DIVERGENT():\r\n                switch (numClasses) {\r\n                    case 2: {\r\n                        let colors = ColorBrewer.getColors('Spectral', 4);\r\n                        res[0] = colors[2];\r\n                        res[1] = colors[0];\r\n                        break;\r\n                    }\r\n                    default:\r\n                        res = ColorBrewer.getColors('RdYlGn', numClasses);\r\n                        res = res.reverse(); //Start with lower color to higher color\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns the default color for Dot Maps taking in consideration the given number of classes and nature of data currently being used.\r\n     * @static\r\n     * @param { string } dataNature - The type of data.\r\n     * @param { number } numClasses - The number of classes.\r\n     * @returns { Array<number>} the default color for the given number of classes and nature of data currently being used.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getDotMapDefaults(dataNature, numClasses) {\r\n        let res = [];\r\n\r\n        switch (dataNature) {\r\n            case GisplayDefaults.SEQUENTIAL():\r\n                switch (numClasses) {\r\n                    case 2: {\r\n                        let colors = ColorBrewer.getColors('Reds', 3);\r\n                        res[0] = colors[0];\r\n                        res[1] = colors[2];\r\n                        break;\r\n                    }\r\n                    default:\r\n                        res = ColorBrewer.getColors('YlOrRd', numClasses);\r\n                        break;\r\n                }\r\n                break;\r\n            case GisplayDefaults.QUALITATIVE():\r\n                switch (numClasses) {\r\n                    case 2: {\r\n                        let colors = ColorBrewer.getColors('Set1', 3);\r\n                        res[0] = colors[0];\r\n                        res[1] = colors[2];\r\n                        break;\r\n                    }\r\n                    case 3:\r\n                    case 4:\r\n                    case 5:\r\n                    case 6:\r\n                    case 7:\r\n                    case 8:\r\n                    case 9:\r\n                        res = ColorBrewer.getColors('Set1', numClasses);\r\n                        break;\r\n                    default:\r\n                        res = ColorBrewer.getColors('Paired', numClasses);\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns the default color for Proportional Symbols Maps taking in consideration the given number of classes and nature of data currently being used.\r\n     * @static\r\n     * @param {string} dataNature - The type of data.\r\n     * @param {number} numClasses - The number of classes.\r\n     * @returns {Array<number>} the default color for the given number of classes and nature of data currently being used.\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getProportionalSymbolsDefaults(dataNature, numClasses) {\r\n        let res = [];\r\n        switch (dataNature) {\r\n            case GisplayDefaults.SEQUENTIAL():\r\n                switch (numClasses) {\r\n                    case 1:\r\n                    case 2: {\r\n                        let colors = ColorBrewer.getColors('YlOrRd', 3);\r\n                        res[0] = colors[2];\r\n                        res[1] = colors[2];\r\n                        break;\r\n                    }\r\n                    default:\r\n                        res = ColorBrewer.getColors('YlOrRd', numClasses);\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns the ColorBrewer object of type of color schemes. \r\n     * @static\r\n     * @returns {Object} - the ColorBrewer object of type of color schemes. \r\n     * @see https://github.com/axismaps/colorbrewer/blob/master/colorbrewer_schemes.js\r\n     * @memberOf ColorBrewer\r\n     */\r\n    static getColorBrewerVariable() {\r\n        return {\r\n            Diverging: { /*** Diverging ***/\r\n                Spectral: {\r\n                    3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(153,213,148)'],\r\n                    4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,221,164)', 'rgb(43,131,186)'],\r\n                    5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,221,164)', 'rgb(43,131,186)'],\r\n                    6: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'],\r\n                    7: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'],\r\n                    8: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'],\r\n                    9: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'],\r\n                    10: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'],\r\n                    11: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [2, 2, 2, 0, 0, 0, 0, 0, 0],\r\n                        'print': [1, 1, 1, 0, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 1, 1, 0, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                RdYlGn: {\r\n                    3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,207,96)'],\r\n                    4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(166,217,106)', 'rgb(26,150,65)'],\r\n                    5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(166,217,106)', 'rgb(26,150,65)'],\r\n                    6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'],\r\n                    7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'],\r\n                    8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'],\r\n                    9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'],\r\n                    10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'],\r\n                    11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [2, 2, 2, 0, 0, 0, 0, 0, 0],\r\n                        'print': [1, 1, 1, 2, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                RdBu: {\r\n                    3: ['rgb(239,138,98)', 'rgb(247,247,247)', 'rgb(103,169,207)'],\r\n                    4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(146,197,222)', 'rgb(5,113,176)'],\r\n                    5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(247,247,247)', 'rgb(146,197,222)', 'rgb(5,113,176)'],\r\n                    6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'],\r\n                    7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'],\r\n                    8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'],\r\n                    9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'],\r\n                    10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'],\r\n                    11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 1, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PiYG: {\r\n                    3: ['rgb(233,163,201)', 'rgb(247,247,247)', 'rgb(161,215,106)'],\r\n                    4: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(184,225,134)', 'rgb(77,172,38)'],\r\n                    5: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(247,247,247)', 'rgb(184,225,134)', 'rgb(77,172,38)'],\r\n                    6: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'],\r\n                    7: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'],\r\n                    8: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'],\r\n                    9: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'],\r\n                    10: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'],\r\n                    11: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 0, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PRGn: {\r\n                    3: ['rgb(175,141,195)', 'rgb(247,247,247)', 'rgb(127,191,123)'],\r\n                    4: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(166,219,160)', 'rgb(0,136,55)'],\r\n                    5: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(247,247,247)', 'rgb(166,219,160)', 'rgb(0,136,55)'],\r\n                    6: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'],\r\n                    7: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'],\r\n                    8: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'],\r\n                    9: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'],\r\n                    10: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'],\r\n                    11: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 1, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 2, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                RdYlBu: {\r\n                    3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,191,219)'],\r\n                    4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,217,233)', 'rgb(44,123,182)'],\r\n                    5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,217,233)', 'rgb(44,123,182)'],\r\n                    6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'],\r\n                    7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'],\r\n                    8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'],\r\n                    9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'],\r\n                    10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'],\r\n                    11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 1, 2, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                BrBG: {\r\n                    3: ['rgb(216,179,101)', 'rgb(245,245,245)', 'rgb(90,180,172)'],\r\n                    4: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(128,205,193)', 'rgb(1,133,113)'],\r\n                    5: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(245,245,245)', 'rgb(128,205,193)', 'rgb(1,133,113)'],\r\n                    6: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'],\r\n                    7: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'],\r\n                    8: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'],\r\n                    9: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'],\r\n                    10: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'],\r\n                    11: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 1, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 1, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                RdGy: {\r\n                    3: ['rgb(239,138,98)', 'rgb(255,255,255)', 'rgb(153,153,153)'],\r\n                    4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(186,186,186)', 'rgb(64,64,64)'],\r\n                    5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(255,255,255)', 'rgb(186,186,186)', 'rgb(64,64,64)'],\r\n                    6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'],\r\n                    7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'],\r\n                    8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'],\r\n                    9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'],\r\n                    10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'],\r\n                    11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [2],\r\n                        'print': [1, 1, 1, 2, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PuOr: {\r\n                    3: ['rgb(241,163,64)', 'rgb(247,247,247)', 'rgb(153,142,195)'],\r\n                    4: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(178,171,210)', 'rgb(94,60,153)'],\r\n                    5: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(247,247,247)', 'rgb(178,171,210)', 'rgb(94,60,153)'],\r\n                    6: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'],\r\n                    7: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'],\r\n                    8: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'],\r\n                    9: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'],\r\n                    10: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'],\r\n                    11: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'],\r\n                    'properties': {\r\n                        'type': 'div',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 2, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 1, 0, 0, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 1, 0, 0, 0, 0, 0]\r\n                    }\r\n                }\r\n            },\r\n\r\n            Qualitative: { /*** Qualitative ***/\r\n                Set2: {\r\n                    3: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)'],\r\n                    4: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)'],\r\n                    5: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)'],\r\n                    6: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)'],\r\n                    7: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)'],\r\n                    8: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)', 'rgb(179,179,179)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [1, 2, 2, 2, 0, 0, 0],\r\n                        'print': [1, 1, 1, 2, 2, 2],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 2, 2, 2, 2]\r\n                    }\r\n                },\r\n                Accent: {\r\n                    3: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)'],\r\n                    4: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)'],\r\n                    5: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)'],\r\n                    6: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)'],\r\n                    7: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)'],\r\n                    8: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)', 'rgb(102,102,102)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [2, 0, 0, 0, 0, 0, 0],\r\n                        'print': [1, 1, 2, 2, 2, 2],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 2, 2, 2]\r\n                    }\r\n                },\r\n                Set1: {\r\n                    3: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)'],\r\n                    4: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)'],\r\n                    5: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)'],\r\n                    6: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)'],\r\n                    7: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)'],\r\n                    8: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)'],\r\n                    9: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)', 'rgb(153,153,153)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [2],\r\n                        'print': [1],\r\n                        'copy': [0],\r\n                        'screen': [1]\r\n                    }\r\n                },\r\n                Set3: {\r\n                    3: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)'],\r\n                    4: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)'],\r\n                    5: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)'],\r\n                    6: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)'],\r\n                    7: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)'],\r\n                    8: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)'],\r\n                    9: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)'],\r\n                    10: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)'],\r\n                    11: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)'],\r\n                    12: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)', 'rgb(255,237,111)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [2, 2, 0, 0, 0, 0, 0, 0, 0, 0],\r\n                        'print': [1, 1, 1, 1, 1, 1, 2, 0, 0, 0],\r\n                        'copy': [1, 2, 2, 2, 2, 2, 2, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 2, 2, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Dark2: {\r\n                    3: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)'],\r\n                    4: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)'],\r\n                    5: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)'],\r\n                    6: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)'],\r\n                    7: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)'],\r\n                    8: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)', 'rgb(102,102,102)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [1, 2, 2, 2, 0, 0],\r\n                        'print': [1],\r\n                        'copy': [0],\r\n                        'screen': [1]\r\n                    }\r\n                },\r\n                Paired: {\r\n                    3: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)'],\r\n                    4: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)'],\r\n                    5: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)'],\r\n                    6: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)'],\r\n                    7: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)'],\r\n                    8: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)'],\r\n                    9: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)'],\r\n                    10: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)'],\r\n                    11: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)'],\r\n                    12: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)', 'rgb(177,89,40)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [1, 1, 2, 2, 2, 2, 0, 0, 0],\r\n                        'print': [1, 1, 1, 1, 1, 2, 2, 2, 2],\r\n                        'copy': [0],\r\n                        'screen': [1, 1, 1, 1, 1, 1, 1, 1, 2]\r\n                    }\r\n                },\r\n                Pastel2: {\r\n                    3: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)'],\r\n                    4: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)'],\r\n                    5: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)'],\r\n                    6: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)'],\r\n                    7: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)'],\r\n                    8: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)', 'rgb(204,204,204)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [2, 0, 0, 0, 0, 0],\r\n                        'print': [2, 0, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [2, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Pastel1: {\r\n                    3: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)'],\r\n                    4: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)'],\r\n                    5: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)'],\r\n                    6: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)'],\r\n                    7: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)'],\r\n                    8: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)'],\r\n                    9: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)', 'rgb(242,242,242)'],\r\n                    'properties': {\r\n                        'type': 'qual',\r\n                        'blind': [2, 0, 0, 0, 0, 0, 0],\r\n                        'print': [2, 2, 2, 0, 0, 0, 0],\r\n                        'copy': [0],\r\n                        'screen': [2, 2, 2, 2, 0, 0, 0]\r\n                    }\r\n                }\r\n            },\r\n\r\n            Sequential: {/*** Sequential ***/\r\n                OrRd: {\r\n                    3: ['rgb(254,232,200)', 'rgb(253,187,132)', 'rgb(227,74,51)'],\r\n                    4: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(215,48,31)'],\r\n                    5: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'],\r\n                    6: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'],\r\n                    7: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'],\r\n                    8: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'],\r\n                    9: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(179,0,0)', 'rgb(127,0,0)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 1, 2, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PuBu: {\r\n                    3: ['rgb(236,231,242)', 'rgb(166,189,219)', 'rgb(43,140,190)'],\r\n                    4: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(5,112,176)'],\r\n                    5: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'],\r\n                    6: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'],\r\n                    7: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'],\r\n                    8: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'],\r\n                    9: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(4,90,141)', 'rgb(2,56,88)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 2, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                BuPu: {\r\n                    3: ['rgb(224,236,244)', 'rgb(158,188,218)', 'rgb(136,86,167)'],\r\n                    4: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,65,157)'],\r\n                    5: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'],\r\n                    6: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'],\r\n                    7: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'],\r\n                    8: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'],\r\n                    9: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(129,15,124)', 'rgb(77,0,75)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 2, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Oranges: {\r\n                    3: ['rgb(254,230,206)', 'rgb(253,174,107)', 'rgb(230,85,13)'],\r\n                    4: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(217,71,1)'],\r\n                    5: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'],\r\n                    6: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'],\r\n                    7: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'],\r\n                    8: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'],\r\n                    9: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(166,54,3)', 'rgb(127,39,4)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 2, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 2, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                BuGn: {\r\n                    3: ['rgb(229,245,249)', 'rgb(153,216,201)', 'rgb(44,162,95)'],\r\n                    4: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(35,139,69)'],\r\n                    5: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'],\r\n                    6: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'],\r\n                    7: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'],\r\n                    8: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'],\r\n                    9: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                YlOrBr: {\r\n                    3: ['rgb(255,247,188)', 'rgb(254,196,79)', 'rgb(217,95,14)'],\r\n                    4: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(204,76,2)'],\r\n                    5: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'],\r\n                    6: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'],\r\n                    7: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'],\r\n                    8: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'],\r\n                    9: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(153,52,4)', 'rgb(102,37,6)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 2, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                YlGn: {\r\n                    3: ['rgb(247,252,185)', 'rgb(173,221,142)', 'rgb(49,163,84)'],\r\n                    4: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(35,132,67)'],\r\n                    5: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'],\r\n                    6: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'],\r\n                    7: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'],\r\n                    8: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'],\r\n                    9: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,104,55)', 'rgb(0,69,41)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Reds: {\r\n                    3: ['rgb(254,224,210)', 'rgb(252,146,114)', 'rgb(222,45,38)'],\r\n                    4: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(203,24,29)'],\r\n                    5: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'],\r\n                    6: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'],\r\n                    7: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'],\r\n                    8: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'],\r\n                    9: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(165,15,21)', 'rgb(103,0,13)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 2, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                RdPu: {\r\n                    3: ['rgb(253,224,221)', 'rgb(250,159,181)', 'rgb(197,27,138)'],\r\n                    4: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(174,1,126)'],\r\n                    5: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'],\r\n                    6: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'],\r\n                    7: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'],\r\n                    8: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'],\r\n                    9: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)', 'rgb(73,0,106)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 2, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Greens: {\r\n                    3: ['rgb(229,245,224)', 'rgb(161,217,155)', 'rgb(49,163,84)'],\r\n                    4: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(35,139,69)'],\r\n                    5: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'],\r\n                    6: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'],\r\n                    7: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'],\r\n                    8: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'],\r\n                    9: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 0, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                YlGnBu: {\r\n                    3: ['rgb(237,248,177)', 'rgb(127,205,187)', 'rgb(44,127,184)'],\r\n                    4: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(34,94,168)'],\r\n                    5: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'],\r\n                    6: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'],\r\n                    7: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'],\r\n                    8: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'],\r\n                    9: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(37,52,148)', 'rgb(8,29,88)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 2, 2, 2, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Purples: {\r\n                    3: ['rgb(239,237,245)', 'rgb(188,189,220)', 'rgb(117,107,177)'],\r\n                    4: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(106,81,163)'],\r\n                    5: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'],\r\n                    6: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'],\r\n                    7: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'],\r\n                    8: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'],\r\n                    9: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(84,39,143)', 'rgb(63,0,125)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 0, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 0, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                GnBu: {\r\n                    3: ['rgb(224,243,219)', 'rgb(168,221,181)', 'rgb(67,162,202)'],\r\n                    4: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(43,140,190)'],\r\n                    5: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'],\r\n                    6: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'],\r\n                    7: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'],\r\n                    8: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'],\r\n                    9: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,104,172)', 'rgb(8,64,129)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 2, 2, 2, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Greys: {\r\n                    3: ['rgb(240,240,240)', 'rgb(189,189,189)', 'rgb(99,99,99)'],\r\n                    4: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(82,82,82)'],\r\n                    5: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'],\r\n                    6: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'],\r\n                    7: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'],\r\n                    8: ['rgb(255,255,255)', 'rgb(240,240,240)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'],\r\n                    9: ['rgb(255,255,255)', 'rgb(240,240,240)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)', 'rgb(0,0,0)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 0, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                YlOrRd: {\r\n                    3: ['rgb(255,237,160)', 'rgb(254,178,76)', 'rgb(240,59,32)'],\r\n                    4: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(227,26,28)'],\r\n                    5: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'],\r\n                    6: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'],\r\n                    7: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'],\r\n                    8: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'],\r\n                    9: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(189,0,38)', 'rgb(128,0,38)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 2, 2, 0, 0, 0],\r\n                        'copy': [1, 2, 2, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 2, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PuRd: {\r\n                    3: ['rgb(231,225,239)', 'rgb(201,148,199)', 'rgb(221,28,119)'],\r\n                    4: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(206,18,86)'],\r\n                    5: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'],\r\n                    6: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'],\r\n                    7: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'],\r\n                    8: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'],\r\n                    9: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(152,0,67)', 'rgb(103,0,31)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 1, 1, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 1, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                Blues: {\r\n                    3: ['rgb(222,235,247)', 'rgb(158,202,225)', 'rgb(49,130,189)'],\r\n                    4: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(33,113,181)'],\r\n                    5: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'],\r\n                    6: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'],\r\n                    7: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'],\r\n                    8: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'],\r\n                    9: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,81,156)', 'rgb(8,48,107)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 2, 0, 0, 0, 0, 0],\r\n                        'copy': [1, 0, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 2, 0, 0, 0, 0, 0]\r\n                    }\r\n                },\r\n                PuBuGn: {\r\n                    3: ['rgb(236,226,240)', 'rgb(166,189,219)', 'rgb(28,144,153)'],\r\n                    4: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(2,129,138)'],\r\n                    5: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'],\r\n                    6: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'],\r\n                    7: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'],\r\n                    8: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'],\r\n                    9: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,108,89)', 'rgb(1,70,54)'],\r\n                    'properties': {\r\n                        'type': 'seq',\r\n                        'blind': [1],\r\n                        'print': [1, 2, 2, 0, 0, 0, 0],\r\n                        'copy': [1, 2, 0, 0, 0, 0, 0],\r\n                        'screen': [1, 1, 2, 0, 0, 0, 0]\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the colors in number format.\r\n     * IN: [ [\"255\", \"237\", \"160\"], ...] -> OUT: [ [255, 237, 160], ...]\r\n     * @static\r\n     * @param {Array<Array<string>>} rgbColorsStrs - The colors in . \r\n     * @returns {Array<Array<number>>} - the colors in number format.\r\n     * @memberof ColorBrewer\r\n     */\r\n    static convertRGBStrToNum(rgbColorsStrs) {\r\n        let rgbColorsNums = [];\r\n        for (const color of rgbColorsStrs) {\r\n            let rgbColor = [];\r\n            for (const rgb of color) {\r\n                rgbColor.push(+rgb);\r\n            }\r\n            rgbColorsNums.push(rgbColor);\r\n        }\r\n        return rgbColorsNums;\r\n    }\r\n\r\n    /**\r\n     * Converts a given hexadecimal color to decimal (RGB).\r\n     * @static\r\n     * @param {string} hex - The hexadecimal color. \r\n     * @returns {Array<number>} - the red, green and blue values (RGB) conversion of the given hexadecimal string.\r\n     * @memberof ColorBrewer\r\n     */\r\n    static convertHexColorToRGB(hex) {\r\n        let colorNums = [];\r\n        let hexValues = hex.split('#')[1];\r\n        for (let i = 0; i < hexValues.length; i += 2)\r\n            colorNums.push(parseInt(hexValues.slice(i, i + 2), 16));\r\n        return colorNums;\r\n    }\r\n\r\n    /**\r\n     * Convert the given color name to it's RGB value.\r\n     * @static\r\n     * @param {string} colorName - The name of the color. \r\n     * @returns {Array<number>} - the RGB value of the given color name.\r\n     * @memberof ColorBrewer\r\n     */\r\n    static convertNameToRGB(colorName) {\r\n        let hexColor = this.colorNameToHex(colorName);\r\n        if (hexColor)\r\n            return this.convertHexColorToRGB(hexColor);\r\n        throw new GisplayError(`Color name: ${colorName}, not found.`);\r\n    }\r\n\r\n    static colorNameToHex(colourName) {\r\n        let colours = {\r\n            \"aliceblue\": \"#f0f8ff\", \"antiquewhite\": \"#faebd7\", \"aqua\": \"#00ffff\", \"aquamarine\": \"#7fffd4\", \"azure\": \"#f0ffff\",\r\n            \"beige\": \"#f5f5dc\", \"bisque\": \"#ffe4c4\", \"black\": \"#000000\", \"blanchedalmond\": \"#ffebcd\", \"blue\": \"#0000ff\",\r\n            \"blueviolet\": \"#8a2be2\", \"brown\": \"#a52a2a\", \"burlywood\": \"#deb887\",\r\n            \"cadetblue\": \"#5f9ea0\", \"chartreuse\": \"#7fff00\", \"chocolate\": \"#d2691e\", \"coral\": \"#ff7f50\", \"cornflowerblue\": \"#6495ed\",\r\n            \"cornsilk\": \"#fff8dc\", \"crimson\": \"#dc143c\", \"cyan\": \"#00ffff\",\r\n            \"darkblue\": \"#00008b\", \"darkcyan\": \"#008b8b\", \"darkgoldenrod\": \"#b8860b\", \"darkgray\": \"#a9a9a9\", \"darkgreen\": \"#006400\",\r\n            \"darkkhaki\": \"#bdb76b\", \"darkmagenta\": \"#8b008b\", \"darkolivegreen\": \"#556b2f\",\r\n            \"darkorange\": \"#ff8c00\", \"darkorchid\": \"#9932cc\", \"darkred\": \"#8b0000\", \"darksalmon\": \"#e9967a\", \"darkseagreen\": \"#8fbc8f\",\r\n            \"darkslateblue\": \"#483d8b\", \"darkslategray\": \"#2f4f4f\", \"darkturquoise\": \"#00ced1\",\r\n            \"darkviolet\": \"#9400d3\", \"deeppink\": \"#ff1493\", \"deepskyblue\": \"#00bfff\", \"dimgray\": \"#696969\", \"dodgerblue\": \"#1e90ff\",\r\n            \"firebrick\": \"#b22222\", \"floralwhite\": \"#fffaf0\", \"forestgreen\": \"#228b22\", \"fuchsia\": \"#ff00ff\",\r\n            \"gainsboro\": \"#dcdcdc\", \"ghostwhite\": \"#f8f8ff\", \"gold\": \"#ffd700\", \"goldenrod\": \"#daa520\", \"gray\": \"#808080\", \"green\": \"#008000\",\r\n            \"greenyellow\": \"#adff2f\", \"honeydew\": \"#f0fff0\", \"hotpink\": \"#ff69b4\", \"indianred \": \"#cd5c5c\", \"indigo\": \"#4b0082\",\r\n            \"ivory\": \"#fffff0\", \"khaki\": \"#f0e68c\", \"lavender\": \"#e6e6fa\", \"lavenderblush\": \"#fff0f5\", \"lawngreen\": \"#7cfc00\",\r\n            \"lemonchiffon\": \"#fffacd\", \"lightblue\": \"#add8e6\", \"lightcoral\": \"#f08080\", \"lightcyan\": \"#e0ffff\", \"lightgoldenrodyellow\": \"#fafad2\",\r\n            \"lightgrey\": \"#d3d3d3\", \"lightgreen\": \"#90ee90\", \"lightpink\": \"#ffb6c1\", \"lightsalmon\": \"#ffa07a\", \"lightseagreen\": \"#20b2aa\",\r\n            \"lightskyblue\": \"#87cefa\", \"lightslategray\": \"#778899\", \"lightsteelblue\": \"#b0c4de\",\r\n            \"lightyellow\": \"#ffffe0\", \"lime\": \"#00ff00\", \"limegreen\": \"#32cd32\", \"linen\": \"#faf0e6\",\r\n            \"magenta\": \"#ff00ff\", \"maroon\": \"#800000\", \"mediumaquamarine\": \"#66cdaa\", \"mediumblue\": \"#0000cd\", \"mediumorchid\": \"#ba55d3\",\r\n            \"mediumpurple\": \"#9370d8\", \"mediumseagreen\": \"#3cb371\", \"mediumslateblue\": \"#7b68ee\",\r\n            \"mediumspringgreen\": \"#00fa9a\", \"mediumturquoise\": \"#48d1cc\", \"mediumvioletred\": \"#c71585\", \"midnightblue\": \"#191970\",\r\n            \"mintcream\": \"#f5fffa\", \"mistyrose\": \"#ffe4e1\", \"moccasin\": \"#ffe4b5\",\r\n            \"navajowhite\": \"#ffdead\", \"navy\": \"#000080\", \"yellow\": \"#ffff00\", \"yellowgreen\": \"#9acd32\",\r\n            \"oldlace\": \"#fdf5e6\", \"olive\": \"#808000\", \"olivedrab\": \"#6b8e23\", \"orange\": \"#ffa500\", \"orangered\": \"#ff4500\", \"orchid\": \"#da70d6\",\r\n            \"palegoldenrod\": \"#eee8aa\", \"palegreen\": \"#98fb98\", \"paleturquoise\": \"#afeeee\", \"palevioletred\": \"#d87093\",\r\n            \"papayawhip\": \"#ffefd5\", \"peachpuff\": \"#ffdab9\", \"peru\": \"#cd853f\", \"pink\": \"#ffc0cb\", \"plum\": \"#dda0dd\", \"powderblue\": \"#b0e0e6\",\r\n            \"purple\": \"#800080\", \"rebeccapurple\": \"#663399\", \"red\": \"#ff0000\", \"rosybrown\": \"#bc8f8f\", \"royalblue\": \"#4169e1\",\r\n            \"saddlebrown\": \"#8b4513\", \"salmon\": \"#fa8072\", \"sandybrown\": \"#f4a460\", \"seagreen\": \"#2e8b57\", \"seashell\": \"#fff5ee\",\r\n            \"sienna\": \"#a0522d\", \"silver\": \"#c0c0c0\", \"skyblue\": \"#87ceeb\", \"slateblue\": \"#6a5acd\", \"slategray\": \"#708090\",\r\n            \"snow\": \"#fffafa\", \"springgreen\": \"#00ff7f\", \"steelblue\": \"#4682b4\",\r\n            \"tan\": \"#d2b48c\", \"teal\": \"#008080\", \"thistle\": \"#d8bfd8\", \"tomato\": \"#ff6347\", \"turquoise\": \"#40e0d0\",\r\n            \"violet\": \"#ee82ee\", \"wheat\": \"#f5deb3\", \"white\": \"#ffffff\", \"whitesmoke\": \"#f5f5f5\"\r\n        };\r\n\r\n        if (typeof colours[colourName.toLowerCase()] !== 'undefined')\r\n            return colours[colourName.toLowerCase()];\r\n        return false;\r\n    }\r\n}\r\n\r\n/*console.log(ColorBrewer.getDivergingColorSchemes());\r\nconsole.log(ColorBrewer.getSequentialColorSchemes());\r\nconsole.log(ColorBrewer.getQualitativeColorSchemes());*/\r\n//console.log(ColorBrewer.getColorSchemesByName('Spectral'));\r\n//console.log(ColorBrewer.byNameAndNumber('Spectral', 9));\r\n//console.log(ColorBrewer.byNameAndNumber('Spectral', 3)[0]);\r\n// console.log(ColorBrewer.getColors('Spectral', 7));\r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Helpers/ColorBrewer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 195,
    "kind": "class",
    "name": "ColorBrewer",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js",
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Helpers/ColorBrewer.js",
    "importStyle": "{ColorBrewer}",
    "description": "This class will contain all ColorBrewer color schemes and methods to query said color schemes.\nThese queries can be: by their type(Diverging, Qualitative and Sequential), name(Spectral, RdYlGn, etc etc) and number of classes(3,4...). ",
    "see": [
      "https://github.com/axismaps/colorbrewer/blob/master/colorbrewer_schemes.js",
      " https://colorbrewer2.org/"
    ],
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ColorBrewerHelper"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "getColorScheme",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getColorScheme",
    "access": "public",
    "description": "Returns an array with numOfClasses elements that are the colors for the given type of color scheme and it's name.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<RGB>} - Array with the colors given by Color Brewer."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type of color scheme (Options are: Sequential, Diverging and Qualitative)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the color scheme to search."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numOfClasses",
        "description": "Number of classes to search."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<RGB>"
      ],
      "spread": false,
      "description": "Array with the colors given by Color Brewer."
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "getDivergingColorSchemes",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getDivergingColorSchemes",
    "access": "public",
    "description": "Returns all the ColorBrewer diverging color schemes. ",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - all the ColorBrewer diverging color schemes. "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "all the ColorBrewer diverging color schemes."
    }
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "getQualitativeColorSchemes",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getQualitativeColorSchemes",
    "access": "public",
    "description": "Returns all the ColorBrewer qualitative color schemes.",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - all the ColorBrewer qualitative color schemes."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "all the ColorBrewer qualitative color schemes."
    }
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "getSequentialColorSchemes",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getSequentialColorSchemes",
    "access": "public",
    "description": "Returns all the ColorBrewer the sequential color schemes.",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - all the ColorBrewer sequential color schemes."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "all the ColorBrewer sequential color schemes."
    }
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "byName",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.byName",
    "access": "public",
    "description": "This is just an alias for the method getColorSchemesByName(name).",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} an object with multiple color schemes for each number of classes associated with the color scheme given as input."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "an object with multiple color schemes for each number of classes associated with the color scheme given as input."
    }
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "getColorSchemesByName",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getColorSchemesByName",
    "access": "public",
    "description": "Return an object with multiple color schemes for each number of classes associated with the color scheme given as input.",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} an object with multiple color schemes for each number of classes associated with the color scheme given as input."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "an object with multiple color schemes for each number of classes associated with the color scheme given as input."
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "byNumber",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.byNumber",
    "access": "public",
    "description": "Returns all ColorSchemes that contain the number of class given as input.",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - Object with "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": "number of classes to search for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Object with"
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "getAllColorSchemesByNumberOfClasses",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getAllColorSchemesByNumberOfClasses",
    "access": "public",
    "description": "Returns an object of color schemes with only those the objects for the specified number of classes.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - an object of color schemes with only those the objects for the specified number of classes."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "an object of color schemes with only those the objects for the specified number of classes."
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "byNameAndNumber",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.byNameAndNumber",
    "access": "public",
    "description": "For the given color scheme name and number of classes returns the RGB colors associated with them.",
    "lineNumber": 121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<RGB>} Array of colors associated with color scheme name and number of classes."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<RGB>"
      ],
      "spread": false,
      "description": "Array of colors associated with color scheme name and number of classes."
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "getAllColorSchemesByNumberOfClassesAsArray",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getAllColorSchemesByNumberOfClassesAsArray",
    "access": "public",
    "description": "",
    "lineNumber": 135,
    "deprecated": "Use byNumber(n) or getAllColorSchemesByNumberOfClasses(n) instead.",
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Object>}"
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "getColors",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getColors",
    "access": "public",
    "description": "Given the color scheme name and the number of classes returns an Array of colors associated with the given name and number of classes. ",
    "see": [
      "http://stackoverflow.com/a/10971090/"
    ],
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} Colors of the color scheme. As many as number of classes given.  "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "color name"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": "number of classes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "Colors of the color scheme. As many as number of classes given."
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "getColorsHex",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getColorsHex",
    "access": "public",
    "description": "Given the color scheme name and the number of classes returns an Array of colors associated with the given name and number of classes. ",
    "see": [
      "http://stackoverflow.com/a/57805/5869289"
    ],
    "lineNumber": 173,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<string>>} Colors of the color scheme in hexacedimal format.  "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "color name"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": "number of classes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<string>>"
      ],
      "spread": false,
      "description": "Colors of the color scheme in hexacedimal format."
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "getDefautls",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getDefautls",
    "access": "public",
    "description": "Returns the defaults for each map, given it's name, number of classes and nature of the data.",
    "lineNumber": 199,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the defaults for each map, given it's name, number of classes and nature of the data."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mapName",
        "description": "The name of the map."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "The number of classes to build."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "The nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the defaults for each map, given it's name, number of classes and nature of the data."
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "getChoroplethDefaults",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getChoroplethDefaults",
    "access": "public",
    "description": "Returns the default color for Choropleth Maps taking in consideration the given number of classes and nature of data currently being used.",
    "lineNumber": 246,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ Array<number>} the default color for the given number of classes and nature of data currently being used."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "The type of data."
      },
      {
        "nullable": null,
        "types": [
          " number "
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "The number of classes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " Array<number>"
      ],
      "spread": false,
      "description": "the default color for the given number of classes and nature of data currently being used."
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "getChangeMapDefaults",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getChangeMapDefaults",
    "access": "public",
    "description": "Returns the default color for Change Maps taking in consideration the given number of classes and nature of data currently being used.",
    "lineNumber": 284,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ Array<number>} the default color for the given number of classes and nature of data currently being used."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "The type of data."
      },
      {
        "nullable": null,
        "types": [
          " number "
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "The number of classes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " Array<number>"
      ],
      "spread": false,
      "description": "the default color for the given number of classes and nature of data currently being used."
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "getDotMapDefaults",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getDotMapDefaults",
    "access": "public",
    "description": "Returns the default color for Dot Maps taking in consideration the given number of classes and nature of data currently being used.",
    "lineNumber": 313,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ Array<number>} the default color for the given number of classes and nature of data currently being used."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "The type of data."
      },
      {
        "nullable": null,
        "types": [
          " number "
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "The number of classes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " Array<number>"
      ],
      "spread": false,
      "description": "the default color for the given number of classes and nature of data currently being used."
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "getProportionalSymbolsDefaults",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getProportionalSymbolsDefaults",
    "access": "public",
    "description": "Returns the default color for Proportional Symbols Maps taking in consideration the given number of classes and nature of data currently being used.",
    "lineNumber": 364,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} the default color for the given number of classes and nature of data currently being used."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "The type of data."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "The number of classes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the default color for the given number of classes and nature of data currently being used."
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "getColorBrewerVariable",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.getColorBrewerVariable",
    "access": "public",
    "description": "Returns the ColorBrewer object of type of color schemes. ",
    "see": [
      "https://github.com/axismaps/colorbrewer/blob/master/colorbrewer_schemes.js"
    ],
    "lineNumber": 392,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - the ColorBrewer object of type of color schemes. "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ColorBrewer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the ColorBrewer object of type of color schemes."
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "convertRGBStrToNum",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.convertRGBStrToNum",
    "access": "public",
    "description": "Returns the colors in number format.\nIN: [ [\"255\", \"237\", \"160\"], ...] -> OUT: [ [255, 237, 160], ...]",
    "lineNumber": 993,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} - the colors in number format."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Array<string>>"
        ],
        "spread": false,
        "optional": false,
        "name": "rgbColorsStrs",
        "description": "The colors in ."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "the colors in number format."
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "convertHexColorToRGB",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.convertHexColorToRGB",
    "access": "public",
    "description": "Converts a given hexadecimal color to decimal (RGB).",
    "lineNumber": 1012,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the red, green and blue values (RGB) conversion of the given hexadecimal string."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hex",
        "description": "The hexadecimal color."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the red, green and blue values (RGB) conversion of the given hexadecimal string."
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "convertNameToRGB",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.convertNameToRGB",
    "access": "public",
    "description": "Convert the given color name to it's RGB value.",
    "lineNumber": 1027,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the RGB value of the given color name."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "colorName",
        "description": "The name of the color."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the RGB value of the given color name."
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "colorNameToHex",
    "memberof": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.colorNameToHex",
    "access": "public",
    "description": null,
    "lineNumber": 1034,
    "undocument": true
  },
  {
    "__docId__": 218,
    "kind": "file",
    "name": "src/Gisplay/Helpers/WebGLUtils.js",
    "content": "/**\r\n * Class with static methods that will help with WebGL related stuff(Matrices, web mercator projection and shaders).\r\n * Always remeber WebGL is column major when reading the matrix code.\r\n * @see http://ptgmedia.pearsoncmg.com/images/chap3_9780321902924/elementLinks/03fig27.jpg\r\n * @static \r\n * @class WebGLUtils\r\n */\r\nexport class WebGLUtils {\r\n    /**\r\n     * Calculates the scale and offset(X and Y) for the Web Mercator projection.\r\n     * @static\r\n     * @param {number} longitudeCenter - Longitude of the given position.\r\n     * @param {number} latitudeCenter - Latitude of the given position.\r\n     * @param {number} zoom - Current zoom level of the background map.\r\n     * @param {number} tileSize - The size of each tile in the background map. Usually is 256. If different should be given in the API options.\r\n     * @param {number} width - Width of the current canvas.\r\n     * @param {number} height - Height of the current canvas.\r\n     * @returns {{scale: number, offsetX: number, offsetY: number}} - Returns the scale, offsetX and offsetY of the point given using the Web Mercator projection.\r\n     * @see https://bl.ocks.org/enjalot/fb7f3d696167e9b83a72#viewport.js\r\n     * @see https://en.wikipedia.org/wiki/Web_Mercator\r\n     * @memberof WebGLUtils\r\n     */\r\n    static webMercatorProjection(longitudeCenter, latitudeCenter, zoom, tileSize, width, height) {\r\n        // console.log(longitudeCenter, latitudeCenter, zoom, tileSize,  width, height);\r\n        let PI = Math.PI;\r\n        let scale = ((tileSize / 2) / PI) * Math.pow(2, zoom);\r\n        let lambda = longitudeCenter * (PI / 180); // Convert longitude to radians\r\n        let phi = latitudeCenter * (PI / 180); // Convert latitude to radians\r\n\r\n        let xCenter = scale * (lambda + PI);\r\n        let yCenter = scale * (PI - Math.log(Math.tan((PI / 4) + (phi / 2))));\r\n        let offsetX = (width / 2) - xCenter;\r\n        let offsetY = (height / 2) - yCenter;\r\n\r\n        return { scale: scale, offsetX: offsetX, offsetY: offsetY };\r\n    }\r\n\r\n    /**\r\n     * This is the result matrix from the multiplication of M1*M2*M3\r\n     * @static\r\n     * @param {number} scale - The scale calculated with WebMercator projection.\r\n     * @param {number} width - The width of the canvas.\r\n     * @param {number} height - The height of the canvas.\r\n     * @param {number} offsetX - The offsetX calculated with WebMercator projection.\r\n     * @param {number} offsetY - The offsetY calculated with WebMercator projection.\r\n     * @returns {Float32Array} The resulting matrix (M1*M2*M3) in a single matrix to send to WebGL in order to calculate the resulting position.\r\n     * @see Rui's thesis\r\n     * @memberof WebGLUtils\r\n     */\r\n    static finalMatrix(scale, width, height, offsetX, offsetY) {\r\n        let p0 = (2 * Math.PI * scale) / (width * 180);\r\n        let p2 = ((2 * Math.PI * scale) / width) + ((2 * offsetX) / width) - 1;\r\n        let p4 = (2 * scale) / height;\r\n        let p5 = ((2 * offsetY / height) - 1);\r\n        return new Float32Array([\r\n            p0, 0, 0,\r\n            0, p4, 0,\r\n            p2, p5, 1\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Creates and compiles a shader.\r\n     * @static\r\n     * @param {string} type - Type of shader. Options are: VERTEX_SHADER or FRAGMENT_SHADER;\r\n     * @param {string} source_code - The shader source code.\r\n     * @param {WebGLRenderingContext} gl - Webgl object used by the Map class.\r\n     * @returns {WebGLShader} - The shader(vertex of fragment).\r\n     * @memberof WebGLUtils\r\n     */\r\n    static createAndCompileShader(type, source_code, gl) {\r\n        let shader = gl.createShader(type);\r\n        gl.shaderSource(shader, source_code);\r\n        gl.compileShader(shader);\r\n        console.log(gl.getShaderInfoLog(shader));\r\n        return shader;\r\n    }\r\n\r\n    /**\r\n     * Initializes:\r\n     * 1)WebGLProgram, 2) Generates shadders, 3) Attaches shaders to the program, 4) links program, 5) use program.\r\n     * @static\r\n     * @param {{gl: WebGLRenderingContext, program: WebGLProgram}} webgl - The webgl rendering context and program.\r\n     * @param {{vertexShaderCode:string, fragmentShaderCode:string}} shaderSourceCode - The dynamic shaders given by the programmer.\r\n     * @returns {WebGLProgram} - the program with the given shaders attached to it.\r\n     * @memberof WebGLUtils\r\n     */\r\n    static createWebGLProgram(gl, shaderSourceCode) {\r\n        let program = gl.createProgram();\r\n\r\n        const vertex_shader = this.createAndCompileShader(gl.VERTEX_SHADER, shaderSourceCode.vertexShaderCode, gl);\r\n        const fragment_shader = this.createAndCompileShader(gl.FRAGMENT_SHADER, shaderSourceCode.fragmentShaderCode, gl);\r\n\r\n        gl.attachShader(program, vertex_shader);\r\n        gl.attachShader(program, fragment_shader);\r\n\r\n        gl.linkProgram(program);\r\n        gl.useProgram(program);\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * Sets up webgl.\r\n     * @static\r\n     * @param {HTMLCanvasElement} canvas - The canvas element.\r\n     * @param {{width:number, height: number}} bgmapDivSizes - The width and height of the background maps div. \r\n     * @param {{vertexShaderCode:string, fragmentShaderCode:string}} shaderSourceCode - The code for the vertex and fragment shaders.\r\n     * @param {{vertexShaderCode:string, fragmentShaderCode:string}} bordersSourceCode - The code for the vertex and fragment shaders for the borders.\r\n     * @returns {{gl: WebGLRenderingContext, program: WebGLProgram, bordersProgram: WebGLProgram}} - The webgl rendering context and program. \r\n     * @memberof WebGLUtils\r\n     */\r\n    static setupWebGL(canvas, bgmapDivSizes, shaderSourceCode, bordersSourceCode) {\r\n        let webgl = {\r\n            gl: null,\r\n            program: null,\r\n            bordersProgram: null\r\n        };\r\n        webgl.gl = canvas.getContext(\"webgl2\");\r\n        webgl.gl.viewport(0, 0, bgmapDivSizes.width, bgmapDivSizes.height);\r\n        webgl.gl.disable(webgl.gl.DEPTH_TEST);\r\n        \r\n        webgl.program = this.createWebGLProgram(webgl.gl, shaderSourceCode);\r\n        webgl.bordersProgram = this.createWebGLProgram(webgl.gl, bordersSourceCode);\r\n\r\n        window.canvas = canvas;\r\n\r\n        return webgl;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Helpers/WebGLUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 219,
    "kind": "class",
    "name": "WebGLUtils",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js",
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Helpers/WebGLUtils.js",
    "importStyle": "{WebGLUtils}",
    "description": "Class with static methods that will help with WebGL related stuff(Matrices, web mercator projection and shaders).\nAlways remeber WebGL is column major when reading the matrix code.",
    "see": [
      "http://ptgmedia.pearsoncmg.com/images/chap3_9780321902924/elementLinks/03fig27.jpg"
    ],
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "WebGLUtils"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "webMercatorProjection",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.webMercatorProjection",
    "access": "public",
    "description": "Calculates the scale and offset(X and Y) for the Web Mercator projection.",
    "see": [
      "https://bl.ocks.org/enjalot/fb7f3d696167e9b83a72#viewport.js",
      "https://en.wikipedia.org/wiki/Web_Mercator"
    ],
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{scale: number, offsetX: number, offsetY: number}} - Returns the scale, offsetX and offsetY of the point given using the Web Mercator projection."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "longitudeCenter",
        "description": "Longitude of the given position."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "latitudeCenter",
        "description": "Latitude of the given position."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "zoom",
        "description": "Current zoom level of the background map."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "tileSize",
        "description": "The size of each tile in the background map. Usually is 256. If different should be given in the API options."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "Width of the current canvas."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "height",
        "description": "Height of the current canvas."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{scale: number, offsetX: number, offsetY: number}"
      ],
      "spread": false,
      "description": "Returns the scale, offsetX and offsetY of the point given using the Web Mercator projection."
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "finalMatrix",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.finalMatrix",
    "access": "public",
    "description": "This is the result matrix from the multiplication of M1*M2*M3",
    "see": [
      "Rui's thesis"
    ],
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Float32Array} The resulting matrix (M1*M2*M3) in a single matrix to send to WebGL in order to calculate the resulting position."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "scale",
        "description": "The scale calculated with WebMercator projection."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "The width of the canvas."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "height",
        "description": "The height of the canvas."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetX",
        "description": "The offsetX calculated with WebMercator projection."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetY",
        "description": "The offsetY calculated with WebMercator projection."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": "The resulting matrix (M1*M2*M3) in a single matrix to send to WebGL in order to calculate the resulting position."
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "createAndCompileShader",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.createAndCompileShader",
    "access": "public",
    "description": "Creates and compiles a shader.",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WebGLShader} - The shader(vertex of fragment)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Type of shader. Options are: VERTEX_SHADER or FRAGMENT_SHADER;"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source_code",
        "description": "The shader source code."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "gl",
        "description": "Webgl object used by the Map class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WebGLShader"
      ],
      "spread": false,
      "description": "The shader(vertex of fragment)."
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "createWebGLProgram",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.createWebGLProgram",
    "access": "public",
    "description": "Initializes:\n1)WebGLProgram, 2) Generates shadders, 3) Attaches shaders to the program, 4) links program, 5) use program.",
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WebGLProgram} - the program with the given shaders attached to it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{gl: WebGLRenderingContext, program: WebGLProgram}"
        ],
        "spread": false,
        "optional": false,
        "name": "webgl",
        "description": "The webgl rendering context and program."
      },
      {
        "nullable": null,
        "types": [
          "{vertexShaderCode:string, fragmentShaderCode:string}"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderSourceCode",
        "description": "The dynamic shaders given by the programmer."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WebGLProgram"
      ],
      "spread": false,
      "description": "the program with the given shaders attached to it."
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "setupWebGL",
    "memberof": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.setupWebGL",
    "access": "public",
    "description": "Sets up webgl.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{gl: WebGLRenderingContext, program: WebGLProgram, bordersProgram: WebGLProgram}} - The webgl rendering context and program. "
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "HTMLCanvasElement"
        ],
        "spread": false,
        "optional": false,
        "name": "canvas",
        "description": "The canvas element."
      },
      {
        "nullable": null,
        "types": [
          "{width:number, height: number}"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmapDivSizes",
        "description": "The width and height of the background maps div."
      },
      {
        "nullable": null,
        "types": [
          "{vertexShaderCode:string, fragmentShaderCode:string}"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderSourceCode",
        "description": "The code for the vertex and fragment shaders."
      },
      {
        "nullable": null,
        "types": [
          "{vertexShaderCode:string, fragmentShaderCode:string}"
        ],
        "spread": false,
        "optional": false,
        "name": "bordersSourceCode",
        "description": "The code for the vertex and fragment shaders for the borders."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{gl: WebGLRenderingContext, program: WebGLProgram, bordersProgram: WebGLProgram}"
      ],
      "spread": false,
      "description": "The webgl rendering context and program."
    }
  },
  {
    "__docId__": 225,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js",
    "content": "import { BGMapWrapper } from './BGMapWrapper';\r\n\r\n/**\r\n * Bing Maps as background map provider. \r\n * @see https://msdn.microsoft.com/en-us/library/mt712542.aspx\r\n * @export\r\n * @class BGMapBingMaps\r\n * @extends {BGMapWrapper}\r\n */\r\nexport class BGMapBingMaps extends BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of Bing Maps.\r\n     * @param {Object} bgmap - The Bing Maps object.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        super(bgmapDiv, mapBounds, viewPort);\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} mapId - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @returns {Object} - The bing maps object.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    createBackgroundMap(bgmapDiv, mapBounds) {\r\n        let center = { lat: (mapBounds.SW.lat + mapBounds.NE.lat) / 2, lng: (mapBounds.SW.lng + mapBounds.NE.lng) / 2 };\r\n        let map = new Microsoft.Maps.Map(bgmapDiv, {\r\n            credentials: 'tbS2WTHvuzFWMarVDedF~XGeRrWSh4JVHd1yPrfsUJQ~Al0cgZrtc-S57hQveO9iMLRlZesJBacsvRCzVNsSh5E_TzY8iPE8w_LvRjP2_51i',\r\n            center: new Microsoft.Maps.Location(center.lat, center.lng)\r\n        });\r\n\r\n        let locations = [new Microsoft.Maps.Location(mapBounds.SW.lat, mapBounds.SW.lng),\r\n        new Microsoft.Maps.Location(mapBounds.NE.lat, mapBounds.NE.lng)];\r\n        let bounds = Microsoft.Maps.LocationRect.fromLocations(locations);\r\n        map.setView({ bounds: bounds });\r\n\r\n        window.m = map;\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    getContainer() {\r\n        return this.bgMapObject.getRootElement();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    getZoom() {\r\n        return this.bgMapObject.getZoom();\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude(X) of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    getCenterLng() {\r\n        return this.bgMapObject.getCenter().longitude;\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude(Y) of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    getCenterLat() {\r\n        return this.bgMapObject.getCenter().latitude;\r\n    }\r\n\r\n    /**\r\n     * Add Pan/Drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @see https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS\r\n     * @see https://msdn.microsoft.com/en-us/library/mt736399.aspx\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    addDragEvent(func) {\r\n        Microsoft.Maps.Events.addHandler(this.getBackgroundMapProviderObject(), 'mousewheel', func);\r\n        // this.addEventListener('move', fun);\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @see https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS\r\n     * @see https://msdn.microsoft.com/en-us/library/mt736399.aspx\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    addZoomEvent(func) {\r\n        Microsoft.Maps.Events.addHandler(this.getBackgroundMapProviderObject(), 'viewchangeend', func);\r\n    }\r\n\r\n    /**\r\n     * Add click event.\r\n     * @param {GisplayMap} gisplayMap - The gisplay map object.\r\n     * @see https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS\r\n     * @see https://msdn.microsoft.com/en-us/library/mt736399.aspx\r\n     * @memberof BGMapBingMaps\r\n     */\r\n    addClickEvent(gisplayMap) {\r\n        Microsoft.Maps.Events.addHandler(this.getBackgroundMapProviderObject(), 'click', (e) => {\r\n            let rect = this.bgmapDiv.getClientRects();\r\n            let c1 = { x: rect[0].left, y: rect[0].top };\r\n            let p1 = { x: e.pageX, y: e.pageY };\r\n            let point = { x: p1.x - c1.x, y: p1.y - c1.y };\r\n            gisplayMap.clickEvent(point.x, point.y, this);\r\n        });\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapBingMaps.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 226,
    "kind": "class",
    "name": "BGMapBingMaps",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapBingMaps.js",
    "importStyle": "{BGMapBingMaps}",
    "description": "Bing Maps as background map provider. ",
    "see": [
      "https://msdn.microsoft.com/en-us/library/mt712542.aspx"
    ],
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BGMapBingMaps"
      }
    ],
    "interface": false,
    "extends": [
      "BGMapWrapper"
    ]
  },
  {
    "__docId__": 227,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#constructor",
    "access": "public",
    "description": "Creates an instance of Bing Maps.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The Bing Maps object."
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The bing maps object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mapId",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The bing maps object."
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 59,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#getCenterLng",
    "access": "public",
    "description": "Returns the longitude(X) of the bounding box northwest corner.",
    "lineNumber": 68,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#getCenterLat",
    "access": "public",
    "description": "Returns the latitude(Y) of the bounding box northwest corner.",
    "lineNumber": 77,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#addDragEvent",
    "access": "public",
    "description": "Add Pan/Drag event.",
    "see": [
      "https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS",
      "https://msdn.microsoft.com/en-us/library/mt736399.aspx"
    ],
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "see": [
      "https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS",
      "https://msdn.microsoft.com/en-us/library/mt736399.aspx"
    ],
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps#addClickEvent",
    "access": "public",
    "description": "Add click event.",
    "see": [
      "https://www.bing.com/api/maps/sdkrelease/mapcontrol/isdk#layerEvents+JS",
      "https://msdn.microsoft.com/en-us/library/mt736399.aspx"
    ],
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The gisplay map object."
      }
    ]
  },
  {
    "__docId__": 236,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js",
    "content": "import { BGMapWrapper } from './BGMapWrapper';\r\n\r\n/**\r\n * Google Maps as background map provider. \r\n * @see https://developers.google.com/maps/documentation/javascript/3.exp/reference\r\n * @export\r\n * @class GoogleMapsBGMap\r\n * @extends {BGMapWrapper}\r\n */\r\nexport class BGMapGoogleMaps extends BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapsBGMap.\r\n     * @param {Object} bgmap - The Google Maps object.\r\n     * @memberOf GoogleMapsBGMap\r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        super(bgmapDiv, mapBounds, viewPort);\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} mapId - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @returns {Object} - The google maps object.\r\n     * @see https://developers.google.com/maps/documentation/javascript/examples/control-disableUI\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    createBackgroundMap(bgmapDiv, mapBounds) {\r\n        let map = new google.maps.Map(bgmapDiv, { disableDefaultUI: true });\r\n\r\n        let sw = new google.maps.LatLng(mapBounds.SW.lat, mapBounds.SW.lng),\r\n            ne = new google.maps.LatLng(mapBounds.NE.lat, mapBounds.NE.lng),\r\n            center = new google.maps.LatLng((mapBounds.SW.lat + mapBounds.NE.lat) / 2, (mapBounds.SW.lng + mapBounds.NE.lng) / 2);\r\n\r\n        let maxBounds = new google.maps.LatLngBounds();\r\n        maxBounds.extend(sw);\r\n        maxBounds.extend(ne);\r\n        map.setCenter(center);\r\n        map.fitBounds(maxBounds);\r\n\r\n        // In case we go out of the maxBounds this will reset the initial center.\r\n        /* map.addListener('bounds_changed', () => {\r\n            if (maxBounds.contains(map.getCenter()))\r\n                return;\r\n            else\r\n                map.setCenter(center);\r\n        }); */\r\n\r\n        window.m = map;\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    getContainer() {\r\n        return this.bgMapObject.getDiv();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    getZoom() {\r\n        return this.bgMapObject.getZoom();\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude(X) of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @see http://stackoverflow.com/a/6913505\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    getCenterLng() {\r\n        return ((((180 + this.bgMapObject.getCenter().lng()) % 360) + 360) % 360) - 180;\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude(Y) of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @see http://stackoverflow.com/a/6913505\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    getCenterLat() {\r\n        return this.bgMapObject.getCenter().lat();\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to a specified event type.\r\n     * @param {string} eventstr - The event type to add a listen for.\r\n     * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    addEventListener(eventstr, eventfunction) {\r\n        this.bgMapObject.addListener(eventstr, eventfunction);\r\n    }\r\n\r\n    /**\r\n     * Add Pan/Drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @see https://developers.google.com/maps/documentation/javascript/events\r\n     * @see https://developers.google.com/maps/documentation/javascript/reference#Marker \r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    addDragEvent(func) {\r\n        this.addEventListener('drag', func);\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @see https://developers.google.com/maps/documentation/javascript/events\r\n     * @see https://developers.google.com/maps/documentation/javascript/reference#Marker \r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    addZoomEvent(func) {\r\n        // this.addEventListener('zoom_changed', fun);\r\n        this.addEventListener('idle', func); //This event is fired when the map becomes idle after panning or zooming.\r\n    }\r\n\r\n    /**\r\n     * Add click event.\r\n     * @param {GisplayMap} gisplayMap - The gisplay map object.\r\n     * @see https://developers.google.com/maps/documentation/javascript/events\r\n     * @see https://developers.google.com/maps/documentation/javascript/reference#Marker \r\n     * @memberof BGMapGoogleMaps\r\n     */\r\n    addClickEvent(gisplayMap) {\r\n        this.addEventListener('click', e => {\r\n            gisplayMap.clickEvent(e.pixel.x, e.pixel.y, this);\r\n        });\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 237,
    "kind": "class",
    "name": "BGMapGoogleMaps",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js",
    "importStyle": "{BGMapGoogleMaps}",
    "description": "Google Maps as background map provider. ",
    "see": [
      "https://developers.google.com/maps/documentation/javascript/3.exp/reference"
    ],
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GoogleMapsBGMap"
      }
    ],
    "interface": false,
    "extends": [
      "BGMapWrapper"
    ]
  },
  {
    "__docId__": 238,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#constructor",
    "access": "public",
    "description": "Creates an instance of GoogleMapsBGMap.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "GoogleMapsBGMap"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The Google Maps object."
      }
    ]
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "see": [
      "https://developers.google.com/maps/documentation/javascript/examples/control-disableUI"
    ],
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The google maps object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mapId",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The google maps object."
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 60,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#getCenterLng",
    "access": "public",
    "description": "Returns the longitude(X) of the bounding box northwest corner.",
    "see": [
      "http://stackoverflow.com/a/6913505"
    ],
    "lineNumber": 79,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#getCenterLat",
    "access": "public",
    "description": "Returns the latitude(Y) of the bounding box northwest corner.",
    "see": [
      "http://stackoverflow.com/a/6913505"
    ],
    "lineNumber": 89,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#addEventListener",
    "access": "public",
    "description": "Adds a listener to a specified event type.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventstr",
        "description": "The event type to add a listen for."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "eventfunction",
        "description": "The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties."
      }
    ]
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#addDragEvent",
    "access": "public",
    "description": "Add Pan/Drag event.",
    "see": [
      "https://developers.google.com/maps/documentation/javascript/events",
      "https://developers.google.com/maps/documentation/javascript/reference#Marker "
    ],
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "see": [
      "https://developers.google.com/maps/documentation/javascript/events",
      "https://developers.google.com/maps/documentation/javascript/reference#Marker "
    ],
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps#addClickEvent",
    "access": "public",
    "description": "Add click event.",
    "see": [
      "https://developers.google.com/maps/documentation/javascript/events",
      "https://developers.google.com/maps/documentation/javascript/reference#Marker "
    ],
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The gisplay map object."
      }
    ]
  },
  {
    "__docId__": 248,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js",
    "content": "import { BGMapWrapper } from './BGMapWrapper';\r\n\r\n/**\r\n * Here Maps as background map provider. \r\n * @see https://developer.here.com/develop/javascript-api\r\n * @see https://developer.here.com/javascript-apis/documentation/v3/maps/topics/quick-start.html\r\n * @export\r\n * @class HereMapsBGMap\r\n * @extends {BGMapWrapper}\r\n */\r\nexport class BGMapHereMaps extends BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of Here Maps.\r\n     * @param {Object} bgmap - The Here Maps object.\r\n     * @memberOf HereMapsBGMap\r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        super(bgmapDiv, mapBounds, viewPort);\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} mapId - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @returns {Object} - The google maps object.\r\n     * @see https://developer.here.com/api-explorer/maps-js/v3.0/maps/map-using-view-bounds\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    createBackgroundMap(bgmapDiv, mapBounds) {\r\n        let platform = new H.service.Platform({\r\n            'app_id': 'L8PMOO22XlBlfofBNLTH',\r\n            'app_code': '_L7WMKrjcArpjlJenPuuzg'\r\n        });\r\n        let defaultLayers = platform.createDefaultLayers();\r\n        let map = new H.Map(\r\n            bgmapDiv,\r\n            defaultLayers.normal.map,\r\n            {\r\n                center: { lat: (mapBounds.SW.lat + mapBounds.NE.lat) / 2, lng: (mapBounds.SW.lng + mapBounds.NE.lng) / 2 }\r\n            }\r\n        );\r\n        map.setZoom(5);\r\n\r\n        let mapEvents = new H.mapevents.MapEvents(map);//Enable events\r\n        let behavior = new H.mapevents.Behavior(mapEvents);//Enable zoom and pan\r\n\r\n        let nw = [mapBounds.NE.lat, mapBounds.SW.lng],\r\n            se = [mapBounds.SW.lat, mapBounds.NE.lng];\r\n\r\n        let bbox = new H.geo.Rect(...nw, ...se);//42.3736, -71.0751, 42.3472, -71.0408);\r\n        // map.setViewBounds(bbox);\r\n\r\n        //Restrict pan outside bounds\r\n   /*      map.getViewModel().addEventListener('sync', () => {\r\n            let center = map.getCenter();\r\n            // console.warn(this.bgmapDiv.id, center);\r\n            if (!bbox.containsPoint(center)) {\r\n                if (center.lat > bbox.getTop()) {\r\n                    center.lat = bbox.getTop();\r\n                } else if (center.lat < bbox.getBottom()) {\r\n                    center.lat = bbox.getBottom();\r\n                }\r\n                if (center.lng < bbox.getLeft()) {\r\n                    center.lng = bbox.getLeft();\r\n                } else if (center.lng > bbox.getRight()) {\r\n                    center.lng = bbox.getRight();\r\n                }\r\n                // console.warn(\"2\", this.bgmapDiv.id, center);\r\n                map.setCenter(center);\r\n            }\r\n        }); */\r\n\r\n        window.m = map;\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Resize the background map object, when a window resize event occurs.\r\n     * @see https://stackoverflow.com/a/26295344\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    resize() {\r\n        this.bgMapObject.getViewPort().resize();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    getContainer() {\r\n        return this.bgMapObject.getElement();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    getZoom() {\r\n        return this.bgMapObject.getZoom();\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude(X) of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @see https://developer.here.com/api-explorer/maps-js/v3.0/infoBubbles/position-on-mouse-click\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    getCenterLng() {\r\n        return ((((180 + this.bgMapObject.getCenter().lng) % 360) + 360) % 360) - 180;\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude(Y) of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @see https://developer.here.com/api-explorer/maps-js/v3.0/infoBubbles/position-on-mouse-click\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    getCenterLat() {\r\n        return this.bgMapObject.getCenter().lat;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to a specified event type.\r\n     * @param {string} eventstr - The event type to add a listen for.\r\n     * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    addEventListener(eventstr, eventfunction) {\r\n        this.bgMapObject.addEventListener(eventstr, eventfunction);\r\n    }\r\n\r\n    /**\r\n     * Add Pan/Drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @see https://developer.here.com/documentation/maps/topics/events.html\r\n     * @see https://developer.here.com/documentation/maps/topics_api/h-mapevents-mapevents.html#h-mapevents-mapevents__drag-event\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    addDragEvent(func) {\r\n        this.addEventListener('drag', func);\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @see https://developer.here.com/documentation/maps/topics/events.html\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    addZoomEvent(func) {\r\n        this.addEventListener('mapviewchangeend', func);\r\n    }\r\n\r\n    /**\r\n     * Add click event.\r\n     * @param {GisplayMap} gisplayMap - The gisplay map object.\r\n     * @see https://developer.here.com/documentation/maps/topics/events.html\r\n     * @see https://developer.here.com/documentation/maps/topics_api/h-mapevents-mapevents.html#h-mapevents-mapevents__tap-event\r\n     * @memberof BGMapHereMaps\r\n     */\r\n    addClickEvent(gisplayMap) {\r\n        this.addEventListener('tap', e => {\r\n            let rect = this.bgmapDiv.getClientRects();\r\n            let c1 = { x: rect[0].left, y: rect[0].top };\r\n            let p1 = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };\r\n            let point = { x: p1.x - c1.x, y: p1.y - c1.y };\r\n            gisplayMap.clickEvent(point.x, point.y, this);\r\n        });\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapHereMaps.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 249,
    "kind": "class",
    "name": "BGMapHereMaps",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapHereMaps.js",
    "importStyle": "{BGMapHereMaps}",
    "description": "Here Maps as background map provider. ",
    "see": [
      "https://developer.here.com/develop/javascript-api",
      "https://developer.here.com/javascript-apis/documentation/v3/maps/topics/quick-start.html"
    ],
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "HereMapsBGMap"
      }
    ],
    "interface": false,
    "extends": [
      "BGMapWrapper"
    ]
  },
  {
    "__docId__": 250,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#constructor",
    "access": "public",
    "description": "Creates an instance of Here Maps.",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "HereMapsBGMap"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The Here Maps object."
      }
    ]
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "see": [
      "https://developer.here.com/api-explorer/maps-js/v3.0/maps/map-using-view-bounds"
    ],
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The google maps object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mapId",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The google maps object."
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "resize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#resize",
    "access": "public",
    "description": "\nResize the background map object, when a window resize event occurs.",
    "see": [
      "https://stackoverflow.com/a/26295344"
    ],
    "lineNumber": 85
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 94,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 103,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#getCenterLng",
    "access": "public",
    "description": "Returns the longitude(X) of the bounding box northwest corner.",
    "see": [
      "https://developer.here.com/api-explorer/maps-js/v3.0/infoBubbles/position-on-mouse-click"
    ],
    "lineNumber": 113,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#getCenterLat",
    "access": "public",
    "description": "Returns the latitude(Y) of the bounding box northwest corner.",
    "see": [
      "https://developer.here.com/api-explorer/maps-js/v3.0/infoBubbles/position-on-mouse-click"
    ],
    "lineNumber": 123,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#addEventListener",
    "access": "public",
    "description": "Adds a listener to a specified event type.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventstr",
        "description": "The event type to add a listen for."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "eventfunction",
        "description": "The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties."
      }
    ]
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#addDragEvent",
    "access": "public",
    "description": "Add Pan/Drag event.",
    "see": [
      "https://developer.here.com/documentation/maps/topics/events.html",
      "https://developer.here.com/documentation/maps/topics_api/h-mapevents-mapevents.html#h-mapevents-mapevents__drag-event"
    ],
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "see": [
      "https://developer.here.com/documentation/maps/topics/events.html"
    ],
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps#addClickEvent",
    "access": "public",
    "description": "Add click event.",
    "see": [
      "https://developer.here.com/documentation/maps/topics/events.html",
      "https://developer.here.com/documentation/maps/topics_api/h-mapevents-mapevents.html#h-mapevents-mapevents__tap-event"
    ],
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The gisplay map object."
      }
    ]
  },
  {
    "__docId__": 261,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js",
    "content": "import { BGMapWrapper } from './BGMapWrapper';\r\n\r\n/**\r\n * MapBox JS as background map provider.\r\n * @see https://www.mapbox.com/mapbox.js/api/v3.1.1/\r\n * @export\r\n * @class BGMapMapBox\r\n * @extends {BGMapWrapper}\r\n */\r\nexport class BGMapMapBox extends BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of BGMapWrapper.\r\n     * @param {Object} bgmap - The background map object that came from the provider (e.g., Mapbox, Google Maps). \r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        super(bgmapDiv, mapBounds, viewPort);\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} bgmapDiv - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @returns {Object} - The google maps object.\r\n     * @memberof BGMapMapBox\r\n     */\r\n    createBackgroundMap(bgmapDiv, mapBounds) {\r\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\r\n\r\n        let southWest = L.latLng(mapBounds.SW.lat, mapBounds.SW.lng),\r\n            northEast = L.latLng(mapBounds.NE.lat, mapBounds.NE.lng),\r\n            mapbounds = L.latLngBounds(southWest, northEast);\r\n\r\n        let map = L.mapbox.map(bgmapDiv.id, 'mapbox.streets', {\r\n            // set that bounding box as maxBounds to restrict moving the map\r\n            // see full maxBounds documentation:\r\n            // http://leafletjs.com/reference.html#map-maxbounds\r\n            maxBounds: mapbounds,\r\n            zoom: 10,\r\n            attributionControl: true\r\n        });\r\n\r\n        // zoom the map to that bounding box\r\n        map.fitBounds(mapbounds);\r\n\r\n        window.m = map;\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Resize the background map object, when a window resize event occurs.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    resize() {\r\n        this.bgMapObject.invalidateSize();\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapMapBox\r\n     */\r\n    getContainer() {\r\n        return this.bgMapObject.getContainer();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapMapBox\r\n     */\r\n    getZoom() {\r\n        return this.bgMapObject.getZoom();\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapMapBox\r\n     */\r\n    getCenterLng() {\r\n        return ((((180 + this.bgMapObject.getCenter().lng) % 360) + 360) % 360) - 180;\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapMapBox\r\n     */\r\n    getCenterLat() {\r\n        return this.bgMapObject.getCenter().lat;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to a specified event type.\r\n     * @param {string} eventstr - The event type to add a listen for.\r\n     * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n     * @return {void} \r\n     * @memberof BGMapMapBox\r\n     */\r\n    addEventListener(eventstr, eventfunction) {\r\n        this.bgMapObject.on(eventstr, eventfunction);\r\n    }\r\n\r\n    /**\r\n     * Add Pan/Drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @see http://leafletjs.com/reference-1.2.0.html#map-move\r\n     * @memberof BGMapMapBox\r\n     */\r\n    addDragEvent(func) {\r\n        this.addEventListener('move', func);\r\n        /* this.addEventListener('movestart', func);\r\n        this.addEventListener('moveend', func); */\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @see http://leafletjs.com/reference-1.2.0.html#map-zoomend\r\n     * @memberof BGMapMapBox\r\n     */\r\n    addZoomEvent(func) {\r\n        this.addEventListener('zoomend', func);\r\n    }\r\n\r\n    /**\r\n     * Add click event.\r\n     * @param {GisplayMap} gisplayMap - The gisplay map object.\r\n     * @see https://jsfiddle.net/5pp9pqf2/\r\n     * @see http://leafletjs.com/reference-1.2.0.html#map-click\r\n     * @memberof BGMapMapBox\r\n     */\r\n    addClickEvent(gisplayMap) {\r\n        this.addEventListener('click', e => {\r\n            //https://jsfiddle.net/5pp9pqf2/\r\n            let rect = this.bgmapDiv.getClientRects();\r\n            let c1 = { x: rect[0].left, y: rect[0].top };\r\n            let p1 = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };\r\n            let point = { x: p1.x - c1.x, y: p1.y - c1.y };\r\n            gisplayMap.clickEvent(point.x, point.y, this);\r\n        });\r\n    }\r\n}\r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapMapBox.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 262,
    "kind": "class",
    "name": "BGMapMapBox",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapMapBox.js",
    "importStyle": "{BGMapMapBox}",
    "description": "MapBox JS as background map provider.",
    "see": [
      "https://www.mapbox.com/mapbox.js/api/v3.1.1/"
    ],
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BGMapMapBox"
      }
    ],
    "interface": false,
    "extends": [
      "BGMapWrapper"
    ]
  },
  {
    "__docId__": 263,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#constructor",
    "access": "public",
    "description": "Creates an instance of BGMapWrapper.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map object that came from the provider (e.g., Mapbox, Google Maps)."
      }
    ]
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The google maps object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmapDiv",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The google maps object."
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "resize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#resize",
    "access": "public",
    "description": "Resize the background map object, when a window resize event occurs.",
    "lineNumber": 55
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 65,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#getCenterLng",
    "access": "public",
    "description": "Returns the longitude of the bounding box northwest corner.",
    "lineNumber": 83,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#getCenterLat",
    "access": "public",
    "description": "Returns the latitude of the bounding box northwest corner.",
    "lineNumber": 92,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#addEventListener",
    "access": "public",
    "description": "Adds a listener to a specified event type.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventstr",
        "description": "The event type to add a listen for."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "eventfunction",
        "description": "The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#addDragEvent",
    "access": "public",
    "description": "Add Pan/Drag event.",
    "see": [
      "http://leafletjs.com/reference-1.2.0.html#map-move"
    ],
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "see": [
      "http://leafletjs.com/reference-1.2.0.html#map-zoomend"
    ],
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox#addClickEvent",
    "access": "public",
    "description": "Add click event.",
    "see": [
      "https://jsfiddle.net/5pp9pqf2/",
      "http://leafletjs.com/reference-1.2.0.html#map-click"
    ],
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The gisplay map object."
      }
    ]
  },
  {
    "__docId__": 274,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js",
    "content": "import { BGMapWrapper } from './BGMapWrapper';\r\n\r\n/**\r\n * MapBox GL JS as background map provider.\r\n * @see https://www.mapbox.com/mapbox-gl-js/api/\r\n * @export\r\n * @class BGMapMapBoxGLJS\r\n * @extends {BGMapWrapper}\r\n */\r\nexport class BGMapMapBoxGLJS extends BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of BGMapMapBoxGLJS.\r\n     * @param {HTMLDivElement} bgmapDiv \r\n     * @param {any} mapBounds \r\n     * @param {any} viewPort \r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        super(bgmapDiv, mapBounds, viewPort);\r\n        /**\r\n         * The tile size for this specific background map.\r\n         * @type {number}\r\n         */\r\n        this.tileSize = 512;\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} bgmapDiv - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @returns {Object} - The google maps object.\r\n     * @see https://www.mapbox.com/mapbox-gl-js/example/fitbounds/\r\n     * @see https://www.mapbox.com/mapbox-gl-js/example/restrict-bounds/\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    createBackgroundMap(bgmapDiv, mapBounds) {\r\n        mapboxgl.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\r\n\r\n        let mapbounds = [\r\n            [mapBounds.SW.lng, mapBounds.SW.lat], // Southwest coordinates\r\n            [mapBounds.NE.lng, mapBounds.NE.lat]  // Northeast coordinates\r\n        ];\r\n\r\n        let center = [(mapBounds.SW.lng + mapBounds.NE.lng) / 2,\r\n        (mapBounds.SW.lat + mapBounds.NE.lat) / 2];\r\n\r\n        let map = new mapboxgl.Map({\r\n            container: bgmapDiv.id,\r\n            zoom: 6,\r\n            style: 'mapbox://styles/mapbox/dark-v9',\r\n            // maxBounds: mapbounds,\r\n            fitBounds: mapBounds,\r\n            center: center\r\n        });\r\n\r\n        // this.resize(map);\r\n\r\n        window.m = map;\r\n\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Resize the background map object, when a window resize event occurs.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    resize() {\r\n        this.bgMapObject.resize();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    getContainer() {\r\n        return this.bgMapObject.getContainer();\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    getZoom() {\r\n        return this.bgMapObject.getZoom();\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    getCenterLng() {\r\n        return ((((180 + this.bgMapObject.getCenter().lng) % 360) + 360) % 360) - 180;\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    getCenterLat() {\r\n        return this.bgMapObject.getCenter().lat;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to a specified event type.\r\n     * @param {string} eventstr - The event type to add a listen for.\r\n     * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n     * @return {void} \r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    addEventListener(eventstr, eventfunction) {\r\n        this.bgMapObject.on(eventstr, eventfunction);\r\n    }\r\n\r\n    /**\r\n     * Add Pan/Drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @see https://www.mapbox.com/mapbox-gl-js/api/#map.event:drag\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    addDragEvent(func) {\r\n        this.addEventListener('drag', func);\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @see https://www.mapbox.com/mapbox-gl-js/api/#map.event:zoomend\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    addZoomEvent(func) {\r\n        this.addEventListener('zoomend', func);\r\n    }\r\n\r\n    /**\r\n     * Add click event.\r\n     * @param {GisplayMap} gisplayMap - The gisplay map object.\r\n     * @see https://jsfiddle.net/5pp9pqf2/\r\n     * @see https://www.mapbox.com/mapbox-gl-js/api/#map.event:click\r\n     * @memberof BGMapMapBoxGLJS\r\n     */\r\n    addClickEvent(gisplayMap) {\r\n        this.addEventListener('click', e => {\r\n            //https://jsfiddle.net/5pp9pqf2/\r\n            let rect = this.bgmapDiv.getClientRects();\r\n            let c1 = { x: rect[0].left, y: rect[0].top };\r\n            let p1 = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };\r\n            let point = { x: p1.x - c1.x, y: p1.y - c1.y };\r\n            gisplayMap.clickEvent(point.x, point.y, this);\r\n        });\r\n    }\r\n}\r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 275,
    "kind": "class",
    "name": "BGMapMapBoxGLJS",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js",
    "importStyle": "{BGMapMapBoxGLJS}",
    "description": "MapBox GL JS as background map provider.",
    "see": [
      "https://www.mapbox.com/mapbox-gl-js/api/"
    ],
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BGMapMapBoxGLJS"
      }
    ],
    "interface": false,
    "extends": [
      "BGMapWrapper"
    ]
  },
  {
    "__docId__": 276,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#constructor",
    "access": "public",
    "description": "Creates an instance of BGMapMapBoxGLJS.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "HTMLDivElement"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmapDiv",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "viewPort",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 277,
    "kind": "member",
    "name": "tileSize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#tileSize",
    "access": "public",
    "description": "The tile size for this specific background map.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "see": [
      "https://www.mapbox.com/mapbox-gl-js/example/fitbounds/",
      "https://www.mapbox.com/mapbox-gl-js/example/restrict-bounds/"
    ],
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} - The google maps object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmapDiv",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The google maps object."
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "resize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#resize",
    "access": "public",
    "description": "Resize the background map object, when a window resize event occurs.",
    "lineNumber": 68
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 77,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#getCenterLng",
    "access": "public",
    "description": "Returns the longitude of the bounding box northwest corner.",
    "lineNumber": 95,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#getCenterLat",
    "access": "public",
    "description": "Returns the latitude of the bounding box northwest corner.",
    "lineNumber": 104,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#addEventListener",
    "access": "public",
    "description": "Adds a listener to a specified event type.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventstr",
        "description": "The event type to add a listen for."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "eventfunction",
        "description": "The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#addDragEvent",
    "access": "public",
    "description": "Add Pan/Drag event.",
    "see": [
      "https://www.mapbox.com/mapbox-gl-js/api/#map.event:drag"
    ],
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "see": [
      "https://www.mapbox.com/mapbox-gl-js/api/#map.event:zoomend"
    ],
    "lineNumber": 135,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS#addClickEvent",
    "access": "public",
    "description": "Add click event.",
    "see": [
      "https://jsfiddle.net/5pp9pqf2/",
      "https://www.mapbox.com/mapbox-gl-js/api/#map.event:click"
    ],
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The gisplay map object."
      }
    ]
  },
  {
    "__docId__": 288,
    "kind": "file",
    "name": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js",
    "content": "/**\r\n * This class represents a background map wrapper. Used to be a \"middle-man\" between the \r\n * background map provider and the Gisplay API.\r\n * @see https://www.mapbox.com/mapbox-gl-js/api/ \r\n * @see https://developers.google.com/maps/documentation/javascript/3.exp/reference\r\n * @see https://developer.here.com/develop/javascript-api \r\n * @see Diogo's thesis Page 70-72 + 59\r\n */\r\nexport class BGMapWrapper {\r\n\r\n    /**\r\n     * Creates an instance of BGMapWrapper.\r\n     * @param {Object} bgmap - The background map object that came from the provider (e.g., Mapbox, Google Maps). \r\n     */\r\n    constructor(bgmapDiv, mapBounds, viewPort) {\r\n        /**\r\n         * This is the background map object that comes from the background map provider(e.g., MapBox). \r\n         * @type {Object}\r\n         */\r\n        this.bgMapObject = this.createBackgroundMap(bgmapDiv, mapBounds);\r\n        /**\r\n         * The div element that contains this map.\r\n         * @type {HTMLDivElement}\r\n         */\r\n        this.bgmapDiv = bgmapDiv;\r\n        /**\r\n         * The bounds (SW and NE points) of this background map.\r\n         * @type {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}}\r\n         */\r\n        this.mapBounds = mapBounds;\r\n        /**\r\n         * Position of this map on the Canvas. Positions are (left, bottom, width, height).\r\n         * @type {{left:number, bottom:number, width: number, height: number}}\r\n         */\r\n        this.viewPort = viewPort;\r\n        /**\r\n         * The description to add to the background map bottom corner. Used to identify the area being presented.\r\n         * @type {string}\r\n         */\r\n        this.description = \"Mainland USA\";\r\n        /**\r\n         * The size of each background map tile. All existing maps use 256x256, any new background map that has a different tile size must override this variable.\r\n         * @type {number}\r\n         */\r\n        this.tileSize = 256;\r\n    }\r\n\r\n    /**\r\n     * Resize the background map object, when a window resize event occurs.\r\n     * @abstract \r\n     * @memberof BGMapWrapper\r\n     */\r\n    resize() {\r\n    }\r\n\r\n    /**\r\n     * Method that creates the background map and sets the maximum allowed bounds.\r\n     * @param {string} mapId - The div where the map will be contained.\r\n     * @param {{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}} mapBounds - The max bounds allowed for this map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    createBackgroundMap(mapId, mapBounds) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    //DELETE THIS\r\n    /**\r\n     * Returns the map's containing HTML element.\r\n     * @return {HTMLElement} - The map's HTML element container.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getContainer() {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the canvas elment.\r\n     * @returns {number} the width of the canvas elment.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getWidth() {\r\n        return this.getContainer().offsetWidth;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the canvas element.\r\n     * @returns {number} the height of the canvas elment.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getHeight() {\r\n        return this.getContainer().offsetHeight;\r\n    }\r\n\r\n    /**\r\n     * Returns the bounds for this background map.\r\n     * @returns { number } - the bounds for this background map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getMapBounds() {\r\n        return this.mapBounds;\r\n    }\r\n\r\n    /**\r\n     * Returns the viewport values for this background map.\r\n     * @returns {Array<number>} -  the viewport values for this background map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getViewPort() {\r\n        return this.viewPort;\r\n    }\r\n\r\n    /**\r\n     * Calculates the viewport.\r\n     * @returns {Array<number>} -  the viewport values for this background map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    calculateViewPort(canvas) {\r\n        let canvasWidth = canvas.offsetWidth,\r\n            canvasHeight = canvas.offsetHeight;\r\n        return [canvasWidth * this.viewPort.left, canvasHeight * this.viewPort.bottom, canvasWidth * this.viewPort.width, canvasHeight * this.viewPort.height];\r\n    }\r\n\r\n    /**\r\n     * Calculates the power of two value equal or higher than the background map div width and height.\r\n     * @param {any} canvas \r\n     * @returns \r\n     * @memberof BGMapWrapper\r\n     */\r\n    calcNextPowerOfTwo() {\r\n        let bgmapWidth = this.bgmapDiv.offsetWidth,\r\n            bgmapHeight = this.bgmapDiv.offsetHeight;\r\n        return [this._calcNextPowerOfTwoHelper(bgmapWidth), this._calcNextPowerOfTwoHelper(bgmapHeight)];\r\n    }\r\n\r\n    /**\r\n     * Method that calculates the next power of two equal or higher than the given value.\r\n     * @param {number} value - The width/height of the viewport. \r\n     * @returns {number} - The next power of two after the given value.\r\n     * @private \r\n     * @memberof BGMapWrapper\r\n     */\r\n    _calcNextPowerOfTwoHelper(value) {\r\n        let powerOfTwoVals = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072]; //2^1 to 2^17\r\n        // for (let i = 0; i < powerOfTwoVals.length; i++)\r\n        for (let powerVal of powerOfTwoVals)\r\n            if (powerVal >= value)\r\n                return powerVal;\r\n    }\r\n\r\n    /**\r\n     * Returns the map's current zoom level.\r\n     * @return {number} - The map's current zoom level.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getZoom() {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the longitude of the bounding box northwest corner.\r\n     * @return {number} - Longitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getCenterLng() {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the latitude of the bounding box northwest corner.\r\n     * @return {number} - Latitude of northwest corner, measured in degrees.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getCenterLat() {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to a specified event type.\r\n     * @param {string} eventstr - The event type to add a listen for.\r\n     * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    addEventListener(eventstr, eventfunction) {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Add drag event.\r\n     * @param {Function} func - The function to be called when the user performs drag on the map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    addDragEvent(func) {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Add zoom event.\r\n     * @param {Function} func - The function to be called when the user performs zoom in/out on the map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    addZoomEvent(func) {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Add click event. Calculate the position of the click event relative to the containing div (bgmapDiv).\r\n     * With the calculated x,y then call GisplayMap to proceed the hit testing.\r\n     * @param {Map} map - The function to be called when the user clicks on the map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    addClickEvent(map) {\r\n        throw new Error(\"Not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the background map object. This is the Background provider object (e.g., Mapbox, GMaps, HereMaps, Bing Maps).\r\n     * @returns {BGMapWrapper#bgMapObject} the background map object.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getBackgroundMapProviderObject() {\r\n        return this.bgMapObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the tile size used to calculate the projection matrix for WebGL.\r\n     * @returns {number} - the tile size used to calculate the projection matrix for WebGL.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getTileSize() {\r\n        return this.tileSize;\r\n    }\r\n\r\n    /**\r\n     * Returns the div of this background map.\r\n     * @returns {HTMLDivElement} - the div of this background map.\r\n     * @memberof BGMapWrapper\r\n     */\r\n    getDiv() {\r\n        return this.bgmapDiv;\r\n    }\r\n}\r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Background Maps/BGMapWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 289,
    "kind": "class",
    "name": "BGMapWrapper",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Background Maps/BGMapWrapper.js",
    "importStyle": "{BGMapWrapper}",
    "description": "This class represents a background map wrapper. Used to be a \"middle-man\" between the \nbackground map provider and the Gisplay API.",
    "see": [
      "https://www.mapbox.com/mapbox-gl-js/api/ ",
      "https://developers.google.com/maps/documentation/javascript/3.exp/reference",
      "https://developer.here.com/develop/javascript-api ",
      "Diogo's thesis Page 70-72 + 59"
    ],
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 290,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#constructor",
    "access": "public",
    "description": "Creates an instance of BGMapWrapper.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map object that came from the provider (e.g., Mapbox, Google Maps)."
      }
    ]
  },
  {
    "__docId__": 291,
    "kind": "member",
    "name": "bgMapObject",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#bgMapObject",
    "access": "public",
    "description": "This is the background map object that comes from the background map provider(e.g., MapBox). ",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 292,
    "kind": "member",
    "name": "bgmapDiv",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#bgmapDiv",
    "access": "public",
    "description": "The div element that contains this map.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "HTMLDivElement"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 293,
    "kind": "member",
    "name": "mapBounds",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#mapBounds",
    "access": "public",
    "description": "The bounds (SW and NE points) of this background map.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 294,
    "kind": "member",
    "name": "viewPort",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#viewPort",
    "access": "public",
    "description": "Position of this map on the Canvas. Positions are (left, bottom, width, height).",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "{left:number, bottom:number, width: number, height: number}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "description",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#description",
    "access": "public",
    "description": "The description to add to the background map bottom corner. Used to identify the area being presented.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "tileSize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#tileSize",
    "access": "public",
    "description": "The size of each background map tile. All existing maps use 256x256, any new background map that has a different tile size must override this variable.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "resize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#resize",
    "access": "public",
    "description": "Resize the background map object, when a window resize event occurs.",
    "lineNumber": 53,
    "abstract": true
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "createBackgroundMap",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#createBackgroundMap",
    "access": "public",
    "description": "Method that creates the background map and sets the maximum allowed bounds.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mapId",
        "description": "The div where the map will be contained."
      },
      {
        "nullable": null,
        "types": [
          "{SW: {lat:number, lng:number}, NE: {lng:number, lat:number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "mapBounds",
        "description": "The max bounds allowed for this map."
      }
    ]
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "getContainer",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getContainer",
    "access": "public",
    "description": "Returns the map's containing HTML element.",
    "lineNumber": 72,
    "return": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": "The map's HTML element container."
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "getWidth",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getWidth",
    "access": "public",
    "description": "Returns the width of the canvas elment.",
    "lineNumber": 81,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the width of the canvas elment."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the width of the canvas elment."
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "getHeight",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getHeight",
    "access": "public",
    "description": "Returns the height of the canvas element.",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the height of the canvas elment."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the height of the canvas elment."
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "getMapBounds",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getMapBounds",
    "access": "public",
    "description": "Returns the bounds for this background map.",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ number } - the bounds for this background map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " number "
      ],
      "spread": false,
      "description": "the bounds for this background map."
    }
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "getViewPort",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getViewPort",
    "access": "public",
    "description": "Returns the viewport values for this background map.",
    "lineNumber": 108,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} -  the viewport values for this background map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the viewport values for this background map."
    }
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "calculateViewPort",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#calculateViewPort",
    "access": "public",
    "description": "Calculates the viewport.",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} -  the viewport values for this background map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the viewport values for this background map."
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "calcNextPowerOfTwo",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#calcNextPowerOfTwo",
    "access": "public",
    "description": "Calculates the power of two value equal or higher than the background map div width and height.",
    "lineNumber": 129,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "canvas",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "_calcNextPowerOfTwoHelper",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#_calcNextPowerOfTwoHelper",
    "access": "private",
    "description": "Method that calculates the next power of two equal or higher than the given value.",
    "lineNumber": 142,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The next power of two after the given value."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The width/height of the viewport."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The next power of two after the given value."
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "getZoom",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getZoom",
    "access": "public",
    "description": "Returns the map's current zoom level.",
    "lineNumber": 155,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The map's current zoom level."
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "getCenterLng",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getCenterLng",
    "access": "public",
    "description": "Returns the longitude of the bounding box northwest corner.",
    "lineNumber": 164,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Longitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "getCenterLat",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getCenterLat",
    "access": "public",
    "description": "Returns the latitude of the bounding box northwest corner.",
    "lineNumber": 173,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Latitude of northwest corner, measured in degrees."
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#addEventListener",
    "access": "public",
    "description": "Adds a listener to a specified event type.",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventstr",
        "description": "The event type to add a listen for."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "eventfunction",
        "description": "The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties."
      }
    ]
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "addDragEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#addDragEvent",
    "access": "public",
    "description": "Add drag event.",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs drag on the map."
      }
    ]
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "addZoomEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#addZoomEvent",
    "access": "public",
    "description": "Add zoom event.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The function to be called when the user performs zoom in/out on the map."
      }
    ]
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "addClickEvent",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#addClickEvent",
    "access": "public",
    "description": "Add click event. Calculate the position of the click event relative to the containing div (bgmapDiv).\nWith the calculated x,y then call GisplayMap to proceed the hit testing.",
    "lineNumber": 211,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map"
        ],
        "spread": false,
        "optional": false,
        "name": "map",
        "description": "The function to be called when the user clicks on the map."
      }
    ]
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "getBackgroundMapProviderObject",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getBackgroundMapProviderObject",
    "access": "public",
    "description": "Returns the background map object. This is the Background provider object (e.g., Mapbox, GMaps, HereMaps, Bing Maps).",
    "lineNumber": 220,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{BGMapWrapper#bgMapObject} the background map object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BGMapWrapper#bgMapObject"
      ],
      "spread": false,
      "description": "the background map object."
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "getTileSize",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getTileSize",
    "access": "public",
    "description": "Returns the tile size used to calculate the projection matrix for WebGL.",
    "lineNumber": 229,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the tile size used to calculate the projection matrix for WebGL."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the tile size used to calculate the projection matrix for WebGL."
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "getDiv",
    "memberof": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper#getDiv",
    "access": "public",
    "description": "Returns the div of this background map.",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{HTMLDivElement} - the div of this background map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HTMLDivElement"
      ],
      "spread": false,
      "description": "the div of this background map."
    }
  },
  {
    "__docId__": 317,
    "kind": "file",
    "name": "src/Gisplay/Maps/ChangeMap.js",
    "content": "// import { GisplayMap } from './GisplayMap';\r\n// import { Legend } from '../Layout/Legend';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\nimport { Choropleth } from './Choropleth';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\nexport class ChangeMap extends Choropleth {\r\n\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n        // super(geometry, userOptions);\r\n        // userOptions.attr = \"change\"; //window.maps.push(this);\r\n        // this.loadOptions(userOptions);\r\n    }\r\n\r\n    /**\r\n     * DELETE\r\n     * Process data loaded by the user. This mothed overrides the parent(Map class) default processData method.\r\n     * @param {JSON} geojson - GeoJSON object.\r\n     * @param {number} numberOfClasses - Number of classes that the Legend will contain.\r\n     * @param {string} classBreaksMethod - Algorithm to be used to calculate class breaks. Only used it class breaks are not given by the user.\r\n     * @param {string[]} colorScheme - Color scheme to be used by this map.\r\n     * @override \r\n     * @memberof ChangeMap\r\n     */\r\n    preProcessData(geojson, numberOfClasses, classBreaksMethod, colorScheme) {\r\n        let opts = this.gisplayOptions;\r\n        let gjonFeatures = geojson.features;\r\n        for (let i = 0; i < gjonFeatures.length && i < opts.maxFeatures; i++) {\r\n            let gjsonMinuend = gjonFeatures[i].properties[opts.minuend];\r\n            let gjsonSubtrahend = gjonFeatures[i].properties[opts.subtrahend];\r\n            if (typeof gjsonMinuend === 'number' && typeof gjsonSubtrahend === 'number') {\r\n                this.max = Math.max(this.max, gjsonMinuend - gjsonSubtrahend);\r\n                this.min = Math.min(this.min, gjsonMinuend - gjsonSubtrahend);\r\n            }\r\n        }\r\n\r\n        let X = Math.round(this.min + Math.abs(this.min / 3));\r\n        let Y = Math.round(this.min + Math.abs(this.min / 3) * 2);\r\n        let bm = -4;\r\n        let middle = 0;\r\n        let am = 4;\r\n        let Z = Math.round(this.max - Math.abs(this.max / 3) * 2);\r\n        let W = Math.round(this.max - Math.abs(this.max / 3));\r\n        let classBreaks = [this.min, X, Y, bm, am, Z, W, this.max];//this.calcClassBreaks([this.min, X, Y, middle, Z, W, this.max], classBreaksMethod, 6);\r\n        //let classBreaks = [this.min, X, Y, 0, Z, W, this.max];\r\n\r\n        const aesarray = []; //Array of aesthetic objects loaded from the file\r\n        let fcolor = this.getDefaultColors(classBreaks.length - 1);\r\n        for (let i = 0; i < classBreaks.length - 1; i++) {\r\n            let [r, g, b] = chroma(fcolor[i]).rgb();\r\n            let aes;\r\n            if (i !== classBreaks.length - 2)\r\n                aes = new Aesthetic(i, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[i], classBreaks[i + 1]]);\r\n            else {\r\n                aes = new Aesthetic(i, opts.attr, [Math.round(r), Math.round(g), Math.round(b), opts.alpha], [0, 0, 0, 1], null, [classBreaks[i], classBreaks[i + 1]]);\r\n                aes.outer = true;\r\n            }\r\n            aesarray.push(aes);\r\n        }\r\n        /**\r\n         * Aesthetic object. In the case of a Change Map only one Aesthetic exists.\r\n         * @type {Array<Aesthetic>}\r\n         */\r\n        this.aesthetics = aesarray;\r\n    }\r\n\r\n    /**\r\n     * Defaults for ChangeMap.\r\n     * @memberof ChangeMap\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 7;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberof ChangeMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        return ColorBrewer.getDefautls('ChangeMap', numClasses, dataNature ||  GisplayDefaults.DIVERGENT());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/ChangeMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 318,
    "kind": "class",
    "name": "ChangeMap",
    "memberof": "src/Gisplay/Maps/ChangeMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/ChangeMap.js",
    "importStyle": "{ChangeMap}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Gisplay/Maps/Choropleth.js~Choropleth"
    ]
  },
  {
    "__docId__": 319,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "preProcessData",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#preProcessData",
    "access": "public",
    "description": "DELETE\nProcess data loaded by the user. This mothed overrides the parent(Map class) default processData method.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "geojson",
        "description": "GeoJSON object."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": "Number of classes that the Legend will contain."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "classBreaksMethod",
        "description": "Algorithm to be used to calculate class breaks. Only used it class breaks are not given by the user."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "colorScheme",
        "description": "Color scheme to be used by this map."
      }
    ],
    "override": true
  },
  {
    "__docId__": 321,
    "kind": "member",
    "name": "max",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#max",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true
  },
  {
    "__docId__": 322,
    "kind": "member",
    "name": "min",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#min",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "aesthetics",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#aesthetics",
    "access": "public",
    "description": "Aesthetic object. In the case of a Change Map only one Aesthetic exists.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "Array<Aesthetic>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#defaults",
    "access": "public",
    "description": "Defaults for ChangeMap.",
    "lineNumber": 72
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/ChangeMap.js~ChangeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ChangeMap.js~ChangeMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<RGB>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 326,
    "kind": "file",
    "name": "src/Gisplay/Maps/Choropleth.js",
    "content": "import { GisplayMap } from './GisplayMap';\r\n// import { Legend } from '../Layout/Legend';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * Choropleth implementation.\r\n */\r\nexport class Choropleth extends GisplayMap {\r\n    /**\r\n     * Creates an instance of Choropleth.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof Choropleth\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Draw the polygons and borders for the given combination and temporal granule in the background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.    \r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        // console.time('drawChoro');\r\n        this._drawPolygons(mvc, tg, bgmap);\r\n        this._drawBorders(mvc, tg, bgmap);\r\n        // console.timeEnd('drawChoro');\r\n    }\r\n\r\n    /**\r\n     * Draw the polygons for the given combination and temporal granule in the given background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.   \r\n     * @private\r\n     */\r\n    _drawPolygons(mvc, tg, bgmap) {\r\n        this.initialDrawSetup(mvc, bgmap);\r\n\r\n        this.createImageTexture(GisplayDefaults.TEXTURE());\r\n        this.setTextureIndex(mvc); // PATTERN INDEX\r\n        this.setTextureSize();\r\n        this.setPolygons(tg); //POSITION POLYGONS\r\n    }\r\n\r\n    /**\r\n     * Draw the borders for the given combination and temporal granule in the given background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.   \r\n     * @private\r\n     */\r\n    _drawBorders(mvc, tg, bgmap) {\r\n        this.initialDrawSetup(mvc, bgmap, true);\r\n        this.setPolygonsBorders(tg);\r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        // this.drawPolygonsToTexture(mvc, tg, bgmap, textureViewPort);\r\n        this.initialPickingSetup(mvc, bgmap, textureViewPort);\r\n\r\n        this.createImageTexture(GisplayDefaults.TEXTURE());\r\n        this.setTextureIndex(mvc, false);\r\n        this.setTextureSize();\r\n\r\n        this.setPickingColorsAndPolygons(tg);\r\n    }\r\n\r\n    /**\r\n     * Returns the color scheme and number of classes associated with the id given.\r\n     * @returns {{colorScheme: string[], numberOfClasses: number}} - Color scheme and number of classes associated with the id given, empty object otherwise.\r\n     * @override \r\n     * @memberof Choropleth\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 4;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the avialable time controls for the thematic map.\r\n     * @returns {Array<string>}\r\n     * @memberof GisplayMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        return [GisplayDefaults.INSTANT(), GisplayDefaults.ANIMATION()];\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files.\r\n     * @override \r\n     * @memberof Choropleth\r\n     */\r\n    getShadersFileNames() {\r\n        return { vertexShaderFileName: 'polygons.vert', fragmentShaderFileName: 'polygons.frag' };\r\n    }\r\n\r\n    /**\r\n     * Returns the list of Visual variables that this map allows.\r\n     * @returns {Array<string>} - the list of Visual variables that this map allows.\r\n     * @override\r\n     * @memberof Choropleth\r\n     */\r\n    getAvailableVisualVariables() {\r\n        return [GisplayDefaults.COLOR(), GisplayDefaults.TEXTURE()];\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberof Choropleth\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        console.warn(numClasses, dataNature);\r\n        return ColorBrewer.getDefautls('Choropleth', numClasses, dataNature || GisplayDefaults.SEQUENTIAL());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/Choropleth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 327,
    "kind": "class",
    "name": "Choropleth",
    "memberof": "src/Gisplay/Maps/Choropleth.js",
    "static": true,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/Choropleth.js",
    "importStyle": "{Choropleth}",
    "description": "Choropleth implementation.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/Gisplay/Maps/GisplayMap.js~GisplayMap"
    ]
  },
  {
    "__docId__": 328,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#constructor",
    "access": "public",
    "description": "Creates an instance of Choropleth.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#draw",
    "access": "public",
    "description": "Draw the polygons and borders for the given combination and temporal granule in the background map.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "_drawPolygons",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#_drawPolygons",
    "access": "private",
    "description": "Draw the polygons for the given combination and temporal granule in the given background map.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "_drawBorders",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#_drawBorders",
    "access": "private",
    "description": "Draw the borders for the given combination and temporal granule in the given background map.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#defaults",
    "access": "public",
    "description": "Returns the color scheme and number of classes associated with the id given.",
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{colorScheme: string[], numberOfClasses: number}} - Color scheme and number of classes associated with the id given, empty object otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{colorScheme: string[], numberOfClasses: number}"
      ],
      "spread": false,
      "description": "Color scheme and number of classes associated with the id given, empty object otherwise."
    },
    "override": true
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#getAvailableTemporalControls",
    "access": "public",
    "description": "Returns the avialable time controls for the thematic map.",
    "lineNumber": 103,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 113,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": "the name of the vertex and fragment shader files."
    },
    "override": true
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#getAvailableVisualVariables",
    "access": "public",
    "description": "Returns the list of Visual variables that this map allows.",
    "lineNumber": 123,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of Visual variables that this map allows."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of Visual variables that this map allows."
    },
    "override": true
  },
  {
    "__docId__": 337,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/Choropleth.js~Choropleth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/Choropleth.js~Choropleth#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 135,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<RGB>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 338,
    "kind": "file",
    "name": "src/Gisplay/Maps/DotMap.js",
    "content": "import { GisplayMap } from './GisplayMap';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * DotMap implemenetation\r\n * @export\r\n * @class DotMap\r\n * @extends {GisplayMap}\r\n */\r\nexport class DotMap extends GisplayMap {\r\n\r\n    /**\r\n     * Creates an instance of DotMap.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof DotMap\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Draw the points for the given combination and temporal granule in the background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.    \r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        // this.drawPoints(mvc, tg, bgmap);\r\n        this.initialDrawSetup(mvc, bgmap);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeUniform(mvc); // SIZE\r\n        this.setPoints(tg); //POSITION POINTS\r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        // this.drawPointsToTexture(mvc, tg, bgmap, textureViewPort);\r\n        this.initialPickingSetup(mvc, bgmap, textureViewPort);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeUniform(mvc); // SIZE\r\n\r\n        this.setPickingColorsAndPoints(tg);\r\n    }\r\n\r\n    /**\r\n     * Returns the default values for the color (number of classes and colors).\r\n     * @returns {{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors).\r\n     * @override \r\n     * @memberof DotMap\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 3;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files.\r\n     * @memberof DotMap\r\n     */\r\n    getShadersFileNames() {\r\n        return { vertexShaderFileName: 'points.vert', fragmentShaderFileName: 'points.frag' };\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of visual variables that are available for this map.\r\n     * @returns {Array<string>} - the list of visual variables that are available for this map.\r\n     * @memberof DotMap\r\n     */\r\n    getAvailableVisualVariables() {\r\n        return [GisplayDefaults.COLOR(), GisplayDefaults.SHAPE()];\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of available temporal controls for this thematic map.\r\n     * @returns {Array<string>} - the list of available temporal controls for this thematic map.\r\n     * @memberof DotMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        return [GisplayDefaults.INSTANT(), GisplayDefaults.INTERVAL(), GisplayDefaults.ANIMATION()];\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<number>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberof DotMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        return ColorBrewer.getDefautls('DotMap', numClasses, dataNature || GisplayDefaults.SEQUENTIAL());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/DotMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "DotMap",
    "memberof": "src/Gisplay/Maps/DotMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/DotMap.js",
    "importStyle": "{DotMap}",
    "description": "DotMap implemenetation",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DotMap"
      }
    ],
    "interface": false,
    "extends": [
      "GisplayMap"
    ]
  },
  {
    "__docId__": 340,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#constructor",
    "access": "public",
    "description": "Creates an instance of DotMap.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#draw",
    "access": "public",
    "description": "Draw the points for the given combination and temporal granule in the background map.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#defaults",
    "access": "public",
    "description": "Returns the default values for the color (number of classes and colors).",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{color: {numberOfClasses: number, colors: Array<number>}}"
      ],
      "spread": false,
      "description": "the default values for the color (number of classes and colors)."
    },
    "override": true
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 81,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": "the name of the vertex and fragment shader files."
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#getAvailableVisualVariables",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of visual variables that are available for this map.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of visual variables that are available for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of visual variables that are available for this map."
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#getAvailableTemporalControls",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of available temporal controls for this thematic map.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of available temporal controls for this thematic map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of available temporal controls for this thematic map."
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/DotMap.js~DotMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/DotMap.js~DotMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 113,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} Default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 348,
    "kind": "file",
    "name": "src/Gisplay/Maps/FiguresMap.js",
    "content": "import { GisplayMap } from './GisplayMap';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * FiguresMap implemenetation\r\n * @export\r\n * @class FiguresMap\r\n * @extends {GisplayMap}\r\n */\r\nexport class FiguresMap extends GisplayMap {\r\n\r\n    /**\r\n     * Creates an instance of DotMap.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof FiguresMap\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Draw the figures for the given combination and temporal granule in the background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.    \r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        // this.drawFigures(mvc, tg, bgmap);\r\n        this.initialDrawSetup(mvc, bgmap);\r\n\r\n        this.createImageTexture(GisplayDefaults.ORIENTATION()); // LOAD TEXTURE IMAGE\r\n        this._setFigureIndex(mvc); // FIGURE INDEX <<< @TODO METHOD uses a string 'figureIndex' how to change?\r\n        this.setOrientation(mvc);\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values from defaults.json\r\n\r\n        //SIZE\r\n        if (mvc.hasSize()) {\r\n            this.setSizeMinMaxData(mvc); //Min and max data values\r\n            this.setSizeAttributeMultiple(tg);\r\n        }\r\n        else\r\n            this.setSizeAttributeUnique(mvc);\r\n        this.setPoints(tg); //POSITION POINTS\r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        // this.drawFiguresToTexture(mvc, tg, bgmap, textureViewPort);\r\n        this.initialPickingSetup(mvc, bgmap, textureViewPort);\r\n\r\n        this.createImageTexture(GisplayDefaults.ORIENTATION()); // LOAD TEXTURE IMAGE\r\n        this._setFigureIndex(mvc); // FIGURE INDEX <<< @TODO METHOD uses a string 'figureIndex' how to change?\r\n        this.setOrientation(mvc);\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values from defaults.json\r\n\r\n        //SIZE\r\n        if (mvc.hasSize()) {\r\n            this.setSizeMinMaxData(mvc); //Min and max data values\r\n            this.setSizeAttributeMultiple(tg);\r\n        }\r\n        else\r\n            this.setSizeAttributeUnique(mvc);\r\n\r\n        this.setPickingColorsAndPoints(tg);\r\n    }\r\n\r\n    /**\r\n     * Returns the default values for the color (number of classes and colors).\r\n     * @returns {{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors).\r\n     * @override \r\n     * @memberof FiguresMap\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 3;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files.\r\n     * @memberof FiguresMap\r\n     */\r\n    getShadersFileNames() {\r\n        return { vertexShaderFileName: 'figures.vert', fragmentShaderFileName: 'figures.frag' };\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of visual variables that are available for this map.\r\n     * @returns {Array<string>} - the list of visual variables that are available for this map.\r\n     * @memberof FiguresMap\r\n     */\r\n    getAvailableVisualVariables() {\r\n        return [GisplayDefaults.COLOR(), GisplayDefaults.SHAPE(), GisplayDefaults.SIZE(), GisplayDefaults.ORIENTATION()];\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of available temporal controls for this thematic map.\r\n     * @returns {Array<string>} - the list of available temporal controls for this thematic map.\r\n     * @memberof FiguresMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        return [GisplayDefaults.INSTANT(), GisplayDefaults.INTERVAL(), GisplayDefaults.ANIMATION()];\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<number>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberof FiguresMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        return ColorBrewer.getDefautls('DotMap', numClasses, dataNature || GisplayDefaults.SEQUENTIAL());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/FiguresMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 349,
    "kind": "class",
    "name": "FiguresMap",
    "memberof": "src/Gisplay/Maps/FiguresMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/FiguresMap.js",
    "importStyle": "{FiguresMap}",
    "description": "FiguresMap implemenetation",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "FiguresMap"
      }
    ],
    "interface": false,
    "extends": [
      "GisplayMap"
    ]
  },
  {
    "__docId__": 350,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#constructor",
    "access": "public",
    "description": "Creates an instance of DotMap.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#draw",
    "access": "public",
    "description": "Draw the figures for the given combination and temporal granule in the background map.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 353,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#defaults",
    "access": "public",
    "description": "Returns the default values for the color (number of classes and colors).",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{color: {numberOfClasses: number, colors: Array<number>}}"
      ],
      "spread": false,
      "description": "the default values for the color (number of classes and colors)."
    },
    "override": true
  },
  {
    "__docId__": 354,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": "the name of the vertex and fragment shader files."
    }
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#getAvailableVisualVariables",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of visual variables that are available for this map.",
    "lineNumber": 109,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of visual variables that are available for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of visual variables that are available for this map."
    }
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#getAvailableTemporalControls",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of available temporal controls for this thematic map.",
    "lineNumber": 119,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of available temporal controls for this thematic map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of available temporal controls for this thematic map."
    }
  },
  {
    "__docId__": 357,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/FiguresMap.js~FiguresMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/FiguresMap.js~FiguresMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} Default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 358,
    "kind": "file",
    "name": "src/Gisplay/Maps/GisplayMap.js",
    "content": "//Imports for Intellisense TODO: DELETE\r\nimport { BGMapWrapper } from './Background Maps/BGMapWrapper';\r\nimport { URLVariable } from '../VVs/URLVariable';\r\nimport { DataVariable } from '../VVs/DataVariable';\r\nimport { TimeVariable } from '../VVs/TimeVariable';\r\nimport { TemporalGranule } from '../VVs/TemporalGranule';\r\nimport { CategoricalVariable } from '../VVs/CategoricalVariable';\r\nimport { ContinuousVariable } from '../VVs/ContinuousVariable';\r\nimport { MapVariableCombination } from '../VVs/MapVariableCombination';\r\nimport { Legend } from '../Layout/Legend';\r\nimport { ShadersInfo } from '../Shaders/ShadersInfo';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayDynamicLoader } from '../GisplayDynamicLoader';\r\nimport { WebGLUtils } from '../Helpers/WebGLUtils';\r\nimport { LayoutManager } from '../Layout/LayoutManager';\r\nimport { GeoJSONParser } from '../Parser/GeoJSON/GeoJSONParser';\r\n\r\nimport { GisplayOptions } from '../GisplayOptions';\r\nimport { GisplayError } from '../GisplayError';\r\nimport { CSVParser } from '../Parser/CSV/CSVParser';\r\n\r\n/**\r\n * This class contains the GisplayMap class which represents the base thematic map of the Gisplay API.\r\n * @see Diogo's thesis pages 57-60 + 64/65\r\n */\r\nexport class GisplayMap {\r\n    /**\r\n     * Creates an instance of GisplayMap.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof GisplayMap\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        console.time(\"gisplay\");\r\n        /**\r\n         * The name of the library loaded event.\r\n         * @type {string}\r\n         */\r\n        this.LIBRARY_LOADED_EVENT = 'libraryLoaded';\r\n        /**\r\n         * The name of the parser ended event.\r\n         * @type {string}\r\n         */\r\n        this.PARSER_ENDED_EVENT = 'parserEnd';\r\n        /**\r\n         * The name of the event for geometry ids.\r\n         * @type {string}\r\n         */\r\n        this.GEOMETRY_IDS_EVENT = 'geometryIdsEnd';\r\n        /**\r\n         * The shapes image loaded event.\r\n         * Needed, otherwise could cause the error: https://github.com/jywarren/webgl-distort/issues/4\r\n         * @type {string}\r\n         */\r\n        this.SHAPES_IMAGE_LOADED_EVENT = 'shapesImageLoaded';\r\n        /**\r\n         * The patterns image loaded event.\r\n         * @type {string}\r\n         */\r\n        this.PATTERNS_IMAGE_LOADED_EVENT = 'patternsImageLoaded';\r\n        /**\r\n         * The figures image loaded event.\r\n         * @type {string}\r\n         */\r\n        this.FIGURES_IMAGE_LOADED_EVENT = 'figuresImageLoaded';\r\n        /**\r\n         * The finish events for the library load, for parser end, pattern and shapes images and any other that may  be added.\r\n         * @type {{libraryLoaded: boolean, parserEnded: boolean, geometryIdsEnd:boolean, shapesImageLoaded:boolean, patternsImageLoaded:boolean, figuresImageLoaded: boolean}}\r\n         */\r\n        this.finishedEvents = {\r\n            libraryLoaded: false,\r\n            parserEnd: false,\r\n            geometryIdsEnd: true,\r\n            shapesImageLoaded: false,\r\n            patternsImageLoaded: false,\r\n            figuresImageLoaded: false\r\n        };\r\n\r\n        this._setupCustomEventListenners();\r\n\r\n        //@TODO: globalOptions.provider is not null if we already called new GisplayErrorChecker(p,m, globalOpts.provider)\r\n        /**\r\n         * The gisplay dynamic loader.\r\n         * @type {GisplayDynamicLoader}\r\n         */\r\n        this.dynamicLoader = this.startDynamicLoader(globalOptions.provider);\r\n        /**\r\n         * The information about the shaders that will be used for this map.\r\n         * @type {ShadersInfo}\r\n         */\r\n        this.shadersInfo = this.dynamicLoader.getShadersInfo();\r\n\r\n        /**\r\n         * All the options available in the Gisplay API.\r\n         * @type {GisplayOptions}\r\n         */\r\n        this.gisplayOptions = this.loadGisplayOptions(parsingOptions, mappingOptions, globalOptions);\r\n        /**\r\n         * All the categorical variables that were created with the given options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\r\n        this.categoricalVariables = this.gisplayOptions.getCategoricalVariables();\r\n        /**\r\n         * All the continuous variables that were created with the given options.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\r\n        this.continousVariables = this.gisplayOptions.getContinousVariables();\r\n        /**\r\n         * The time variable or null if there's no Time in the dataset.\r\n         * @type {TimeVariable}\r\n         */\r\n        this.timeVariable = this.gisplayOptions.getTimeVariable();\r\n        /**\r\n         * The URLVariable.\r\n         * @type {URLVariable} \r\n         */\r\n        this.urlVariable = this.gisplayOptions.getURLVariable();\r\n\r\n        this._setupGeometryIdsEventListenner();\r\n\r\n        /**\r\n         * Holds the background maps.\r\n         * @type {Array<BGMapWrapper>}\r\n         */\r\n        this.bgMaps = [];\r\n        /**\r\n         * Holds reference to WebGL context and program.\r\n         * @type {{gl: WebGLRenderingContext, program: WebGLProgram, bordersProgram: WebGLProgram}} _webgl - WebGL rendering context, program and borders program.\r\n         * @see Diogo's thesis page 64+\r\n         */\r\n        this._webgl = null;\r\n        /**\r\n         * The layout manager. \r\n         * @type {LayoutManager}\r\n         */\r\n        this.layoutManager = new LayoutManager(this.gisplayOptions);\r\n        /**\r\n         * Holds all the existing Legends.\r\n         * @type {Array<Legend>}\r\n         */\r\n        this.legends = [];\r\n\r\n        /**\r\n         * An array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable.\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.optionalVariables = this.gisplayOptions.getOptionalVariables();\r\n        //THIS VARIABLE IS NOT IN USE ATM\r\n        /**\r\n         * The geometry variables (longitude and latitude).\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.geometryVariables = this.gisplayOptions.getGeometryVariables();\r\n\r\n        //WILL COME FROM PARSERs\r\n        /**\r\n         * All the Visual Variable Combinations that exist in this map. Read and processed from the dataset.\r\n         * @type {Array<MapVariableCombination>}\r\n         */\r\n        this.mapVariableCombinations = [];\r\n        /**\r\n         * Map where each key is a combination string and it's value is the index of it's position in the visual variable combinations array.\r\n         * @type {Map<string, number>}\r\n         */\r\n        this.mapVariableCombinationToIndexMap = new Map();\r\n        /**\r\n         * The map with ids and their respective geometry.\r\n         * @type {Map<string, Polygon|Array<number>>}\r\n         */\r\n        this.geometryIdsMap = new Map();\r\n        /**\r\n         * The buffer with all points. Used for maps with polygons or lines.\r\n         * @type {WebGLBuffer}\r\n         */\r\n        this.allPoints;\r\n        this.allColors;\r\n        /**\r\n         * The geometry primitive that was read from the file.\r\n         * @type {number}\r\n         */\r\n        this.geometryPrimitive;\r\n\r\n        //Setup webgl context and program.\r\n        this.setupWebGL();\r\n\r\n        this.readFiles();\r\n        // console.log(this);\r\n        window.g = this;\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     INITIAL SETUP      ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Sets up a listener for each existing custom event.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setupCustomEventListenners() {\r\n        document.addEventListener(this.LIBRARY_LOADED_EVENT, () => { this.initialSetup(this.LIBRARY_LOADED_EVENT); });\r\n        document.addEventListener(this.SHAPES_IMAGE_LOADED_EVENT, () => { this.initialSetup(this.SHAPES_IMAGE_LOADED_EVENT); });\r\n        document.addEventListener(this.PATTERNS_IMAGE_LOADED_EVENT, () => { this.initialSetup(this.PATTERNS_IMAGE_LOADED_EVENT); });\r\n        document.addEventListener(this.FIGURES_IMAGE_LOADED_EVENT, () => { this.initialSetup(this.FIGURES_IMAGE_LOADED_EVENT); });\r\n        // Listen to parser end/done event\r\n        document.addEventListener(this.PARSER_ENDED_EVENT, (e) => this.receiveParserData(e.detail), false);\r\n    }\r\n\r\n    /**\r\n     * Setup a listener for geometry ids event, if the geometry was given by ids.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setupGeometryIdsEventListenner() {\r\n        if (this.urlVariable.hasIds()) {\r\n            this.finishedEvents.geometryIdsEnd = false;\r\n            document.addEventListener(this.GEOMETRY_IDS_EVENT, (e) => this.receiveParserGeometryIds(e.detail), false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start the Gisplay dynamic loader, responsible to load multiple elements of the Gisplay API.\r\n     * @param {string} libraryName - The name of the background map. \r\n     * @returns {GisplayDynamicLoader} - the GisplayDynamicLoader object created.\r\n     * @memberof GisplayMap\r\n     */\r\n    startDynamicLoader(libraryName) {\r\n        let vertexShaderFileName = this.getShadersFileNames().vertexShaderFileName;\r\n        let fragmentShaderFileName = this.getShadersFileNames().fragmentShaderFileName;\r\n        return new GisplayDynamicLoader(libraryName, vertexShaderFileName, fragmentShaderFileName);\r\n    }\r\n\r\n    /**\r\n     * Loads user and default options. For each case if it isn't provided by the user, then it uses\r\n     * the default option. 1st method to be called.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @returns {GisplayOptions} - the processed gisplay options.\r\n     * @memberof GisplayMap\r\n     */\r\n    loadGisplayOptions(parsingOptions, mappingOptions, globalOptions) {\r\n        return new GisplayOptions(parsingOptions, mappingOptions, globalOptions, this);\r\n    }\r\n\r\n    /**\r\n     * Sets up WebGL.\r\n     * @memberof GisplayMap\r\n     */\r\n    setupWebGL() {\r\n        let { vertexShaderFileName, fragmentShaderFileName } = this.getShadersFileNames();\r\n        let { borderVertexFileName, borderFragmentFileName } = GisplayDefaults.getBordersShadersFileNames();\r\n        this._webgl = WebGLUtils.setupWebGL(\r\n            this.layoutManager.getCanvas(),\r\n            this.layoutManager.getBgmapsDiv(),\r\n            this.dynamicLoader.loadShaders(vertexShaderFileName, fragmentShaderFileName),\r\n            this.dynamicLoader.loadShaders(borderVertexFileName, borderFragmentFileName)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Read the data file, and if it exists the geospatial information.\r\n     * @memberof GisplayMap\r\n     */\r\n    readFiles() {\r\n        let fileName = this.urlVariable.getDataFileName();\r\n        if (fileName.endsWith('.json') || fileName.endsWith('.geojson')) {// Start geojson parser for this file and userOptions\r\n            console.log('JSON');\r\n            new GeoJSONParser(this.gisplayOptions, this._webgl.gl);\r\n        } else if (fileName.endsWith('.csv') || fileName.endsWith('.CSV')) {// Start CSV parser for this file and userOptions\r\n            console.log(\"CSV\");\r\n            // new CSVParser(this.gisplayOptions, this._webgl.gl);\r\n            new CSVParser(this.gisplayOptions, this._webgl.gl);\r\n        } else {\r\n            console.error(\"WRONG File extension\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Receives the parsed data.\r\n     * @param {{mapVariableCombinations: Array<MapVariableCombination>, mapVariableCombinationToIndexMap:Map<string, number>, categoricalVariables: Array<CategoricalVariable>, continousVariables:Array<ContinuousVariable>, allPoints: WebGLBuffer}} detail - The custom event (parserEnd) data. \r\n     * @memberof GisplayMap\r\n     */\r\n    receiveParserData(detail) {\r\n        // console.log(detail);\r\n        this.mapVariableCombinations = detail.mapVariableCombinations;\r\n        this.mapVariableCombinationToIndexMap = detail.mapVariableCombinationToIndexMap;\r\n        this.categoricalVariables = detail.categoricalVariables;\r\n        this.continousVariables = detail.continousVariables;\r\n        if (!Array.isArray(detail.allPoints)) { //Only save the allPoints if it contains a WebGLBuffer\r\n            this.allPoints = detail.allPoints;\r\n            this.allColors = detail.allColors;\r\n        }\r\n        // console.log(this.visualVariableCombinations, this.visualVariableCombinationToIndexMap, this.categoricalVariables, this.continousVariables);\r\n        this.initialSetup(this.PARSER_ENDED_EVENT);\r\n    }\r\n\r\n    /**\r\n     * Receives the parsed ids and their respective geometry.\r\n     * @param {{geometryIdsMap: Map<string, any>, allPoints: WebGLBuffer, geometryPrimitive: number}} detail - The custom event (parserEnd) data. \r\n     * @memberof GisplayMap\r\n     */\r\n    receiveParserGeometryIds(detail) {\r\n        this.geometryIdsMap = detail.geometryIdsMap;\r\n        this.allPoints = detail.allPoints;\r\n        this.allColors = detail.allColors;\r\n        this.geometryPrimitive = detail.geometryPrimitive;\r\n        this.initialSetup(this.GEOMETRY_IDS_EVENT);\r\n    }\r\n\r\n    /**\r\n     * If all events already ended then it continues the API execution (setup layout, legends, etc), otherwise does nothing.\r\n     * @param {string} eventName - The name of the fired event. \r\n     * @see https://blog.mariusschulz.com/2016/02/10/the-some-and-every-array-methods-in-javascript\r\n     * @memberof GisplayMap\r\n     */\r\n    initialSetup(eventName) {\r\n        this.finishedEvents[eventName] = true;\r\n        // console.log(this.finishedEvents);\r\n        //Verify all events are done\r\n        let allEventsDone = Object.values(this.finishedEvents).every((v) => v); //.filter((k) => k).length === values.length;\r\n        if (allEventsDone) {\r\n            console.timeEnd(\"gisplay\");\r\n\r\n            if (this.urlVariable.hasIds())\r\n                this.replaceIdsWithGeometry();\r\n\r\n            // console.log(this.finishedEvents);\r\n\r\n            this.generateTGsRGBAIDs();\r\n\r\n            this.setupBGMapsLayout();\r\n            this.setupTimeControl();\r\n            this.setupLegends();\r\n            this.setupInteractionEvents();\r\n\r\n            this.layoutManager.resizeCanvas(); //Avoid bug where elems would be above Legends\r\n            this.drawToMap();\r\n\r\n            this.layoutManager.dismissLoader();\r\n            this.layoutManager.createDisbaleBGMapsIcon();\r\n            console.log(this);\r\n            window.tg = this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates the RGBA identifiers for each Map Variable combination and for each Temporal Granule.\r\n     * @memberof GisplayMap\r\n     */\r\n    generateTGsRGBAIDs() {\r\n        //The R and G will be used to represent the index of the MVC and B and A will be used represent the index of the TG\r\n        //This way we can find the MVC/TG in O(1)\r\n        for (const [i, mvc] of this.mapVariableCombinations.entries()) {\r\n            let [Rmvc, Gmvc, Bmvc, Amvc] = GisplayDefaults.numberToRGBA(i + 1); // Bmvc and Amvc will allow indices between 0-65535\r\n            for (const [j, tg] of mvc.getTemporalGranules().entries()) {\r\n                let [Rtg, Gtg, Btg, Atg] = GisplayDefaults.numberToRGBA(j + 1);\r\n                //                     Index MVC   Index TG\r\n                tg.setRTGRGBAIdentifier(Bmvc, Amvc, Btg, Atg);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When the GeoJSONIdsParser is used, we can replace the data that it processed. This data can be used directly by each temporal granule.\r\n     * This method replaces the ids with the actual geometry and then continues the process by joining the picking colors etc.\r\n     * @memberof GisplayMap\r\n     */\r\n    replaceIdsWithGeometry() {\r\n        console.warn(this.geometryIdsMap, this.geometryPrimitive);\r\n        for (const mvc of this.mapVariableCombinations)\r\n            for (const tg of mvc.getTemporalGranules())\r\n                tg.setGeometryPrimitive(this.geometryPrimitive);\r\n\r\n        for (const mvc of this.mapVariableCombinations)\r\n            for (const tg of mvc.getTemporalGranules())\r\n                tg.replaceIdsWithGeometry(this.geometryIdsMap);\r\n\r\n        for (const mvc of this.mapVariableCombinations)\r\n            mvc.joinPickingColors();\r\n\r\n        for (const mvc of this.mapVariableCombinations)\r\n            for (const tg of mvc.getTemporalGranules())\r\n                tg.setNumElements();\r\n\r\n        for (const mvc of this.mapVariableCombinations)\r\n            mvc.joinTemporalGranuleData(this._webgl.gl, this.geometryPrimitive);\r\n\r\n        this.geometryIdsMap = null;\r\n    }\r\n\r\n    printInfo(bgmap = this.bgMaps[0]) {\r\n        if (!window.numDraws)\r\n            window.numDraws = 0;\r\n        let lngCenter = bgmap.getCenterLng();\r\n        let latCenter = bgmap.getCenterLat();\r\n        let zoom = bgmap.getZoom();\r\n        let tileSize = bgmap.getTileSize();\r\n        let width = bgmap.getWidth();\r\n        let height = bgmap.getHeight();\r\n        let mercator = WebGLUtils.webMercatorProjection(lngCenter, latCenter, zoom, tileSize, width, height);\r\n        let MMatrix = WebGLUtils.finalMatrix(mercator.scale, width, height, mercator.offsetX, mercator.offsetY);\r\n        console.log(\"NumDraws = \", ++window.numDraws, lngCenter, latCenter, zoom, width, height, mercator.scale, mercator.offsetX, mercator.offsetY);\r\n        // console.log(this.layoutManager.getBgmapsDiv().width, this.layoutManager.getBgmapsDiv().height);\r\n        // let bgmapsDiv = document.getElementById('gisplay2_bgmaps');\r\n        // console.log(bgmapsDiv.offsetWidth, bgmapsDiv.offsetHeight);\r\n        console.log(\"-------\");\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################       SETUP LAYOUT      #####################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Sets up the layout manager for this instance of the Gisplay API.\r\n     * @memberof GisplayMap\r\n     */\r\n    setupBGMapsLayout() {\r\n        this.bgMaps = this.layoutManager.setupBGMapsLayout();\r\n        // this.bgMaps = this.layoutManager._createBackgroundMaps();\r\n    }\r\n\r\n    /**\r\n     * Creates the time control.\r\n     * @memberof GisplayMap\r\n     */\r\n    setupTimeControl() {\r\n        if (this.timeVariable)\r\n            this.layoutManager.createTimeControl(this.timeVariable);//timeTitle, type, timeInstants);\r\n    }\r\n\r\n    /**\r\n     * Creates all the legends needed for this thematic map.\r\n     * @memberof GisplayMap\r\n     */\r\n    setupLegends() {\r\n        for (const catVar of this.categoricalVariables) {\r\n            let image;\r\n            if (catVar.getTypeOfVisualVariable() === GisplayDefaults.TEXTURE())\r\n                image = this.dynamicLoader.getPatternsImage();\r\n            else if (catVar.getTypeOfVisualVariable() === GisplayDefaults.SHAPE())\r\n                image = this.dynamicLoader.getShapesImage();\r\n            else if (catVar.getTypeOfVisualVariable() === GisplayDefaults.ORIENTATION())\r\n                image = this.dynamicLoader.getFiguresImage();\r\n            this.legends.push(this.layoutManager.createLegend(catVar, image));\r\n        }\r\n        for (const contVar of this.continousVariables)\r\n            this.legends.push(this.layoutManager.createLegend(contVar, this.dynamicLoader.getShapesImage()));\r\n    }\r\n\r\n    /**\r\n     * Setup all interaction events used by the Gisplay API. \r\n     * The existing events are pan (drag), zoom, and click on the background map plus the methods for\r\n     * the time control change, legend change and for the resize of the window.\r\n     * This events will be fired by the background map provider and we can use them to draw(zoom and pan) or alert information(click).\r\n     * @memberof GisplayMap\r\n     */\r\n    setupInteractionEvents() {\r\n        for (let bgmap of this.bgMaps) {\r\n            bgmap.addDragEvent(() => this.drawToMap('drag'));\r\n            bgmap.addZoomEvent(() => this.drawToMap('zoom'));\r\n            bgmap.addClickEvent(this);\r\n        }\r\n        //Listen to time control events\r\n        document.addEventListener('TimeRangeChanged', () => { this.drawToMap('time'); });\r\n        //Listen to changes on any Legend\r\n        document.addEventListener('LegendChangedEvent', (e) => { this.legendChangedEvent(e.detail); });\r\n\r\n        window.addEventListener('resize', () => {\r\n            //  this.layoutManager.resizeCanvas(); \r\n            for (let bgmap of this.bgMaps)\r\n                bgmap.resize();\r\n            this.drawToMap('resize');\r\n        }, false); //Resize Canvas when the user changes the size of the window\r\n    }\r\n\r\n    /**\r\n     * Called when any legend state changes.\r\n     * @memberof GisplayMap\r\n     */\r\n    legendChangedEvent() {\r\n        //                  L1             L2                   legends\r\n        let states = []; // [false, true], [true, true, true]   state\r\n        //                   0      1       0     1     2       index\r\n        for (let legend of this.legends)\r\n            states.push(legend.getLegendVisibilityState());\r\n        // console.log(states);\r\n\r\n        for (let mvc of this.mapVariableCombinations) {\r\n            let combinationStr = mvc.getCombinationString();\r\n            // console.log(combinationStr); //00, 01, 02, 10, 11, 12\r\n            let finalState = true;\r\n            for (let i = 0; i < combinationStr.length; i++) { // 0..0\r\n                let charInteger = +combinationStr[i]; //0\r\n                let charState = states[i][charInteger]; //states[0][0] -> false\r\n                finalState = finalState && charState; //Conjunction between the legend index state and the current state\r\n            }\r\n            // console.log(finalState);\r\n            finalState ? mvc.enable() : mvc.disable();\r\n        }\r\n        this.drawToMap('legend');\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     WEBGL METHODS      ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Clear current buffers to preset values.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/clear\r\n     * @memberof GisplayMap\r\n     */\r\n    clear() {\r\n        const gl = this._webgl.gl;\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        gl.disable(gl.DEPTH_TEST);\r\n        // this.layoutManager.deletePickingTooltip();\r\n    }\r\n\r\n    /**\r\n     * This method is used to draw to the background map. For each enabled map variable combination goes over each \r\n     * active temporal granule and draws all it's geometry with the respective information.\r\n     * @memberof GisplayMap\r\n     */\r\n    drawToMap(eventName = 'initial') {\r\n        let initT = performance.now();\r\n        console.time(\"drawToMap\");\r\n        // console.time(\"b4\");\r\n        this.clear();\r\n        this.layoutManager.deletePickingTooltip();\r\n        this.layoutManager.resizeCanvas();\r\n        for (let bgmap of this.bgMaps) //Needed?\r\n            bgmap.resize();\r\n        console.warn(eventName);\r\n        // this.printInfo();\r\n\r\n        /*const gl = this._webgl.gl;\r\n         gl.enable(gl.BLEND);\r\n         gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA); \r\n         */\r\n\r\n        let granulesIndices = this.getActiveTemporalGranules();\r\n        for (let mvc of this.mapVariableCombinations) {\r\n            // console.time(\"mvc\");\r\n            if (mvc.isEnabled()) {\r\n                let mvcTemporalGranules = mvc.getTemporalGranules();\r\n                for (let index of granulesIndices) {\r\n                    let tg = mvcTemporalGranules[index];\r\n                    // console.time(\"draw\");\r\n                    // console.warn(tg.getNumElements(), tg.hasElements());\r\n                    if (tg.hasElements())\r\n                        for (let bgmap of this.bgMaps)\r\n                            this.draw(mvc, tg, bgmap);\r\n                    // console.timeEnd(\"draw\");\r\n                }\r\n            }\r\n            // console.timeEnd(\"mvc\");\r\n        }\r\n        console.timeEnd(\"drawToMap\");\r\n        let finalT = performance.now();\r\n        console.log(initT, finalT, finalT - initT);\r\n    }\r\n\r\n    //@TODO DELETE next 6 methods \r\n    /**\r\n     * The new method to draw points.\r\n     * @param {MapVariableCombination} mvc \r\n     * @param {TemporalGranule} tg \r\n     * @param {BGMapWrapper} bgmap \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPoints(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc);\r\n        this._setPickingState(false);\r\n        this._setProjectionMatrix(bgmap);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeUniform(mvc); // SIZE\r\n\r\n        this.setPoints(tg); //POSITION\r\n    }\r\n\r\n    /**\r\n     * Draw proportion symbols.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule.\r\n     * @param {BGMapWrapper} bgmap - The background map\r\n     * @see https://stats.stackexchange.com/a/144342\r\n     * @see http://devdocs.io/dom/webglrenderingcontext/vertexattribpointer\r\n     * @memberof GisplayMap\r\n     */\r\n    drawProportionalSymbols(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc);\r\n        this._setPickingState(false);\r\n        this._setProjectionMatrix(bgmap);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values\r\n        this.setSizeMinMaxData(mvc); //Min and max data values\r\n\r\n        this.setSizeAttributeMultiple(tg); //SIZE\r\n\r\n        //All points\r\n        this.setPoints(tg); //POSITION\r\n    }\r\n\r\n    /**\r\n     * Draw figures.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule.\r\n     * @param {BGMapWrapper} bgmap - The background map\r\n     * @see https://stats.stackexchange.com/a/144342\r\n     * @see http://devdocs.io/dom/webglrenderingcontext/vertexattribpointer\r\n     * @memberof GisplayMap\r\n     */\r\n    drawFigures(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc); //COLOR + ALPHA\r\n        this._setPickingState(false);  //PICKING\r\n        this._setProjectionMatrix(bgmap); //MATRICES\r\n\r\n        this.createImageTexture(GisplayDefaults.ORIENTATION()); // LOAD TEXTURE IMAGE\r\n        this._setFigureIndex(mvc); // FIGURE INDEX <<< @TODO METHOD uses a string 'figureIndex' how to change?\r\n        this.setOrientation(mvc);\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values from defaults.json\r\n\r\n        //SIZE\r\n        if (mvc.hasSize()) {\r\n            this.setSizeMinMaxData(mvc); //Min and max data values\r\n            this.setSizeAttributeMultiple(tg);\r\n        }\r\n        else\r\n            this.setSizeAttributeUnique(mvc);\r\n\r\n        //All points\r\n        this.setPoints(tg); //POSITION\r\n    }\r\n\r\n    /**\r\n     * The new method to draw Polygons.\r\n     * @param {MapVariableCombination} mvc - The map variable combination\r\n     * @param {TemporalGranule} tg - The temporal granule. \r\n     * @param {BGMapWrapper} bgmap - The background map where we want to draw.\r\n     * @memberof GisplayMap\r\n     */\r\n    drawPolygons(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc);\r\n        this._setPickingState(false); // NO PICKING NOW\r\n        this._setProjectionMatrix(bgmap);\r\n\r\n        this.createImageTexture(GisplayDefaults.TEXTURE());\r\n        this.setTextureIndex(mvc); // PATTERN INDEX\r\n        this.setTextureSize();\r\n\r\n        this.setPolygons(tg); //POSITION\r\n    }\r\n\r\n    /**\r\n     * The new method to draw Borders.\r\n     * @param {MapVariableCombination} mvc - The map variable combination\r\n     * @param {TemporalGranule} tg - The temporal granule. \r\n     * @param {BGMapWrapper} bgmap - The background map where we want to draw.\r\n     * @see https://stackoverflow.com/a/9153755/ - Use program\r\n     * @memberof GisplayMap\r\n     */\r\n    drawBorders(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.bordersProgram;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc, true);\r\n        this._setProjectionMatrix(bgmap, true);\r\n\r\n        this.setPolygonsBorders(tg);\r\n    }\r\n\r\n    /**\r\n     * The new method to draw Lines.\r\n     * @param {MapVariableCombination} mvc - The map variable combination\r\n     * @param {TemporalGranule} tg - The temporal granule. \r\n     * @param {BGMapWrapper} bgmap - The background map where we want to draw.\r\n     * @see http://www3.ntu.edu.sg/home/ehchua/programming/opengl/images/GL_GeometricPrimitives.png\r\n     * @memberof GisplayMap\r\n     */\r\n    drawLines(mvc, tg, bgmap) {\r\n        const gl = this._webgl.gl;\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc);\r\n        this._setPickingState(false); // NO PICKING NOW\r\n        this._setProjectionMatrix(bgmap);\r\n\r\n        this.setLines(tg); //Draw the lines \r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################         WEBGL AUX      ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Initial setup for the draw operation. All draw operations should first call this method. \r\n     * Sets the program to use, the viewport, the alpha and color, the picking state and the projection matrix. \r\n     * @param {MapVariableCombination} mvc - The map variable combination\r\n     * @param {BGMapWrapper} bgmap - The background map where we want to draw.\r\n     * @param {boolean} [useBordersProgram=false] - Should use the borders program and color or not.\r\n     * @memberof GisplayMap\r\n     */\r\n    initialDrawSetup(mvc, bgmap, useBordersProgram = false) {\r\n        const gl = this._webgl.gl;\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n        const PROGRAM = useBordersProgram ? this._webgl.bordersProgram : this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setViewport(bgmap);\r\n        this._setAlphaAndColor(mvc, useBordersProgram);\r\n        if (!useBordersProgram)\r\n            this._setPickingState(false); // NO PICKING NOW\r\n        this._setProjectionMatrix(bgmap, useBordersProgram);\r\n    }\r\n\r\n    /**\r\n     * Set the viewport for normal draw.\r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.\r\n     * @private\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/viewport\r\n     * @memberof GisplayMap\r\n     */\r\n    _setViewport(bgmap) {\r\n        const gl = this._webgl.gl;\r\n        let viewport = bgmap.calculateViewPort(this.layoutManager.canvas);\r\n        gl.viewport(...viewport);\r\n        gl.scissor(...viewport);\r\n    }\r\n\r\n    /**\r\n     * Set the alpha and color values in the fragment shader.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {boolean} [useBordersProgram=false] - Should use the borders program and color or not.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setAlphaAndColor(mvc, useBordersProgram = false) {\r\n        const gl = this._webgl.gl;\r\n        const webGLProgram = useBordersProgram ? this._webgl.bordersProgram : this._webgl.program;\r\n        const fragmentColorLocation = gl.getUniformLocation(webGLProgram, this.shadersInfo.getColorName()); // COLOR\r\n        let color = useBordersProgram ? GisplayDefaults.getDefaultBordersColor() : mvc.getColor();\r\n        gl.uniform3f(fragmentColorLocation, ...color);\r\n        const fragmentAlphaLocation = gl.getUniformLocation(webGLProgram, this.shadersInfo.getOpacityName()); // ALPHA\r\n        gl.uniform1f(fragmentAlphaLocation, mvc.getAlpha());\r\n    }\r\n\r\n    /**\r\n     * Set the picking state. 1 if we want to draw the picking data, 0, otherwise.\r\n     * @param {boolean} isEnabled - Enable or disable isPicking in the fragment shader.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setPickingState(isEnabled) {\r\n        const gl = this._webgl.gl;\r\n        const fragmentIsPickingLocation = gl.getUniformLocation(this._webgl.program, GisplayDefaults.isPickingName()); //PICKING\r\n        gl.uniform1i(fragmentIsPickingLocation, isEnabled ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * This method will set the projection matrix to be used to convert the sent lat/lng points/vertices into WebGL coordinates.\r\n     * @param {BGMapWrapper} bgmap - The background map wrapper.\r\n     * @param {boolean} [useBordersProgram=false] - Use the borders program or not.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setProjectionMatrix(bgmap, useBordersProgram = false) {\r\n        const gl = this._webgl.gl;\r\n        let lngCenter = bgmap.getCenterLng();\r\n        let latCenter = bgmap.getCenterLat();\r\n        let zoom = bgmap.getZoom();\r\n        let tileSize = bgmap.getTileSize();\r\n        let width = bgmap.getWidth();\r\n        let height = bgmap.getHeight();\r\n        let mercator = WebGLUtils.webMercatorProjection(lngCenter, latCenter, zoom, tileSize, width, height);\r\n        // let MMatrix = WebGLUtils.finalMatrix(mercator.scale, width, height,\r\n        //     mercator.offsetX + (window.x ? window.x : 0), mercator.offsetY + (window.y ? window.y : 0));\r\n        let MMatrix = WebGLUtils.finalMatrix(mercator.scale, width, height, mercator.offsetX, mercator.offsetY);\r\n        const MatrixLocation = gl.getUniformLocation(useBordersProgram ? this._webgl.bordersProgram : this._webgl.program, this.shadersInfo.getMatrixProjectionName());\r\n        gl.uniformMatrix3fv(MatrixLocation, false, MMatrix);\r\n    }\r\n\r\n    /**\r\n     * Creates a texture with the image that contains the shapes, figures or patterns.\r\n     * If it's a dot or prop symbols then load shapes image.\r\n     * Else if it's a figures map load the figures image.\r\n     * Else if it's a polygons map load the patterns image.\r\n     * @param {boolean} [imageType=GisplayDefaults.SHAPE()] - The type of image to load.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    createImageTexture(imageType = GisplayDefaults.SHAPE()) {\r\n        const gl = this._webgl.gl;\r\n        const texture = gl.createTexture();\r\n        let image;\r\n        if (imageType === GisplayDefaults.SHAPE())\r\n            image = this.dynamicLoader.getShapesImage();\r\n        else if (imageType === GisplayDefaults.TEXTURE())\r\n            image = this.dynamicLoader.getPatternsImage();\r\n        else if (imageType === GisplayDefaults.ORIENTATION())\r\n            image = this.dynamicLoader.getFiguresImage();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        // Set the parameters so we can render any size image.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        // Upload the image into the texture.\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n    }\r\n\r\n    /**\r\n     * Set the shape index value in the fragment shader.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setShapeIndex(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const vertexShapeIndexLocation = gl.getUniformLocation(this._webgl.program, this.shadersInfo.getShapeName()); // SHAPE INDEX\r\n        gl.uniform1i(vertexShapeIndexLocation, mvc.getShape());\r\n    }\r\n\r\n    /**\r\n     * Set the size location in the vertex shader when the type of the variable is uniform. \r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setSizeUniform(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const vertexSizeLocation = gl.getUniformLocation(this._webgl.program, this.shadersInfo.getSizeVarName()); // SIZE UNIFORM\r\n        gl.uniform1f(vertexSizeLocation, mvc.getSize());\r\n    }\r\n\r\n    /**\r\n     * Set the size location in the vertex shader when the type of the variable is attribute but we \r\n     * only want to use a single value to identify all elements (meaning all elements have the same size). \r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setSizeAttributeUnique(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, this.shadersInfo.getSizeVarName()); // SIZE data itself\r\n        gl.vertexAttrib1f(vertexSizeLocation, mvc.getSize());\r\n    }\r\n\r\n    /**\r\n     * Set the size location in the vertex shader when the type of the variable is attribute and each element\r\n     * will have it's own size.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the information to be drawn. \r\n     * @memberof GisplayMap\r\n     */\r\n    setSizeAttributeMultiple(tg) {\r\n        const gl = this._webgl.gl;\r\n        let attributeData = tg.getAttributeData();\r\n        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, this.shadersInfo.getSizeVarName()); // SIZE data itself\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, attributeData);\r\n        gl.enableVertexAttribArray(vertexSizeLocation);\r\n        gl.vertexAttribPointer(vertexSizeLocation, 1, gl.FLOAT, false, GisplayDefaults.getFloat32BytesPerElement(), 0);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex shader min and max pixels uniform values.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setSizeMinMaxPixels() {\r\n        //Size Related default values\r\n        const gl = this._webgl.gl;\r\n        const webGLProgram = this._webgl.program;\r\n        const vertexMinPixelsLocation = gl.getUniformLocation(webGLProgram, GisplayDefaults.getMinSizePixels().name); //SIZE min, max pixels\r\n        gl.uniform1f(vertexMinPixelsLocation, GisplayDefaults.getMinSizePixels().value);\r\n        const vertexMaxPixelsLocation = gl.getUniformLocation(webGLProgram, GisplayDefaults.getMaxSizePixels().name);\r\n        gl.uniform1f(vertexMaxPixelsLocation, GisplayDefaults.getMaxSizePixels().value);\r\n    }\r\n\r\n    /**\r\n     * Set the vertex shader min and maximum data values.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setSizeMinMaxData(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const webGLProgram = this._webgl.program;\r\n        let [min, max] = mvc.getMapVariableMinMax(GisplayDefaults.SIZE());\r\n        const vertexMinDataLocation = gl.getUniformLocation(webGLProgram, GisplayDefaults.getMinSizeDataName());\r\n        gl.uniform1f(vertexMinDataLocation, min);\r\n        const vertexMaxDataLocation = gl.getUniformLocation(webGLProgram, GisplayDefaults.getMaxSizeDataName());\r\n        gl.uniform1f(vertexMaxDataLocation, max);\r\n    }\r\n\r\n    /**\r\n     * Set the pattern index in the fragment shader.\r\n     * If the textureIndex parameter is set then it overrides the value set by the map variable combination.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {number} hasTextureIndex - The index of the texture.\r\n     * @param {boolean} [hasTextureIndex=true] - If false then set to -1 (meaning it should not use any texture).\r\n     * @memberof GisplayMap\r\n     */\r\n    setTextureIndex(mvc, hasTextureIndex = true) {\r\n        const gl = this._webgl.gl;\r\n        const fragmentTextureIndexLocation = gl.getUniformLocation(this._webgl.program, this.shadersInfo.getTextureName()); // PATTERN INDEX\r\n        gl.uniform1i(fragmentTextureIndexLocation, hasTextureIndex ? mvc.getTexture() : -1);\r\n    }\r\n\r\n    /**\r\n     * Set the frament pattern size value to the default patterns image size. \r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    setTextureSize() {\r\n        const gl = this._webgl.gl;\r\n        const fragmentPatternSize = gl.getUniformLocation(this._webgl.program, 'patternSize'); // PATTERN SIZE (128 or 32 or ...)\r\n        gl.uniform1i(fragmentPatternSize, GisplayDefaults.getPatternImageSize());\r\n    }\r\n\r\n    /**\r\n     * Set the figure index in the fragment shader.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setFigureIndex(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const fragmentFigureIndexLocation = gl.getUniformLocation(this._webgl.program, 'figureIndex'); // FIGURE INDEX\r\n        gl.uniform1i(fragmentFigureIndexLocation, mvc.getFigure());\r\n    }\r\n\r\n    /**\r\n     * Set the orientation in the fragment shader.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @memberof GisplayMap\r\n     */\r\n    setOrientation(mvc) {\r\n        const gl = this._webgl.gl;\r\n        const fragmentOrientationLocation = gl.getUniformLocation(this._webgl.program, this.shadersInfo.getOrientationName()); // ORIENTATION\r\n        gl.uniform1f(fragmentOrientationLocation, mvc.getOrientation());\r\n    }\r\n\r\n    /**\r\n     * Set all points inside the given temporal granule to WebGL at once. \r\n     * @param {TemporalGranule} tg - The temporal granule that contains the points to be drawn. \r\n     * @memberof GisplayMap\r\n     */\r\n    setPoints(tg) {\r\n        const gl = this._webgl.gl;\r\n        let points = tg.getGeometryData();\r\n        // console.error(tg, tg.getNumElements(), points);\r\n        const vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, this.shadersInfo.getPositionName()); //POSITION\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, points);\r\n        gl.enableVertexAttribArray(vertexCoordsLocation);\r\n        gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, GisplayDefaults.getFloat32BytesPerElement() * 2, 0);\r\n        gl.drawArrays(gl.POINTS, 0, tg.getNumElements());\r\n        // console.log(points, tg.getNumElements());\r\n    }\r\n\r\n    /**\r\n     * Set the polygons inside the given temporal granule. \r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn. \r\n     * @memberof GisplayMap\r\n     */\r\n    setPolygons(tg) {\r\n        const gl = this._webgl.gl;\r\n        const vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, this.shadersInfo.getPositionName());// POSITION\r\n        let polygons = this._findTemporalGranuleGeometry(tg);\r\n\r\n        // console.error(\"NUMELMS=\", tg.getNumElements());\r\n\r\n        //Enable the use of 32 bit elements\r\n        gl.getExtension(\"OES_element_index_uint\");\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.allPoints);\r\n        gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(vertexCoordsLocation);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, polygons.polygonsIndices);\r\n        gl.drawElements(gl.TRIANGLES, tg.getNumElements().polygonsIndices, gl.UNSIGNED_INT, 0);\r\n    }\r\n\r\n    /**\r\n     * Set the polygons borders inside the given temporal granule. \r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons borders to be drawn. \r\n     * @memberof GisplayMap\r\n     */\r\n    setPolygonsBorders(tg) {\r\n        const gl = this._webgl.gl;\r\n        const vertexCoordsLocation = gl.getAttribLocation(this._webgl.bordersProgram, this.shadersInfo.getPositionName());\r\n        let polygons = this._findTemporalGranuleGeometry(tg);\r\n\r\n        // console.error(\"NUMELMS=\", tg.getNumElements());\r\n\r\n        // gl.getExtension(\"OES_element_index_uint\");\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.allPoints);\r\n        gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, GisplayDefaults.getFloat32BytesPerElement() * 2, 0);\r\n        gl.enableVertexAttribArray(vertexCoordsLocation);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, polygons.bordersIndices);\r\n        gl.drawElements(gl.LINES, tg.getNumElements().bordersIndices, gl.UNSIGNED_INT, 0);\r\n    }\r\n\r\n    /**\r\n     * Set the lines for the given temporal granule.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons borders to be drawn. \r\n     * @memberof GisplayMap\r\n     */\r\n    setLines(tg) {\r\n        const gl = this._webgl.gl;\r\n        const vertexCoordsLocation = gl.getAttribLocation(this._webgl.program, this.shadersInfo.getPositionName());\r\n        let lines = this._findTemporalGranuleGeometry(tg);\r\n\r\n        gl.getExtension(\"OES_element_index_uint\");\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.allPoints);\r\n        gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, GisplayDefaults.getFloat32BytesPerElement() * 2, 0);\r\n        gl.enableVertexAttribArray(vertexCoordsLocation);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, lines);\r\n        gl.drawElements(gl.LINES, tg.getNumElements(), gl.UNSIGNED_INT, 0);\r\n    }\r\n\r\n    /**\r\n     * Returns the indices of the active temporal granules.\r\n     * @returns {Array<number>|number}\r\n     * @memberof GisplayMap\r\n     */\r\n    getActiveTemporalGranules() {\r\n        return this.layoutManager.getTimeControl() ? this.layoutManager.getActiveTemporalGranules() : [0];\r\n    }\r\n\r\n    /**\r\n     * Find temporal granule geometry. If there's geometry ids then look for each id on the geometry ids map otherwise get it directly from the temporal granule.\r\n     * @param {TemporalGranule} tg - The temporal granule. \r\n     * @returns {Polygon|Array<Array<number>>} - the temporal granule geometry.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _findTemporalGranuleGeometry(tg) {\r\n        let geometryData = tg.getGeometryData();\r\n        return geometryData;\r\n        /* if (!this.urlVariable.hasIds())\r\n            return geometryData;\r\n        else {\r\n            let elems = []; //Points, Polygons or lines\r\n            if (this.urlVariable.hasIds()) //REMOVE IF @TODO\r\n                for (let elem of geometryData) {\r\n                    if (this.geometryIdsMap.get(elem[0]) === undefined)\r\n                        console.log(elem, \"COUNTRY? DOES NOT EXIST IN DATASET\", this.geometryIdsMap.get(elem[0]));\r\n                    elems.push(this.geometryIdsMap.get(elem[0]));\r\n                }\r\n            return elems;\r\n        } */\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #######################     WEBGL PICKING      ######################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Callback for the user click on the map.\r\n     * @param {number} lng - Longitude of the click event. \r\n     * @param {number} lat - Latitude of the click event.\r\n     * @memberof GisplayMap\r\n     */\r\n    clickEvent(clickX, clickY, bgmap) {//lng, lat, zoom, bgmap) {\r\n        // console.log(\"CLICK\");\r\n        this.drawPickingData(clickX, clickY, bgmap);\r\n    }\r\n\r\n    /**\r\n     * Draw picking data.\r\n     * First create a texture to draw the picking data. \r\n     * Then draw the picking data in the texture.\r\n     * After that, look for the clicked pixel on the texture and read it's information (RGBA color).\r\n     * Now with the RGBA id, search the MapVariableCombination that contains the Red color.\r\n     * With the result show a tooltip in the clicked position.\r\n     * @param {number} clickX - The x position that was clicked on the background map.\r\n     * @param {number} clickY - The y position that was clicked on the background map.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click event happened.\r\n     * @see https://github.com/FarhadG/webgl-picking\r\n     * @see https://stackoverflow.com/a/15064957 - Read pixels from texture\r\n     * @see http://www.realtimerendering.com/blog/webgl-2-basics/\r\n     * @memberof GisplayMap\r\n     */\r\n    drawPickingData(clickX, clickY, bgmap) {\r\n        console.time('picking');\r\n        console.time('drawPicking');\r\n        const gl = this._webgl.gl;\r\n        let [width, height] = [bgmap.getWidth(), bgmap.getHeight()];\r\n        let [nextWidth, nextHeight] = bgmap.calcNextPowerOfTwo();\r\n\r\n        gl.disable(gl.BLEND);\r\n\r\n        //Create frameBuffer\r\n        let framebuffer = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer); // This is the buffer where we will draw from now on\r\n\r\n        //Create texture to be used to draw the picking data\r\n        let texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, nextWidth, nextHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n        gl.viewport(0, 0, nextWidth, nextHeight); //Viewport for the texture\r\n\r\n        let texture2 = gl.createTexture(); //Refazer o desenho se n der\r\n        gl.bindTexture(gl.TEXTURE_2D, texture2);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, nextWidth, nextHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, texture2, 0);\r\n        gl.viewport(0, 0, nextWidth, nextHeight); //Viewport for the texture\r\n\r\n        gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]); // http://www.realtimerendering.com/blog/webgl-2-basics/\r\n\r\n        let textureViewPort = [0, 0, nextWidth, nextHeight];\r\n        this._drawToTexture(textureViewPort, bgmap);\r\n\r\n        console.timeEnd('drawPicking');\r\n\r\n        // console.log(\"HERE\");\r\n        let clickTextureX = clickX * nextWidth / width;\r\n        let clickTextureY = nextHeight - (clickY * nextHeight / height);\r\n\r\n        console.time('readPixels');\r\n        let pixels = new Uint8Array(4);\r\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer);\r\n        gl.readBuffer(gl.COLOR_ATTACHMENT0); // https://stackoverflow.com/a/45573301\r\n        gl.readPixels(clickTextureX, clickTextureY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\r\n        console.log(\"Pixels\", pixels);\r\n        console.timeEnd('readPixels');\r\n\r\n        let pixelsMVCTG = new Uint8Array(4);\r\n        gl.readBuffer(gl.COLOR_ATTACHMENT1);\r\n        gl.readPixels(clickTextureX, clickTextureY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelsMVCTG);\r\n        console.log(\"Pixels MVCTG\", pixelsMVCTG);\r\n\r\n        console.time('searchPicked');\r\n\r\n        let message = this._searchMVC(pixelsMVCTG, pixels);\r\n        if (message)\r\n            this.layoutManager.createToolTip(clickX, clickY, bgmap, message);\r\n\r\n        if (window.a) {\r\n            let imageData = new Uint8Array(nextWidth * nextHeight * 4);\r\n            gl.readPixels(0, 0, nextWidth, nextHeight, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\r\n            console.log(imageData);\r\n            this.countColors(imageData);\r\n\r\n            // this.saveTextureToImage(imageData, nextWidth, nextHeight, clickTextureX, clickTextureY);\r\n        }\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null); //Go back to original FrameBuffer.\r\n\r\n        console.timeEnd('searchPicked');\r\n        console.timeEnd('picking');\r\n    }\r\n\r\n    /**\r\n     * Given the RGBA color, then search the respective picking element, if any. \r\n     * The value is converted to it's integer representation that it's then used to compare with all the picking colors in each\r\n     * temporal granule of each of the enabled map variable combinations.\r\n     * To quickly find the right map variable combination, the value of the given RGBA is compared with the start RGBA and end RGBA of each map variable combination.\r\n     * Upon finding the correct map variable combination, then just loop over each active temporal granule and look for the picked element.\r\n     * @todo Create binarySearch method to look for the picked color faster. Since the generated colors are sequencial this is can be implemented.\r\n     * @param {number} r - The red color value. \r\n     * @param {number} g - The green color value. \r\n     * @param {number} b - The blue color value. \r\n     * @param {number} a - The alpha color value. \r\n     * @returns {string} - The information of the picked element, if any.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _searchMVC(MVCTG, clickedRGBA) {\r\n        let MVC = [0, 0, MVCTG[0], MVCTG[1]];\r\n        let TG = [0, 0, MVCTG[2], MVCTG[3]];\r\n        let numMVC = GisplayDefaults.RGBAToNumber(...MVC);\r\n        let numTG = GisplayDefaults.RGBAToNumber(...TG);\r\n        if (numMVC !== 0 && numTG !== 0) {\r\n            // console.log(numMVC, numTG);\r\n            numMVC--; //The ids started at 1 then we want to subtract 1\r\n            numTG--;//The ids started at 1 then we want to subtract 1\r\n            // console.log(numMVC, numTG);\r\n\r\n            let numRGBA = GisplayDefaults.RGBAToNumber(...clickedRGBA);\r\n            let pickedTG = this.mapVariableCombinations[numMVC].temporalGranules[numTG];\r\n            let pickedTGData = pickedTG.getPickingData();\r\n            let pickedIndex = pickedTGData.findColorIndex(numRGBA, this.urlVariable.hasIds());\r\n            // console.log(numRGBA, pickedTGData, pickedIndex);\r\n            if (pickedIndex === -1)\r\n                console.error(\"Something went wrong... It shouldn't end up here\");\r\n            else\r\n                return this.generateToolTipInformation(pickedTG, pickedIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the message to be shown to the user in the tooltip message.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the element that was clicked.\r\n     * @param {number} index - The index inside the picking data for the given temporal granule in the map variable combination. \r\n     * @returns {string} - the message to be shown to the user in the tooltip message.\r\n     * @memberof GisplayMap\r\n     */\r\n    generateToolTipInformation(tg, index) {\r\n        // console.log(\"index of picked element = \", index);\r\n\r\n        let resMessage = '';\r\n\r\n        let continuousInfo = tg.getPickingData().getIndexContinuousData(index);\r\n        let optionalData = tg.getPickingData().getIndexOptionalData(index);\r\n\r\n        // console.warn(tg.getPickingData());\r\n        // console.warn(pickingInfo, index);\r\n\r\n        for (let [i, opt] of this.optionalVariables.entries())\r\n            resMessage += opt.getInternalName() + ':' + optionalData[i] + '\\n';\r\n\r\n        for (let [i, contVar] of this.continousVariables.entries())\r\n            resMessage += contVar.getInternalName() + ':' + continuousInfo[i] + '\\n';\r\n\r\n        // console.log(mvc.getMapVariablesValues());\r\n        // console.log(resMessage);\r\n\r\n        if (!resMessage) // No Optional variables nor continuous variables, only categorical\r\n            resMessage = 'See Legend for categorical variable information';\r\n        return resMessage;\r\n    }\r\n\r\n    /**\r\n     * Execute the draw operation like it would be done for the screen but now using the picking colors.\r\n     * @param {Array<number>} textureViewPort - The viewport to draw to. \r\n     * @param {BGMapWrapper} bgmap - The background map where the click event happened.\r\n     * @memberof GisplayMap\r\n     */\r\n    _drawToTexture(textureViewPort, bgmap) {\r\n        console.error(\"draw to Texture\");\r\n\r\n        let granulesIndices = this.getActiveTemporalGranules();\r\n        for (let mvc of this.mapVariableCombinations) {\r\n            if (mvc.isEnabled()) {\r\n                let mvcTemporalGranules = mvc.getTemporalGranules();\r\n                for (let index of granulesIndices) {\r\n                    let tg = mvcTemporalGranules[index];\r\n                    if (tg.hasElements())\r\n                        this.drawPicking(mvc, tg, bgmap, textureViewPort);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Similar to initialDrawSetup(...) but in this case for picking.\r\n     * @param {MapVariableCombination} mvc - The map variable combination\r\n     * @param {BGMapWrapper} bgmap - The background map where we want to draw.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    initialPickingSetup(mvc, bgmap, textureViewPort) {\r\n        const gl = this._webgl.gl;\r\n        gl.disable(gl.BLEND);\r\n        // gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n        const PROGRAM = this._webgl.program;\r\n        gl.useProgram(PROGRAM);\r\n        if (gl === null)\r\n            return;\r\n\r\n        this._setPickingViewPort(textureViewPort);\r\n        this._setAlphaAndColor(mvc);\r\n        this._setPickingState(true);\r\n        this._setProjectionMatrix(bgmap);\r\n    }\r\n\r\n    /**\r\n     * Set viewport for picking draw.\r\n     * @param {Array<number>} viewport- The viewport of the texture image where the picking data will be drawn.\r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setPickingViewPort(viewport) {\r\n        const gl = this._webgl.gl;\r\n        gl.viewport(...viewport);\r\n        gl.scissor(...viewport);\r\n    }\r\n\r\n    /**\r\n     * Upload all picking colors of the given temporal granule to the GPU.\r\n     * @param {TemporalGranule} tg - The temporal granule where to look for picking colors. \r\n     * @private\r\n     * @memberof GisplayMap\r\n     */\r\n    _setAllPickingColors(tg) {\r\n        const gl = this._webgl.gl;\r\n\r\n        this._setMVCTGIdentifier(tg);\r\n\r\n        let pickingColors = tg.getPickingData().getPickingColors(); //Colors\r\n        const vertexPickingColorLocation = gl.getAttribLocation(this._webgl.program, GisplayDefaults.pickingColorName()); //PICKING COLOR\r\n        console.log(\"vertexPickingColorLocation\", vertexPickingColorLocation, this.allPoints, this.allColors, this.geometryPrimitive);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.allPoints ? this.allColors : pickingColors);\r\n        gl.enableVertexAttribArray(vertexPickingColorLocation);\r\n        gl.vertexAttribPointer(vertexPickingColorLocation, 4, gl.UNSIGNED_BYTE, false, 0, 0);\r\n        return vertexPickingColorLocation;\r\n    }\r\n\r\n    /**\r\n     * Set the identifier for the MVC and TG.\r\n     * @param {TemporalGranule} tg - The temporal granule. \r\n     * @memberof GisplayMap\r\n     */\r\n    _setMVCTGIdentifier(tg) {\r\n        const gl = this._webgl.gl;\r\n        const fragmentColorLocation = gl.getUniformLocation(this._webgl.program, GisplayDefaults.pickingMVCTGIdentifierName()); // COLOR\r\n        gl.uniform4fv(fragmentColorLocation, tg.getRGBAIdentifier());\r\n        console.log(\"ID\", tg.getRGBAIdentifier());\r\n    }\r\n\r\n    /**\r\n     * Set all points and respective colors for picking.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @memberof GisplayMap\r\n     */\r\n    setPickingColorsAndPoints(tg) {\r\n        const gl = this._webgl.gl;\r\n        let vertexPickingColorLocation = this._setAllPickingColors(tg);\r\n        this.setPoints(tg); // POSITION\r\n        gl.disableVertexAttribArray(vertexPickingColorLocation);\r\n    }\r\n\r\n    /**\r\n     * Set all polygons and respective colors for picking.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @memberof GisplayMap\r\n     */\r\n    setPickingColorsAndPolygons(tg) {\r\n        const gl = this._webgl.gl;\r\n        let vertexPickingColorLocation = this._setAllPickingColors(tg);\r\n        this.setPolygons(tg); // POSITION\r\n        gl.disableVertexAttribArray(vertexPickingColorLocation);\r\n    }\r\n\r\n    /**\r\n     * Set all lines and respective colors for picking.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @memberof GisplayMap\r\n     */\r\n    setPickingColorsAndLines(tg) {\r\n        const gl = this._webgl.gl;\r\n        let vertexPickingColorLocation = this._setAllPickingColors(tg);\r\n        this.setLines(tg); // POSITION\r\n        gl.disableVertexAttribArray(vertexPickingColorLocation);\r\n        /* const PROGRAM = this._webgl.program;\r\n\r\n        let pickingColors = tg.getPickingData().getPickingColors(); //Colors\r\n        const vertexPickingColorLocation = gl.getUniformLocation(PROGRAM, GisplayDefaults.pickingColorName());\r\n\r\n        const vertexCoordsLocation = gl.getAttribLocation(PROGRAM, this.shadersInfo.getPositionName());// POSITION\r\n        let lines = this._findTemporalGranuleGeometry(tg);\r\n        let i = 0;\r\n        for (let line of lines) {\r\n            gl.uniform4f(vertexPickingColorLocation, ...pickingColors[i++]); //One color for each line\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, line.lineBuffer);\r\n            gl.enableVertexAttribArray(vertexCoordsLocation);\r\n            gl.vertexAttribPointer(vertexCoordsLocation, 2, gl.FLOAT, false, GisplayDefaults.getFloat32BytesPerElement() * 2, 0);\r\n            gl.drawArrays(gl.LINE_STRIP, 0, line.numElements);\r\n        } */\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    ###################     WEBGL PICKING EXTRAS      ###################\r\n    #####################################################################\r\n    */\r\n    saveTextureToImage(data, width, height, x, y) {\r\n        let canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        let context = canvas.getContext('2d');\r\n\r\n        // this.countColors(data);\r\n        this.redClickedPixels(data, width, height, x, y);\r\n\r\n        // Copy the pixels to a 2D canvas\r\n        let imageData = context.createImageData(width, height);\r\n        imageData.data.set(data);\r\n        context.putImageData(imageData, 0, 0);\r\n        // console.log(imageData);\r\n        let img = new Image();\r\n        img.id = 's1';\r\n        img.src = canvas.toDataURL();\r\n        let w = window.open(\"\"); //https://stackoverflow.com/a/27798235/\r\n        w.document.write(img.outerHTML);\r\n        return img;\r\n    }\r\n\r\n    countColors(data) {\r\n        let colors = [];//new Set();\r\n        for (let i = 0; i < data.length - 4; i++) {\r\n            let color = [];\r\n            for (let j = i; j < i + 4; j++)\r\n                color.push(data[j]);\r\n            // console.log(color);\r\n\r\n            let allEqual = false;\r\n            for (let c of colors) {\r\n                let colorExists = true;\r\n                for (let k = 0; k < 4; k++)\r\n                    if (c[k] !== color[k])\r\n                        colorExists = false;\r\n                allEqual = colorExists;\r\n            }\r\n            if (!allEqual)\r\n                colors.push(color);\r\n        }\r\n        console.warn(\"!= colors in the image are:\", colors);\r\n    }\r\n\r\n    //https://code.tutsplus.com/tutorials/canvas-from-scratch-pixel-manipulation--net-20573\r\n    redClickedPixels(data, w, h, x, y) {\r\n        let roundX = Math.round(x);\r\n        let roundY = Math.round(y);\r\n        let startPos = 4 * roundY * w + 4 * roundX - 4;\r\n        console.log(startPos);\r\n        for (let i = startPos; i < startPos + 100; i++) {\r\n            if (i % 4 === 0 || i % 4 === 3)\r\n                data[i] = 255;\r\n            else\r\n                data[i] = 0;\r\n        }\r\n        /*  data[startPos] = 255;\r\n         data[startPos + 1] = 0;\r\n         data[startPos + 2] = 0;\r\n         data[startPos + 3] = 255; */\r\n\r\n        for (let i = 0; i < 10000; i++) {\r\n            if (i % 4 === 0 || i % 4 === 3)\r\n                data[i] = 255;\r\n            else\r\n                data[i] = 0;\r\n        }\r\n        /*         data[0] = 255;\r\n                data[1] = 0;\r\n                data[2] = 0;\r\n                data[3] = 255; */\r\n\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #####################      ABSTRACT METHODS      ####################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Draw map function. Must be overriden by subclasses.\r\n     * @param {MapVariableCombination} mvc - The combination. \r\n     * @param {TemporalGranule} tg - The temporal granule.\r\n     * @param {BGMapWrapper} bgmap - The background map.\r\n     * @abstract \r\n     * @memberof GisplayMap\r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        throw new Error(`Draw method: draw(${mvc, tg, bgmap}) must be implemented by the subclass.`);\r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        console.warn(`The method to draw the picking data drawPicking(${mvc, tg, bgmap, textureViewPort}) is not required, but if you want to use the picking capabilites then you must implement this method in the subclass`);\r\n    }\r\n\r\n    /**\r\n     * Defaults for each map. Subclasses should override this method.\r\n     * @returns {{color: {numberOfClasses: number, colors: Array<number>}} - the default values for the color (number of classes and colors).\r\n     * @abstract \r\n     * @memberof GisplayMap\r\n     */\r\n    defaults() {\r\n        throw new Error(\"This map has no defaults defined.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential, diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<RGB>>} - the default colors for the map given the number of classes and nature of data.\r\n     * @abstract \r\n     * @memberof GisplayMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        throw new Error(`getDefaultColors(${numClasses, dataNature}) must be overriden by subclasses.`);\r\n    }\r\n\r\n    /**\r\n     * Returns the available visual variables for this map.\r\n     * @returns {Array<string>} - the available visual variables for this map.\r\n     * @abstract\r\n     * @memberof GisplayMap\r\n     */\r\n    getAvailableVisualVariables() {\r\n        throw new Error(\"Sub classes of GisplayMap must implement getAvailableVisualVariables() method which should return the list of available visual varialbes for the map.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}}\r\n     * @memberof GisplayMap\r\n     */\r\n    getShadersFileNames() {\r\n        throw new Error(\"Sub classes of GisplayMap must implement getShadersFileNames() method which should return the vertex and fragment shader file name.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the avialable time controls for the thematic map.\r\n     * @returns {Array<string>}\r\n     * @memberof GisplayMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        throw new Error(\"Sub classes of GisplayMap must implement getAvailableTemporalControls() method which should return the availabe temporal controls.\");\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    #####################       GOLBAL METHODS       ####################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the information about the shaders that will be used for this map.\r\n     * @returns {ShadersInfo} - the information about the shaders that will be used for this map.\r\n     * @memberof GisplayMap\r\n     */\r\n    getShadersInfo() {\r\n        return this.shadersInfo;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/GisplayMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 359,
    "kind": "class",
    "name": "GisplayMap",
    "memberof": "src/Gisplay/Maps/GisplayMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/GisplayMap.js",
    "importStyle": "{GisplayMap}",
    "description": "This class contains the GisplayMap class which represents the base thematic map of the Gisplay API.",
    "see": [
      "Diogo's thesis pages 57-60 + 64/65"
    ],
    "lineNumber": 27,
    "interface": false
  },
  {
    "__docId__": 360,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#constructor",
    "access": "public",
    "description": "Creates an instance of GisplayMap.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "LIBRARY_LOADED_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#LIBRARY_LOADED_EVENT",
    "access": "public",
    "description": "The name of the library loaded event.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 362,
    "kind": "member",
    "name": "PARSER_ENDED_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#PARSER_ENDED_EVENT",
    "access": "public",
    "description": "The name of the parser ended event.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 363,
    "kind": "member",
    "name": "GEOMETRY_IDS_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#GEOMETRY_IDS_EVENT",
    "access": "public",
    "description": "The name of the event for geometry ids.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 364,
    "kind": "member",
    "name": "SHAPES_IMAGE_LOADED_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#SHAPES_IMAGE_LOADED_EVENT",
    "access": "public",
    "description": "The shapes image loaded event.\nNeeded, otherwise could cause the error: https://github.com/jywarren/webgl-distort/issues/4",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 365,
    "kind": "member",
    "name": "PATTERNS_IMAGE_LOADED_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#PATTERNS_IMAGE_LOADED_EVENT",
    "access": "public",
    "description": "The patterns image loaded event.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 366,
    "kind": "member",
    "name": "FIGURES_IMAGE_LOADED_EVENT",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#FIGURES_IMAGE_LOADED_EVENT",
    "access": "public",
    "description": "The figures image loaded event.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 367,
    "kind": "member",
    "name": "finishedEvents",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#finishedEvents",
    "access": "public",
    "description": "The finish events for the library load, for parser end, pattern and shapes images and any other that may  be added.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "{libraryLoaded: boolean, parserEnded: boolean, geometryIdsEnd:boolean, shapesImageLoaded:boolean, patternsImageLoaded:boolean, figuresImageLoaded: boolean}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 368,
    "kind": "member",
    "name": "dynamicLoader",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#dynamicLoader",
    "access": "public",
    "description": "The gisplay dynamic loader.",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "GisplayDynamicLoader"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 369,
    "kind": "member",
    "name": "shadersInfo",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#shadersInfo",
    "access": "public",
    "description": "The information about the shaders that will be used for this map.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "ShadersInfo"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 370,
    "kind": "member",
    "name": "gisplayOptions",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#gisplayOptions",
    "access": "public",
    "description": "All the options available in the Gisplay API.",
    "lineNumber": 99,
    "type": {
      "nullable": null,
      "types": [
        "GisplayOptions"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 371,
    "kind": "member",
    "name": "categoricalVariables",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#categoricalVariables",
    "access": "public",
    "description": "All the categorical variables that were created with the given options.",
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "continousVariables",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#continousVariables",
    "access": "public",
    "description": "All the continuous variables that were created with the given options.",
    "lineNumber": 109,
    "type": {
      "nullable": null,
      "types": [
        "Array<ContinuousVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "timeVariable",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#timeVariable",
    "access": "public",
    "description": "The time variable or null if there's no Time in the dataset.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "TimeVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "urlVariable",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#urlVariable",
    "access": "public",
    "description": "The URLVariable.",
    "lineNumber": 119,
    "type": {
      "nullable": null,
      "types": [
        "URLVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "bgMaps",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#bgMaps",
    "access": "public",
    "description": "Holds the background maps.",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "Array<BGMapWrapper>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "_webgl",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_webgl",
    "access": "private",
    "description": "Holds reference to WebGL context and program.",
    "see": [
      "Diogo's thesis page 64+"
    ],
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "{gl: WebGLRenderingContext, program: WebGLProgram, bordersProgram: WebGLProgram}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "layoutManager",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#layoutManager",
    "access": "public",
    "description": "The layout manager. ",
    "lineNumber": 138,
    "type": {
      "nullable": null,
      "types": [
        "LayoutManager"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "legends",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#legends",
    "access": "public",
    "description": "Holds all the existing Legends.",
    "lineNumber": 143,
    "type": {
      "nullable": null,
      "types": [
        "Array<Legend>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "optionalVariables",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#optionalVariables",
    "access": "public",
    "description": "An array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable.",
    "lineNumber": 149,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "geometryVariables",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#geometryVariables",
    "access": "public",
    "description": "The geometry variables (longitude and latitude).",
    "lineNumber": 155,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "mapVariableCombinations",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#mapVariableCombinations",
    "access": "public",
    "description": "All the Visual Variable Combinations that exist in this map. Read and processed from the dataset.",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "Array<MapVariableCombination>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 382,
    "kind": "member",
    "name": "mapVariableCombinationToIndexMap",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#mapVariableCombinationToIndexMap",
    "access": "public",
    "description": "Map where each key is a combination string and it's value is the index of it's position in the visual variable combinations array.",
    "lineNumber": 167,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "geometryIdsMap",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#geometryIdsMap",
    "access": "public",
    "description": "The map with ids and their respective geometry.",
    "lineNumber": 172,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, Polygon|Array<number>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "_setupCustomEventListenners",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setupCustomEventListenners",
    "access": "private",
    "description": "Sets up a listener for each existing custom event.",
    "lineNumber": 203
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "_setupGeometryIdsEventListenner",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setupGeometryIdsEventListenner",
    "access": "private",
    "description": "Setup a listener for geometry ids event, if the geometry was given by ids.",
    "lineNumber": 217
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "startDynamicLoader",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#startDynamicLoader",
    "access": "public",
    "description": "Start the Gisplay dynamic loader, responsible to load multiple elements of the Gisplay API.",
    "lineNumber": 230,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{GisplayDynamicLoader} - the GisplayDynamicLoader object created."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryName",
        "description": "The name of the background map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GisplayDynamicLoader"
      ],
      "spread": false,
      "description": "the GisplayDynamicLoader object created."
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "loadGisplayOptions",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#loadGisplayOptions",
    "access": "public",
    "description": "Loads user and default options. For each case if it isn't provided by the user, then it uses\nthe default option. 1st method to be called.",
    "lineNumber": 245,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{GisplayOptions} - the processed gisplay options."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GisplayOptions"
      ],
      "spread": false,
      "description": "the processed gisplay options."
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "setupWebGL",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setupWebGL",
    "access": "public",
    "description": "Sets up WebGL.",
    "lineNumber": 253
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "readFiles",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#readFiles",
    "access": "public",
    "description": "Read the data file, and if it exists the geospatial information.",
    "lineNumber": 268
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "receiveParserData",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#receiveParserData",
    "access": "public",
    "description": "Receives the parsed data.",
    "lineNumber": 287,
    "params": [
      {
        "nullable": null,
        "types": [
          "{mapVariableCombinations: Array<MapVariableCombination>, mapVariableCombinationToIndexMap:Map<string, number>, categoricalVariables: Array<CategoricalVariable>, continousVariables:Array<ContinuousVariable>, allPoints: WebGLBuffer}"
        ],
        "spread": false,
        "optional": false,
        "name": "detail",
        "description": "The custom event (parserEnd) data."
      }
    ]
  },
  {
    "__docId__": 396,
    "kind": "member",
    "name": "allPoints",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#allPoints",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true
  },
  {
    "__docId__": 397,
    "kind": "member",
    "name": "allColors",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#allColors",
    "access": "public",
    "description": null,
    "lineNumber": 295,
    "undocument": true
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "receiveParserGeometryIds",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#receiveParserGeometryIds",
    "access": "public",
    "description": "Receives the parsed ids and their respective geometry.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometryIdsMap: Map<string, any>, allPoints: WebGLBuffer, geometryPrimitive: number}"
        ],
        "spread": false,
        "optional": false,
        "name": "detail",
        "description": "The custom event (parserEnd) data."
      }
    ]
  },
  {
    "__docId__": 402,
    "kind": "member",
    "name": "geometryPrimitive",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#geometryPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 310,
    "undocument": true
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "initialSetup",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#initialSetup",
    "access": "public",
    "description": "If all events already ended then it continues the API execution (setup layout, legends, etc), otherwise does nothing.",
    "see": [
      "https://blog.mariusschulz.com/2016/02/10/the-some-and-every-array-methods-in-javascript"
    ],
    "lineNumber": 320,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "The name of the fired event."
      }
    ]
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "generateTGsRGBAIDs",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#generateTGsRGBAIDs",
    "access": "public",
    "description": "Generates the RGBA identifiers for each Map Variable combination and for each Temporal Granule.",
    "lineNumber": 354
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "replaceIdsWithGeometry",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#replaceIdsWithGeometry",
    "access": "public",
    "description": "When the GeoJSONIdsParser is used, we can replace the data that it processed. This data can be used directly by each temporal granule.\nThis method replaces the ids with the actual geometry and then continues the process by joining the picking colors etc.",
    "lineNumber": 372
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "printInfo",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#printInfo",
    "access": "public",
    "description": null,
    "lineNumber": 395,
    "undocument": true
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "setupBGMapsLayout",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setupBGMapsLayout",
    "access": "public",
    "description": "Sets up the layout manager for this instance of the Gisplay API.",
    "lineNumber": 422
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "setupTimeControl",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setupTimeControl",
    "access": "public",
    "description": "Creates the time control.",
    "lineNumber": 431
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "setupLegends",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setupLegends",
    "access": "public",
    "description": "Creates all the legends needed for this thematic map.",
    "lineNumber": 440
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "setupInteractionEvents",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setupInteractionEvents",
    "access": "public",
    "description": "Setup all interaction events used by the Gisplay API. \nThe existing events are pan (drag), zoom, and click on the background map plus the methods for\nthe time control change, legend change and for the resize of the window.\nThis events will be fired by the background map provider and we can use them to draw(zoom and pan) or alert information(click).",
    "lineNumber": 462
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "legendChangedEvent",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#legendChangedEvent",
    "access": "public",
    "description": "Called when any legend state changes.",
    "lineNumber": 485
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "clear",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#clear",
    "access": "public",
    "description": "Clear current buffers to preset values.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/clear"
    ],
    "lineNumber": 518
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "drawToMap",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawToMap",
    "access": "public",
    "description": "This method is used to draw to the background map. For each enabled map variable combination goes over each \nactive temporal granule and draws all it's geometry with the respective information.",
    "lineNumber": 530
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "drawPoints",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawPoints",
    "access": "public",
    "description": "The new method to draw points.",
    "lineNumber": 577,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "drawProportionalSymbols",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawProportionalSymbols",
    "access": "public",
    "description": "Draw proportion symbols.",
    "see": [
      "https://stats.stackexchange.com/a/144342",
      "http://devdocs.io/dom/webglrenderingcontext/vertexattribpointer"
    ],
    "lineNumber": 605,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map"
      }
    ]
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "drawFigures",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawFigures",
    "access": "public",
    "description": "Draw figures.",
    "see": [
      "https://stats.stackexchange.com/a/144342",
      "http://devdocs.io/dom/webglrenderingcontext/vertexattribpointer"
    ],
    "lineNumber": 637,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map"
      }
    ]
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "drawPolygons",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawPolygons",
    "access": "public",
    "description": "The new method to draw Polygons.",
    "lineNumber": 673,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination"
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "drawBorders",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawBorders",
    "access": "public",
    "description": "The new method to draw Borders.",
    "see": [
      "https://stackoverflow.com/a/9153755/ - Use program"
    ],
    "lineNumber": 700,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination"
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "drawLines",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawLines",
    "access": "public",
    "description": "The new method to draw Lines.",
    "see": [
      "http://www3.ntu.edu.sg/home/ehchua/programming/opengl/images/GL_GeometricPrimitives.png"
    ],
    "lineNumber": 722,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination"
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "initialDrawSetup",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#initialDrawSetup",
    "access": "public",
    "description": "Initial setup for the draw operation. All draw operations should first call this method. \nSets the program to use, the viewport, the alpha and color, the picking state and the projection matrix. ",
    "lineNumber": 750,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination"
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "useBordersProgram",
        "description": "Should use the borders program and color or not."
      }
    ]
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "_setViewport",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setViewport",
    "access": "private",
    "description": "Set the viewport for normal draw.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/viewport"
    ],
    "lineNumber": 774,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "_setAlphaAndColor",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setAlphaAndColor",
    "access": "private",
    "description": "Set the alpha and color values in the fragment shader.",
    "lineNumber": 788,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "useBordersProgram",
        "description": "Should use the borders program and color or not."
      }
    ]
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "_setPickingState",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setPickingState",
    "access": "private",
    "description": "Set the picking state. 1 if we want to draw the picking data, 0, otherwise.",
    "lineNumber": 804,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isEnabled",
        "description": "Enable or disable isPicking in the fragment shader."
      }
    ]
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "_setProjectionMatrix",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setProjectionMatrix",
    "access": "private",
    "description": "This method will set the projection matrix to be used to convert the sent lat/lng points/vertices into WebGL coordinates.",
    "lineNumber": 817,
    "params": [
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map wrapper."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "useBordersProgram",
        "description": "Use the borders program or not."
      }
    ]
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "createImageTexture",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#createImageTexture",
    "access": "private",
    "description": "Creates a texture with the image that contains the shapes, figures or patterns.\nIf it's a dot or prop symbols then load shapes image.\nElse if it's a figures map load the figures image.\nElse if it's a polygons map load the patterns image.",
    "lineNumber": 842,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "GisplayDefaults.SHAPE()",
        "defaultRaw": "GisplayDefaults.SHAPE()",
        "name": "imageType",
        "description": "The type of image to load."
      }
    ]
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "setShapeIndex",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setShapeIndex",
    "access": "private",
    "description": "Set the shape index value in the fragment shader.",
    "lineNumber": 868,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "setSizeUniform",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setSizeUniform",
    "access": "private",
    "description": "Set the size location in the vertex shader when the type of the variable is uniform. ",
    "lineNumber": 880,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 430,
    "kind": "method",
    "name": "setSizeAttributeUnique",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setSizeAttributeUnique",
    "access": "private",
    "description": "Set the size location in the vertex shader when the type of the variable is attribute but we \nonly want to use a single value to identify all elements (meaning all elements have the same size). ",
    "lineNumber": 893,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "setSizeAttributeMultiple",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setSizeAttributeMultiple",
    "access": "public",
    "description": "Set the size location in the vertex shader when the type of the variable is attribute and each element\nwill have it's own size.",
    "lineNumber": 905,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the information to be drawn."
      }
    ]
  },
  {
    "__docId__": 432,
    "kind": "method",
    "name": "setSizeMinMaxPixels",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setSizeMinMaxPixels",
    "access": "private",
    "description": "Sets the vertex shader min and max pixels uniform values.",
    "lineNumber": 919
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "setSizeMinMaxData",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setSizeMinMaxData",
    "access": "private",
    "description": "Set the vertex shader min and maximum data values.",
    "lineNumber": 935,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "setTextureIndex",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setTextureIndex",
    "access": "public",
    "description": "Set the pattern index in the fragment shader.\nIf the textureIndex parameter is set then it overrides the value set by the map variable combination.",
    "lineNumber": 953,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hasTextureIndex",
        "description": "The index of the texture."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "hasTextureIndex",
        "description": "If false then set to -1 (meaning it should not use any texture)."
      }
    ]
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "setTextureSize",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setTextureSize",
    "access": "private",
    "description": "Set the frament pattern size value to the default patterns image size. ",
    "lineNumber": 964
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "_setFigureIndex",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setFigureIndex",
    "access": "private",
    "description": "Set the figure index in the fragment shader.",
    "lineNumber": 976,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 437,
    "kind": "method",
    "name": "setOrientation",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setOrientation",
    "access": "public",
    "description": "Set the orientation in the fragment shader.",
    "lineNumber": 987,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      }
    ]
  },
  {
    "__docId__": 438,
    "kind": "method",
    "name": "setPoints",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPoints",
    "access": "public",
    "description": "Set all points inside the given temporal granule to WebGL at once. ",
    "lineNumber": 998,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the points to be drawn."
      }
    ]
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "setPolygons",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPolygons",
    "access": "public",
    "description": "Set the polygons inside the given temporal granule. ",
    "lineNumber": 1015,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      }
    ]
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "setPolygonsBorders",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPolygonsBorders",
    "access": "public",
    "description": "Set the polygons borders inside the given temporal granule. ",
    "lineNumber": 1038,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons borders to be drawn."
      }
    ]
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "setLines",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setLines",
    "access": "public",
    "description": "Set the lines for the given temporal granule.",
    "lineNumber": 1060,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons borders to be drawn."
      }
    ]
  },
  {
    "__docId__": 442,
    "kind": "method",
    "name": "getActiveTemporalGranules",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getActiveTemporalGranules",
    "access": "public",
    "description": "Returns the indices of the active temporal granules.",
    "lineNumber": 1080,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>|number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>",
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "_findTemporalGranuleGeometry",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_findTemporalGranuleGeometry",
    "access": "private",
    "description": "Find temporal granule geometry. If there's geometry ids then look for each id on the geometry ids map otherwise get it directly from the temporal granule.",
    "lineNumber": 1091,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Polygon|Array<Array<number>>} - the temporal granule geometry."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Polygon",
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "the temporal granule geometry."
    }
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "clickEvent",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#clickEvent",
    "access": "public",
    "description": "Callback for the user click on the map.",
    "lineNumber": 1119,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lng",
        "description": "Longitude of the click event."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lat",
        "description": "Latitude of the click event."
      }
    ]
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "drawPickingData",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawPickingData",
    "access": "public",
    "description": "Draw picking data.\nFirst create a texture to draw the picking data. \nThen draw the picking data in the texture.\nAfter that, look for the clicked pixel on the texture and read it's information (RGBA color).\nNow with the RGBA id, search the MapVariableCombination that contains the Red color.\nWith the result show a tooltip in the clicked position.",
    "see": [
      "https://github.com/FarhadG/webgl-picking",
      "https://stackoverflow.com/a/15064957 - Read pixels from texture",
      "http://www.realtimerendering.com/blog/webgl-2-basics/"
    ],
    "lineNumber": 1139,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "clickX",
        "description": "The x position that was clicked on the background map."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "clickY",
        "description": "The y position that was clicked on the background map."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click event happened."
      }
    ]
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "_searchMVC",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_searchMVC",
    "access": "private",
    "description": "Given the RGBA color, then search the respective picking element, if any. \nThe value is converted to it's integer representation that it's then used to compare with all the picking colors in each\ntemporal granule of each of the enabled map variable combinations.\nTo quickly find the right map variable combination, the value of the given RGBA is compared with the start RGBA and end RGBA of each map variable combination.\nUpon finding the correct map variable combination, then just loop over each active temporal granule and look for the picked element.",
    "lineNumber": 1225,
    "todo": [
      "Create binarySearch method to look for the picked color faster. Since the generated colors are sequencial this is can be implemented."
    ],
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The information of the picked element, if any."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "The red color value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "g",
        "description": "The green color value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "The blue color value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "The alpha color value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The information of the picked element, if any."
    }
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "generateToolTipInformation",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#generateToolTipInformation",
    "access": "public",
    "description": "Returns the message to be shown to the user in the tooltip message.",
    "lineNumber": 1255,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the message to be shown to the user in the tooltip message."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the element that was clicked."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "The index inside the picking data for the given temporal granule in the map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the message to be shown to the user in the tooltip message."
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "_drawToTexture",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_drawToTexture",
    "access": "private",
    "description": "Execute the draw operation like it would be done for the screen but now using the picking colors.",
    "lineNumber": 1286,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport to draw to."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click event happened."
      }
    ]
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "initialPickingSetup",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#initialPickingSetup",
    "access": "public",
    "description": "Similar to initialDrawSetup(...) but in this case for picking.",
    "lineNumber": 1309,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination"
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 450,
    "kind": "method",
    "name": "_setPickingViewPort",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setPickingViewPort",
    "access": "private",
    "description": "Set viewport for picking draw.",
    "lineNumber": 1331,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "viewport-",
        "description": "The viewport of the texture image where the picking data will be drawn."
      }
    ]
  },
  {
    "__docId__": 451,
    "kind": "method",
    "name": "_setAllPickingColors",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setAllPickingColors",
    "access": "private",
    "description": "Upload all picking colors of the given temporal granule to the GPU.",
    "lineNumber": 1343,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule where to look for picking colors."
      }
    ]
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "_setMVCTGIdentifier",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#_setMVCTGIdentifier",
    "access": "private",
    "description": "Set the identifier for the MVC and TG.",
    "lineNumber": 1362,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      }
    ]
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "setPickingColorsAndPoints",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPickingColorsAndPoints",
    "access": "public",
    "description": "Set all points and respective colors for picking.",
    "lineNumber": 1374,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      }
    ]
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "setPickingColorsAndPolygons",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPickingColorsAndPolygons",
    "access": "public",
    "description": "Set all polygons and respective colors for picking.",
    "lineNumber": 1386,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      }
    ]
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "setPickingColorsAndLines",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#setPickingColorsAndLines",
    "access": "public",
    "description": "Set all lines and respective colors for picking.",
    "lineNumber": 1398,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      }
    ]
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "saveTextureToImage",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#saveTextureToImage",
    "access": "public",
    "description": null,
    "lineNumber": 1425,
    "undocument": true
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "countColors",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#countColors",
    "access": "public",
    "description": null,
    "lineNumber": 1447,
    "undocument": true
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "redClickedPixels",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#redClickedPixels",
    "access": "public",
    "description": null,
    "lineNumber": 1470,
    "undocument": true
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#draw",
    "access": "public",
    "description": "Draw map function. Must be overriden by subclasses.",
    "lineNumber": 1512,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map."
      }
    ],
    "abstract": true
  },
  {
    "__docId__": 460,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 1524,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 461,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#defaults",
    "access": "public",
    "description": "Defaults for each map. Subclasses should override this method.",
    "lineNumber": 1534,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{color: {numberOfClasses: number, colors: Array<number>}} - the default values for the color (number of classes and colors)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{color: {numberOfClasses: number, colors: Array<number>}"
      ],
      "spread": false,
      "description": "the default values for the color (number of classes and colors)."
    },
    "abstract": true
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential, diverging or qualitative). ",
    "lineNumber": 1546,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<RGB>>} - the default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<RGB>>"
      ],
      "spread": false,
      "description": "the default colors for the map given the number of classes and nature of data."
    },
    "abstract": true
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getAvailableVisualVariables",
    "access": "public",
    "description": "Returns the available visual variables for this map.",
    "lineNumber": 1556,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the available visual variables for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the available visual variables for this map."
    },
    "abstract": true
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 1565,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getAvailableTemporalControls",
    "access": "public",
    "description": "Returns the avialable time controls for the thematic map.",
    "lineNumber": 1574,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "getShadersInfo",
    "memberof": "src/Gisplay/Maps/GisplayMap.js~GisplayMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/GisplayMap.js~GisplayMap#getShadersInfo",
    "access": "public",
    "description": "Returns the information about the shaders that will be used for this map.",
    "lineNumber": 1588,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ShadersInfo} - the information about the shaders that will be used for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ShadersInfo"
      ],
      "spread": false,
      "description": "the information about the shaders that will be used for this map."
    }
  },
  {
    "__docId__": 467,
    "kind": "file",
    "name": "src/Gisplay/Maps/LinesMap.js",
    "content": "import { GisplayMap } from './GisplayMap';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * LinesMap implemenetation\r\n * @export\r\n * @class LinesMap\r\n * @extends {GisplayMap}\r\n */\r\nexport class LinesMap extends GisplayMap {\r\n\r\n    /**\r\n     * Creates an instance of LinesMap.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof LinesMap\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Draw the lines for the given combination and temporal granule in the background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.    \r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        // this.drawLines(mvc, tg, bgmap);\r\n        this.initialDrawSetup(mvc, bgmap);\r\n        this.setLines(tg); //Draw the lines \r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof GisplayMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        // this.drawLinesToTexture(mvc, tg, bgmap, textureViewPort);\r\n        this.initialPickingSetup(mvc, bgmap, textureViewPort);\r\n\r\n        this.setPickingColorsAndLines(tg);\r\n    }\r\n\r\n    /**\r\n     * Returns the default values for the color (number of classes and colors).\r\n     * @returns {{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors).\r\n     * @override \r\n     * @memberof LinesMap\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 3;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files.\r\n     * @memberof LinesMap\r\n     */\r\n    getShadersFileNames() {\r\n        return { vertexShaderFileName: 'lines.vert', fragmentShaderFileName: 'lines.frag' };\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of visual variables that are available for this map.\r\n     * @returns {Array<string>} - the list of visual variables that are available for this map.\r\n     * @memberof LinesMap\r\n     */\r\n    getAvailableVisualVariables() {\r\n        return [GisplayDefaults.COLOR()];\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of available temporal controls for this thematic map.\r\n     * @returns {Array<string>} - the list of available temporal controls for this thematic map.\r\n     * @memberof LinesMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        return [GisplayDefaults.INSTANT(), GisplayDefaults.INTERVAL(), GisplayDefaults.ANIMATION()];\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<number>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberof LinesMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        return ColorBrewer.getDefautls('DotMap', numClasses, dataNature || GisplayDefaults.SEQUENTIAL());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/LinesMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 468,
    "kind": "class",
    "name": "LinesMap",
    "memberof": "src/Gisplay/Maps/LinesMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/LinesMap.js",
    "importStyle": "{LinesMap}",
    "description": "LinesMap implemenetation",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LinesMap"
      }
    ],
    "interface": false,
    "extends": [
      "GisplayMap"
    ]
  },
  {
    "__docId__": 469,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#constructor",
    "access": "public",
    "description": "Creates an instance of LinesMap.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#draw",
    "access": "public",
    "description": "Draw the lines for the given combination and temporal granule in the background map.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#defaults",
    "access": "public",
    "description": "Returns the default values for the color (number of classes and colors).",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{color: {numberOfClasses: number, colors: Array<number>}}"
      ],
      "spread": false,
      "description": "the default values for the color (number of classes and colors)."
    },
    "override": true
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": "the name of the vertex and fragment shader files."
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#getAvailableVisualVariables",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of visual variables that are available for this map.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of visual variables that are available for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of visual variables that are available for this map."
    }
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#getAvailableTemporalControls",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of available temporal controls for this thematic map.",
    "lineNumber": 94,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of available temporal controls for this thematic map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of available temporal controls for this thematic map."
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/LinesMap.js~LinesMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/LinesMap.js~LinesMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} Default colors for the map given the number of classes and nature of data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 477,
    "kind": "file",
    "name": "src/Gisplay/Maps/ProportionalSymbolsMap.js",
    "content": "import { GisplayMap } from './GisplayMap';\r\nimport { ColorBrewer } from '../Helpers/ColorBrewer';\r\n\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * Proportional Symbols Map implementation.\r\n */\r\nexport class ProportionalSymbolsMap extends GisplayMap {\r\n\r\n    /**\r\n     * Creates an instance of ProportionalSymbolsMap.\r\n     * @param {Object} parsingOptions - The parsing options.\r\n     * @param {Object} mappingOptions - The mapping options.\r\n     * @param {Object} globalOptions - The globabl options.\r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    constructor(parsingOptions, mappingOptions, globalOptions) {\r\n        super(parsingOptions, mappingOptions, globalOptions);\r\n    }\r\n\r\n    /**\r\n     * Draw the proportional points for the given combination and temporal granule in the background map.\r\n     * @param {MapVariableCombination} mvc - The map variable combination.\r\n     * @param {TemporalGranule} tg - The temporal granule that contains the polygons to be drawn.    \r\n     * @param {MapVariableCombination} bgmap - The background map where we want to draw.    \r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    draw(mvc, tg, bgmap) {\r\n        // console.time(\"draw\");\r\n        // this.drawProportionalSymbols(mvc, tg, bgmap);\r\n        // console.timeEnd(\"draw\");\r\n        this.initialDrawSetup(mvc, bgmap);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values\r\n        this.setSizeMinMaxData(mvc); //Min and max data values\r\n        this.setSizeAttributeMultiple(tg); //SIZE\r\n        this.setPoints(tg); //POSITION POINTS\r\n    }\r\n\r\n    /**\r\n     * The method to be called to draw the picking data after a click on the background map.\r\n     * @param {MapVariableCombination} mvc - The MapVariableCombination to use.\r\n     * @param {TemporalGranule} tg - The temporal granule to be used.\r\n     * @param {BGMapWrapper} bgmap - The background map where the click happened.\r\n     * @param {Array<number>} textureViewPort - The viewport of the texture, where we want to draw the picking data. \r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    drawPicking(mvc, tg, bgmap, textureViewPort) {\r\n        // this.drawProportionalSymbolsToTexture(mvc, tg, bgmap, textureViewPort);\r\n        this.initialPickingSetup(mvc, bgmap, textureViewPort);\r\n\r\n        this.createImageTexture();\r\n        this.setShapeIndex(mvc); // SHAPE INDEX\r\n        this.setSizeMinMaxPixels(); //Min and max pixels default values\r\n        this.setSizeMinMaxData(mvc); //Min and max data values\r\n        this.setSizeAttributeMultiple(tg); //SIZE all elems\r\n\r\n        this.setPickingColorsAndPoints(tg);\r\n    }\r\n\r\n    /**\r\n     * Returns the default values for the color (number of classes and colors).\r\n     * @returns {{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors).\r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    defaults() {\r\n        let numberOfClasses = 3;\r\n        return {\r\n            color: {\r\n                numberOfClasses: numberOfClasses,\r\n                colors: this.getDefaultColors(numberOfClasses)\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the vertex and fragment shader files.\r\n     * @returns {{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files.\r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    getShadersFileNames() {\r\n        return { vertexShaderFileName: 'symbols.vert', fragmentShaderFileName: 'symbols.frag' };\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of visual variables that are available for this map.\r\n     * @returns {Array<string>} - the list of visual variables that are available for this map.\r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    getAvailableVisualVariables() {\r\n        return [GisplayDefaults.COLOR(), GisplayDefaults.SHAPE(), GisplayDefaults.SIZE()];\r\n    }\r\n\r\n    /**\r\n     * NOT USED YET\r\n     * Returns the list of available temporal controls for this thematic map.\r\n     * @returns {Array<string>} - the list of available temporal controls for this thematic map.\r\n     * @memberof ProportionalSymbolsMap\r\n     */\r\n    getAvailableTemporalControls() {\r\n        return [GisplayDefaults.INSTANT(), GisplayDefaults.INTERVAL(), GisplayDefaults.ANIMATION()];\r\n    }\r\n\r\n    /**\r\n     * Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). \r\n     * @param {number} numClasses - Number of classes. \r\n     * @param {string} dataNature - Nature of the data.\r\n     * @returns {Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data.\r\n     * @override \r\n     * @memberOf ProportionalSymbolsMap\r\n     */\r\n    getDefaultColors(numClasses, dataNature) {\r\n        return ColorBrewer.getDefautls('ProportionalSymbols', numClasses, dataNature || GisplayDefaults.SEQUENTIAL());\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Maps/ProportionalSymbolsMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 478,
    "kind": "class",
    "name": "ProportionalSymbolsMap",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js",
    "static": true,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Maps/ProportionalSymbolsMap.js",
    "importStyle": "{ProportionalSymbolsMap}",
    "description": "Proportional Symbols Map implementation.",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "src/Gisplay/Maps/GisplayMap.js~GisplayMap"
    ]
  },
  {
    "__docId__": 479,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#constructor",
    "access": "public",
    "description": "Creates an instance of ProportionalSymbolsMap.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "parsingOptions",
        "description": "The parsing options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mappingOptions",
        "description": "The mapping options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "globalOptions",
        "description": "The globabl options."
      }
    ]
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "draw",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#draw",
    "access": "public",
    "description": "Draw the proportional points for the given combination and temporal granule in the background map.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule that contains the polygons to be drawn."
      },
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where we want to draw."
      }
    ]
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "drawPicking",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#drawPicking",
    "access": "public",
    "description": "The method to be called to draw the picking data after a click on the background map.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "MapVariableCombination"
        ],
        "spread": false,
        "optional": false,
        "name": "mvc",
        "description": "The MapVariableCombination to use."
      },
      {
        "nullable": null,
        "types": [
          "TemporalGranule"
        ],
        "spread": false,
        "optional": false,
        "name": "tg",
        "description": "The temporal granule to be used."
      },
      {
        "nullable": null,
        "types": [
          "BGMapWrapper"
        ],
        "spread": false,
        "optional": false,
        "name": "bgmap",
        "description": "The background map where the click happened."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "textureViewPort",
        "description": "The viewport of the texture, where we want to draw the picking data."
      }
    ]
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "defaults",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#defaults",
    "access": "public",
    "description": "Returns the default values for the color (number of classes and colors).",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{color: {numberOfClasses: number, colors: Array<number>}}} - the default values for the color (number of classes and colors)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{color: {numberOfClasses: number, colors: Array<number>}}"
      ],
      "spread": false,
      "description": "the default values for the color (number of classes and colors)."
    }
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "getShadersFileNames",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#getShadersFileNames",
    "access": "public",
    "description": "Returns the name of the vertex and fragment shader files.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{vertexShaderFileName:string, fragmentShaderFileName:string}} - the name of the vertex and fragment shader files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{vertexShaderFileName:string, fragmentShaderFileName:string}"
      ],
      "spread": false,
      "description": "the name of the vertex and fragment shader files."
    }
  },
  {
    "__docId__": 484,
    "kind": "method",
    "name": "getAvailableVisualVariables",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#getAvailableVisualVariables",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of visual variables that are available for this map.",
    "lineNumber": 94,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of visual variables that are available for this map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of visual variables that are available for this map."
    }
  },
  {
    "__docId__": 485,
    "kind": "method",
    "name": "getAvailableTemporalControls",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#getAvailableTemporalControls",
    "access": "public",
    "description": "NOT USED YET\nReturns the list of available temporal controls for this thematic map.",
    "lineNumber": 104,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the list of available temporal controls for this thematic map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the list of available temporal controls for this thematic map."
    }
  },
  {
    "__docId__": 486,
    "kind": "method",
    "name": "getDefaultColors",
    "memberof": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap#getDefaultColors",
    "access": "public",
    "description": "Returns the colors for this map given the number of classes and the nature of the data (sequential,  diverging or qualitative). ",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<RGB>>} Default colors for the map given the number of classes and nature of data."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "ProportionalSymbolsMap"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataNature",
        "description": "Nature of the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<RGB>>"
      ],
      "spread": false,
      "description": "Default colors for the map given the number of classes and nature of data."
    },
    "override": true
  },
  {
    "__docId__": 487,
    "kind": "file",
    "name": "src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "content": "let worker = self;\r\n\r\nimport { DataVariable } from '../../VVs/DataVariable';\r\nimport { URLVariable } from '../../VVs/URLVariable';\r\nimport { TimeVariable } from '../../VVs/TimeVariable';\r\nimport { CategoricalVariable } from '../../VVs/CategoricalVariable';\r\nimport { ContinuousVariable } from '../../VVs/ContinuousVariable';\r\nimport { GisplayDefaults } from '../../GisplayDefaults';\r\n\r\nclass CSVDataWorker {\r\n    constructor() {\r\n        // console.log(\"-------------------CSV Data Worker-------------------\");\r\n        /**\r\n         * The first row read by this data worker.\r\n         * @type {string}\r\n         */\r\n        this.firstWorkerRow = '';\r\n        /**\r\n         * The last row of the last chunk read by the parser.\r\n         * @type {string}\r\n         */\r\n        this.lastWorkerRow = '';\r\n        /**\r\n         * Save the remaining of the last row from the chunk that was read.\r\n         * It's used when a chunk didn't end in a row delimitir character.\r\n         * @type {string}\r\n         */\r\n        this.remainingChunkRow = '';\r\n\r\n        /**\r\n         * The data file.\r\n         * @type {File}\r\n         */\r\n        this.dataFile = null;\r\n        /**\r\n         * The start byte for this worker.\r\n         * @type {number}\r\n         */\r\n        this.startByte = 0;\r\n        /**\r\n         * The end byte for this worker.\r\n         * @type {number}\r\n         */\r\n        this.endByte = 0;\r\n        /**\r\n         * The size of each chunk to read from the file.\r\n         * @type {number}\r\n         */\r\n        this.chunkSize = 0;\r\n        /**\r\n         * The index of this worker. DELETE?\r\n         * @type {number}\r\n         */\r\n        this.workerIndex = -1;\r\n        /**\r\n         * Number of columns for each row. DELETE?\r\n         * @type {number}\r\n         */\r\n        this.numColumnsPerRow = -1; //NOT USED ATM\r\n\r\n        /**\r\n         * The row delimiter.\r\n         * @type {string}\r\n         */\r\n        this.rowDelimiter = '';\r\n        /**\r\n         * The column delimiter.\r\n         * @type {string}\r\n         */\r\n        this.columnDelimiter = '';\r\n\r\n        /**\r\n         * The header indices. \r\n         * The array is split into 5 positions: [0]categorical, [1]continuous, [2]geometry, [3]time and [4]optional variables. \r\n         * @type {Array<Array<number>>}\r\n         */\r\n        this.headerIndices = [];\r\n\r\n        //TIME \r\n        /**\r\n         * The time variable.\r\n         * @type {TimeVariable}\r\n         */\r\n        this.timeVariable = null;\r\n        /**\r\n         * The granularity of the time variable.\r\n         * @type {string}\r\n         */\r\n        this.timeGranularity = '';\r\n\r\n        //CATEGORICAL\r\n        /**\r\n         * The categorical variables present in the user options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\r\n        this.categoricalVariables = [];\r\n        /**\r\n         * If the options contain any categorical variable.\r\n         * @type {boolean}\r\n         */\r\n        this.hasCategoricalVariables = false;\r\n\r\n        //CONTINUOUS\r\n        /**\r\n         * The continuous variables.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\r\n        this.continuousVariables = [];\r\n\r\n        //OPTIONAL\r\n        /**\r\n         * The optional variables.\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.optionalVariables = [];\r\n\r\n        /**\r\n         * The FileReader used to read a portion of the file.\r\n         * @type {FileReader}\r\n         */\r\n        this.reader = this.createFileReader();\r\n        worker.onmessage = (e) => { this.onMessage(e.data); };\r\n\r\n        //SAVE INFORMATION\r\n        /**\r\n         * Used to save the rows directly read from the file\r\n         * @type {Array<Array<string|number>>}\r\n         */\r\n        this.dataRowsSaved = []; //Save rows read by this Worker\r\n        /**\r\n         * The final data rows which contain all information to be sent to the main thread.\r\n         * @type {Array<Array<{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}>>}\r\n         */\r\n        this.finalDataRows = [];\r\n        // this.numRowsRead = 0;\r\n\r\n        /** \r\n         * Will be true when we want to process the last line.\r\n         * @type {boolean}\r\n         */\r\n        this.isLastLine = false;\r\n    }\r\n\r\n    /**\r\n     * Create file reader.\r\n     * @returns {FileReader} - the FileReader used to read a portion of the file.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    createFileReader() {\r\n        let reader = new FileReader();\r\n        reader.onload = (e) => { this.chunkReadFromFile(e); };\r\n        reader.onerror = (e) => { console.error(e); };\r\n        return reader;\r\n    }\r\n\r\n    /**\r\n     * When the worker receives a message. \r\n     * @param {{protocolMessage: string, messageData:Object}} dataMessage - The data message that was sent by the main Thread.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    onMessage(dataMessage) {\r\n        // console.log(\"-------------------CSV Data Worker-------------------\");\r\n        // console.log(dataMessage);\r\n        let protocolMessages = GisplayDefaults.MESSAGES_CSV();\r\n        switch (dataMessage.protocolMessage) {\r\n            case protocolMessages.TO_START: { //Worker processed it's part\r\n                //File and chunk information\r\n                let workerOptions = dataMessage.messageData.workerOptions;\r\n                this.dataFile = workerOptions.dataFile;\r\n                this.startByte = workerOptions.startByte;\r\n                this.endByte = workerOptions.endByte;\r\n                this.chunkSize = workerOptions.chunkSize;\r\n                this.workerIndex = workerOptions.workerIndex;\r\n                this.numColumnsPerRow = workerOptions.numColumnsPerRow;\r\n                this.rowDelimiter = workerOptions.rowDelimiter;\r\n                this.columnDelimiter = workerOptions.columnDelimiter;\r\n                //Indices and class calc\r\n                this.headerIndices = workerOptions.headerIndices;\r\n                //Save Categorical/Continuous and time Vars\r\n                this._saveVariables(dataMessage.messageData.workerOptions);\r\n                //Start reading file\r\n                this.readNextChunk();\r\n                break;\r\n            }\r\n            /*  case protocolMessages.TO_REMAINING_ROWS1: {\r\n                 this.processRows(dataMessage.messageData, 0, dataMessage.messageData.length);\r\n                 worker.postMessage({ protocolMessage: protocolMessages.END_REMAINING_ROWS1 });\r\n                 break;\r\n             } */\r\n            case protocolMessages.TO_LIMITS_CAT: {\r\n                console.log(\"TO_LIMIT_CAT\")\r\n                let catVarsCategoriesMap = new Map();\r\n                for (const catVar of this.categoricalVariables)\r\n                    catVarsCategoriesMap.set(catVar.getInternalName(), catVar.getCategories());\r\n\r\n                let contVarsMinMaxMap = new Map();\r\n                for (const contVar of this.continuousVariables)\r\n                    contVarsMinMaxMap.set(contVar.getInternalName(), [contVar.getMin(), contVar.getMax()]);\r\n\r\n                // console.log(this.workerIndex, catVarsCategoriesMap, contVarsMinMaxMap, this.timeVariable, this.timeVariable.getTemporalGranulesSet())\r\n\r\n                worker.postMessage({\r\n                    protocolMessage: protocolMessages.END_LIMITS_CAT,\r\n                    messageData: {\r\n                        categoricalVariables: catVarsCategoriesMap,\r\n                        continousVariables: contVarsMinMaxMap,\r\n                        timeVariable: this.timeVariable ? this.timeVariable.getTemporalGranulesSet() : this.timeVariable\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_LIMITS_CAT_RES: {\r\n                let continousVarsMinMax = dataMessage.messageData;\r\n                for (let [i, contVar] of this.continuousVariables.entries()) {\r\n                    contVar.setMinMax(continousVarsMinMax[i][0]);\r\n                    contVar.setMinMax(continousVarsMinMax[i][1]);\r\n                    contVar.setStep(); //Update step value\r\n                }\r\n\r\n                //Loop through data and calculate bins for each continuous variable\r\n                let contPosStart = this.categoricalVariables.length;\r\n                let contPosEnd = contPosStart + this.continuousVariables.length;\r\n                for (let data of this.dataRowsSaved)\r\n                    for (let i = contPosStart; i < contPosEnd; i++)\r\n                        this.continuousVariables[i - contPosStart].addValueToBins(data[i]);\r\n\r\n                let histograms = [];\r\n                for (const contVar of this.continuousVariables)\r\n                    histograms.push(contVar.getHistogram());\r\n\r\n                // console.log(this.continuousVariables[0].getHistogram());\r\n\r\n                worker.postMessage({\r\n                    protocolMessage: protocolMessages.END_LIMITS_CAT_RES,\r\n                    messageData: {\r\n                        histograms: histograms\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_JOIN_DATA: {\r\n                //Process data and then send the res data\r\n                if (this.workerIndex === 0) {\r\n                    console.log(\"I will process the data....NOT\")\r\n                    console.log(dataMessage.messageData);\r\n                }\r\n\r\n                let catVars = dataMessage.messageData.categoricalVariables;\r\n                for (const [i, catVar] of catVars.entries())\r\n                    this.categoricalVariables[i].valueToIndexMap = catVar.valueToIndexMap;\r\n\r\n                let contVars = dataMessage.messageData.continuousVariables;\r\n                for (const [i, contVar] of contVars.entries())\r\n                    this.continuousVariables[i].classIntervals = contVar.classIntervals;\r\n\r\n                let tVar = dataMessage.messageData.timeVariable;\r\n                if (tVar)\r\n                    this.timeVariable.temporalGranulesMap = tVar.temporalGranulesMap;\r\n\r\n                let msgData = dataMessage.messageData;\r\n                this._joinData(msgData.mvcs, msgData.numberTGs);\r\n\r\n                //Create array to send information about \r\n\r\n                /*  \r\n                let numElemsArr = []\r\n                    for (let i = 0; i < msgData.mvcs.size; i++) {\r\n                    numElemsArr[i] = [];\r\n                    for (let j = 0; j < msgData.numberTGs; j++)\r\n                        numElemsArr[i][j] = 69;//this.finalDataRows[i][j].continuousData[0].length;\r\n                } */\r\n                let numElemsArr = [];\r\n                console.error(this.finalDataRows);\r\n                if (this.continuousVariables.length > 0) {\r\n                    for (let i = 0; i < msgData.mvcs.size; i++) {\r\n                        numElemsArr[i] = 0;\r\n                        for (let j = 0; j < msgData.numberTGs; j++)\r\n                            numElemsArr[i] += this.finalDataRows[i][j].continuousData[0].length;\r\n                    }\r\n                } else {\r\n                    // throw new Error(\"FUCKED UP\");\r\n                    for (let i = 0; i < msgData.mvcs.size; i++) {\r\n                        numElemsArr[i] = 0;\r\n                        for (let j = 0; j < msgData.numberTGs; j++) {\r\n                            if (this.headerIndices[2].length)\r\n                                numElemsArr[i] += this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\r\n                            else\r\n                                numElemsArr[i] += this.finalDataRows[i][j].spatialData.length; //Ids\r\n                        }\r\n                    }\r\n                }\r\n                console.warn(numElemsArr);\r\n\r\n                worker.postMessage({\r\n                    protocolMessage: protocolMessages.END_JOIN_DATA,\r\n                    messageData: {\r\n                        numElemsPerTG: numElemsArr,\r\n                        workerIndex: this.workerIndex\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_GENERATE_RGBA: {\r\n                // Should Generate RGBAs for all MVCs/TGs \r\n                this._generateRGBACodes(dataMessage.messageData);\r\n                worker.postMessage({ protocolMessage: protocolMessages.END_GENERATE_RGBA });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_SEND_DATA: {\r\n                worker.postMessage({\r\n                    protocolMessage: protocolMessages.END_SEND_DATA,\r\n                    messageData: {\r\n                        finalDataRows: this.finalDataRows\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate RGBA codes for each element in each MVC/TG.\r\n     * @param {Array<Array<number>} RGBAByMVC_TG - The start RGBA code for each MVC/TG. \r\n     * @memberof CSVNewDataWorker\r\n     */\r\n    _generateRGBACodes(RGBAByMVC_TG) {\r\n        let numMVCs = this.finalDataRows.length,\r\n            numTGs = this.finalDataRows[0].length;\r\n        for (let i = 0; i < numMVCs; i++) {\r\n            let startRGBA = RGBAByMVC_TG[i],\r\n                startRGBANum = GisplayDefaults.RGBAToNumber(...startRGBA);\r\n            for (let j = 0; j < numTGs; j++) {\r\n                let numberOfElements = 0;\r\n                if (this.headerIndices[2].length)\r\n                    numberOfElements = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\r\n                else\r\n                    numberOfElements = this.finalDataRows[i][j].spatialData.length; //Ids\r\n                // let continuousDataLength = this.finalDataRows[i][j].continuousData[0].length; //Using continuous data that might not exist\r\n                if (numberOfElements > 0) {\r\n                    for (let k = 0; k < numberOfElements; k++) {\r\n                        let RGBA = GisplayDefaults.numberToRGBA(startRGBANum);\r\n                        this.finalDataRows[i][j].RGBA.push(...RGBA);\r\n                        this.finalDataRows[i][j].numberRGBA.push(startRGBANum++);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.verifyIntegrityRGBA(numMVCs, numTGs);\r\n    }\r\n\r\n    verifyIntegrityRGBA(numMVCs, numTGs) {\r\n        // console.warn(\"VERIFY INTEGRITY\")\r\n        for (let i = 0; i < numMVCs; i++) {\r\n            for (let j = 0; j < numTGs; j++) {\r\n                // let continuousDataLength = this.finalDataRows[i][j].continuousData[0].length;\r\n                let continuousDataLength = 0;\r\n                if (this.headerIndices[2].length)\r\n                    continuousDataLength = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\r\n                else\r\n                    continuousDataLength = this.finalDataRows[i][j].spatialData.length; //Ids\r\n                let first = true;\r\n                if (continuousDataLength > 0)\r\n                    for (let k = 0; k < continuousDataLength - 1; k++) {\r\n                        /* if (first) {\r\n                            first = false;\r\n                            console.log(this.finalDataRows[i][j].numberRGBA[k] + 1, this.finalDataRows[i][j].numberRGBA[k + 1])\r\n                        } */\r\n                        console.assert(this.finalDataRows[i][j].numberRGBA[k] + 1 === this.finalDataRows[i][j].numberRGBA[k + 1])\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join the data into MVCs and TGs.\r\n     * @param {Map<string, number>} mvcs - The generated MVCs map and respective index.\r\n     * @param {number} numberTGs - The number of temporal granules.\r\n     * @memberof CSVNewDataWorker\r\n     */\r\n    _joinData(mvcs, numberTGs) {\r\n        //Loop through rows and copy them to the final array\r\n        //categorical vars and time var can be ignored (they are known by the arrays indices)\r\n        //Save cont vars, geometry, opt vars and RGBA value\r\n\r\n        let hasIds = this.headerIndices[2].length ? false : true;\r\n        let geoPositions = hasIds ? 1 : 2;\r\n\r\n        // console.warn(this.timeVariable, mvcs);\r\n        let numberMVCs = mvcs.size,\r\n            numCatVars = this.categoricalVariables.length,\r\n            numContVars = this.continuousVariables.length,\r\n            geoStartPos = numCatVars + numContVars,\r\n            geoEndPos = geoStartPos + geoPositions,\r\n            timePos = geoEndPos;\r\n\r\n        this.finalDataRows = this._createFinalRows(numberMVCs, numberTGs);\r\n        //For each row saved then split it to its place\r\n        for (const rowSaved of this.dataRowsSaved) {\r\n            let finalRow = [];\r\n            let combination = '';\r\n\r\n            for (let [i, catVar] of this.categoricalVariables.entries())\r\n                combination += catVar.findIndex(rowSaved[i]);\r\n            let contValues = [];\r\n            for (let [j, contVar] of this.continuousVariables.entries()) {\r\n                let contValue = rowSaved[j + numCatVars];\r\n                combination += contVar.findClassIntervalIndex(contValue);\r\n                contValues.push(contValue);\r\n            }\r\n\r\n            let mvcIndex = mvcs.get(combination);\r\n            let tgIndex = this.timeVariable !== undefined ? this.timeVariable.getTGMapIndex(rowSaved[timePos]) : 0;\r\n            if (tgIndex === undefined)\r\n                console.error(\"HERE\")\r\n            for (let i = 0; i < contValues.length; i++)\r\n                this.finalDataRows[mvcIndex][tgIndex].continuousData[i].push(contValues[i]);\r\n            for (let i = geoStartPos; i < geoEndPos; i++)\r\n                this.finalDataRows[mvcIndex][tgIndex].spatialData.push(rowSaved[i]);\r\n            for (let i = timePos + 1; i < rowSaved.length; i++)\r\n                this.finalDataRows[mvcIndex][tgIndex].optionalData[i - timePos - 1].push(rowSaved[i]);\r\n        }\r\n        this.dataRowsSaved = undefined; //Allows Garbage collection\r\n    }\r\n\r\n    /**\r\n     * Create the final row to hold the information that the worker should send at the end to the main thread.\r\n     * @param {number} numberMVCs - Number of existing map variable combinations.\r\n     * @param {number} numberTGs - Number of existing temporal granules . \r\n     * @returns {Array<any>} - the final row to hold the information that the worker should send at the end to the main thread.\r\n     * @memberof CSVNewDataWorker\r\n     */\r\n    _createFinalRows(numberMVCs, numberTGs) {\r\n        let finalRows = [];\r\n\r\n        //Create arrays for optionalData\r\n        let optionalDataArrays = [];\r\n        for (let i = 0; i < this.optionalVariables.length; i++) //Create multiple arrays one for each optional variable\r\n            optionalDataArrays[i] = [];\r\n\r\n        let continuosDataArrays = [];\r\n        for (let i = 0; i < this.continuousVariables.length; i++) //Create multiple arrays one for each optional variable\r\n            continuosDataArrays[i] = [];\r\n\r\n        //Create array for final Rows\r\n        for (let i = 0; i < numberMVCs; i++) {\r\n            finalRows[i] = [];\r\n            for (let j = 0; j < numberTGs; j++) {\r\n                finalRows[i][j] = {\r\n                    continuousData: GisplayDefaults.cloneNestedArray(continuosDataArrays),\r\n                    spatialData: [],\r\n                    optionalData: GisplayDefaults.cloneNestedArray(optionalDataArrays),\r\n                    RGBA: [],\r\n                    numberRGBA: []\r\n                }\r\n            }\r\n        }\r\n        // console.log(finalRows);\r\n        return finalRows;\r\n    }\r\n\r\n    /**\r\n     * Recreate the variables sent by the main thread.\r\n     * @param {{continousVariables: Array<ContinuousVariable>, categoricalVariables: Array<CategoricalVariable>, timeVariable: TimeVariable}} data - Data sent by the main thread.\r\n     * @memberof CSVNewDataWorker\r\n     */\r\n    _saveVariables(data) {\r\n        let contVars = [];\r\n        for (const contVar of data.continuousVariables) {\r\n            console.log(contVar);\r\n            contVars.push(new ContinuousVariable(\r\n                contVar.externalName,\r\n                contVar.internalName,\r\n                contVar.typeOfVisualVariable,\r\n                contVar.shaderVariableQualifier,\r\n                contVar.visualVariableMapping,\r\n                contVar.classBreaks,\r\n                contVar.numberOfClasses,\r\n                contVar.classBreakMethod,\r\n                contVar.classBreakMethodParams\r\n            ));\r\n        }\r\n        // let doa = true;\r\n        // if (doa) {\r\n        let catVars = [];\r\n        for (const catVar of data.categoricalVariables) {\r\n            catVars.push(new CategoricalVariable(\r\n                catVar.externalName,\r\n                catVar.internalName,\r\n                catVar.typeOfVisualVariable,\r\n                catVar.shaderVariableQualifier,\r\n                catVar.visualVariableMapping,\r\n                null\r\n            ));\r\n        }\r\n\r\n        let tVar = data.timeVariable;\r\n        let timeVariable;\r\n        if (tVar !== undefined) {\r\n            timeVariable = new TimeVariable(\r\n                tVar.externalName,\r\n                tVar.internalName,\r\n                tVar.granularity,\r\n                tVar.timeControl\r\n            );\r\n        }\r\n        let optVars = [];\r\n        for (const optVar of data.optionalVariables)\r\n            optVars.push(new DataVariable(optVar.externalName, optVar.internalName));\r\n\r\n        //TIME\r\n        // this.timeVariable = workerOptions.timeVariable;\r\n        this.timeVariable = timeVariable;\r\n        this.timeGranularity = this.timeVariable ? this.timeVariable.getGranularity() : '';\r\n        //CATEGORICAL\r\n        this.categoricalVariables = catVars;//workerOptions.categoricalVariables;\r\n        this.hasCategoricalVariables = this.categoricalVariables.length > 0;\r\n        //CONTINOUS \r\n        this.continuousVariables = contVars;//workerOptions.continuousVariables;\r\n        //OPTIONAL VARS\r\n        this.optionalVariables = optVars;\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Reads a chunk of bytes from the file.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    readNextChunk() {\r\n        let start = Math.min(this.startByte, this.endByte);\r\n        let end = Math.min(this.startByte + this.chunkSize, this.endByte);\r\n        this.reader.readAsText(this.dataFile.slice(start, end));\r\n    }\r\n\r\n    /**\r\n     * Reads more 1000 bytes to finish the last line of the worker.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    readLastLine() {\r\n        if (this.lastWorkerRow.length === 0)\r\n            return true;\r\n        let start = Math.min(this.startByte, this.endByte);\r\n        let end = this.endByte + 1000;\r\n        this.reader.readAsText(this.dataFile.slice(start, end));\r\n    }\r\n\r\n    /**\r\n     * Called after a chunk is read from the file.\r\n     * @param {ProgressEvent} e - Event associated with the read data.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    chunkReadFromFile(e) {\r\n        if (this.isLastLine) {\r\n            // console.warn(\"last line\", this.workerIndex, e.target.result);\r\n            let rows = (this.lastWorkerRow + e.target.result).split(this.rowDelimiter);\r\n            // console.warn(this.workerIndex, rows);\r\n            this.processRows(rows, 0, 1);\r\n            this.sendENDStartMessage();\r\n        } else {\r\n            this.startByte += this.chunkSize;\r\n            this.processChunk(e.target.result);\r\n            if (this.startByte >= this.endByte) {\r\n                // console.log(\"END\");\r\n                // console.log(\"NumRows Worker\", this.workerIndex, \"is:\", this.numRowsRead, \"\\nFIRSTROW = \", this.firstWorkerRow, \"\\nLASTROW = \", this.lastWorkerRow);\r\n                //Post message with first and last row\r\n                // console.warn(\"worker Terminated\", this.workerIndex, this.firstWorkerRow, this.lastWorkerRow);\r\n                this.isLastLine = true;\r\n                let isDone = this.readLastLine();\r\n                if (isDone) //Only the ones that returned true from the readLastLine() method will send back to the \r\n                    this.sendENDStartMessage();\r\n            }\r\n            else\r\n                this.readNextChunk();\r\n        }\r\n    }\r\n\r\n    sendENDStartMessage() {\r\n        console.warn(\"END\", this.workerIndex, this.dataRowsSaved.length);\r\n        worker.postMessage({\r\n            protocolMessage: GisplayDefaults.MESSAGES_CSV().END_START,\r\n            messageData: {\r\n                workerIndex: this.workerIndex,\r\n                // firstWorkerRow: this.firstWorkerRow,\r\n                // lastWorkerRow: this.lastWorkerRow\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Process the chunk that was read from the file.\r\n     * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n     * @see https://image.prntscr.com/image/BkaRp8qSQuyt9phoSh71ZA.png\r\n     * @see https://image.prntscr.com/image/FAQ8CVH9S1W6X0RoZrOWfw.png - Edge case for \\r\\n.\r\n     * @see https://image.prntscr.com/image/yYXWcZwLQjSNYqIiuQEcKQ.png - Edge case example.\r\n     * @param {any} chunkText  - The text read from the file.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    processChunk(chunkText) {\r\n        let rows = (this.remainingChunkRow + chunkText).split(this.rowDelimiter); //May not have the best performance (has to create new string due to string immutability). Could be changed but solution has to solve the EDGE CASE.\r\n        this.remainingChunkRow = rows[rows.length - 1];\r\n        let [startRowIndex, endRowIndex] = [0, rows.length - 1]; //The index to start and end the rows processing\r\n        if (!this.firstWorkerRow) { //Save 1st row of this worker \r\n            this.firstWorkerRow = rows[0];\r\n            startRowIndex = 1; //Ignore first row of first chunk in any worker\r\n        }\r\n        if (!this.lastWorkerRow && this.startByte >= this.endByte) {\r\n            // console.log(this.workerIndex, this.lastWorkerRow);\r\n            this.lastWorkerRow = this.remainingChunkRow; //Save last row if it's the last chunk (See split image) \r\n            // console.log(this.workerIndex, rows, this.dataRowsSaved, this.firstWorkerRow, this.lastWorkerRow);\r\n\r\n            // console.error(this.workerIndex, this.remainingChunkRow);\r\n        }\r\n        this.processRows(rows, startRowIndex, endRowIndex);\r\n    }\r\n\r\n    /**\r\n     * Process the rows that are in the rows array. The first row of the 1st chunk read from the file should be ignored.\r\n     * @param {Array<string>} rows - The rows, each one in a position of the array. \r\n     * @param {number} startRowIndex - The row to start processing.\r\n     * @param {number} endRowIndex - The last row to process.\r\n     * @memberof CSVDataWorker\r\n     */\r\n    processRows(rows, startRowIndex, endRowIndex) {\r\n        let resRows = [];\r\n        // this.numRowsRead += (endRowIndex - startRowIndex); //DELETE\r\n        let categoricalIndices = this.headerIndices[0];\r\n        let continuousIndices = this.headerIndices[1];\r\n        let geometryIndices = this.headerIndices[2];\r\n        let hasIdGeometry = false;\r\n        if (+geometryIndices === +geometryIndices) {\r\n            geometryIndices = [geometryIndices];\r\n            hasIdGeometry = true;\r\n        }\r\n        let timeIndex = this.headerIndices[3];\r\n        let hasTime = this.timeGranularity !== ''; //OR this.timeVariable !== undefined\r\n        let optinalIndices = this.headerIndices[4];\r\n        for (let i = startRowIndex; i < endRowIndex; i++) {\r\n            this.numRowsRead++;\r\n            let columns = rows[i].split(this.columnDelimiter);\r\n            /* if (columns.length !== this.numColumnsPerRow) //Check for errors\r\n                throw new Error(\"Wrong number of columns\");\r\n             */\r\n            let row = [];\r\n\r\n            for (let [i, catIndex] of categoricalIndices.entries()) {\r\n                let category = columns[catIndex];\r\n                if (this.categoricalVariables[i].classCalculationRequired())\r\n                    this.categoricalVariables[i].addCategory(category);\r\n                row.push(category);\r\n            }\r\n\r\n            for (let [i, contIndex] of continuousIndices.entries()) {\r\n                let value = +columns[contIndex];\r\n                /* if (value >= 80000.10)\r\n                    console.warn(\"WUUUT\"); */\r\n                this.continuousVariables[i].setMinMax(value);\r\n                row.push(value); //String to number\r\n            }\r\n\r\n            for (let geoIndex of geometryIndices) {\r\n                if (hasIdGeometry) {\r\n                    let value = columns[geoIndex];\r\n                    if (+value === +value)\r\n                        row.push(+value);\r\n                    else\r\n                        row.push(value.toUpperCase());\r\n                }\r\n                else\r\n                    row.push(+columns[geoIndex]);\r\n            }\r\n\r\n            if (hasTime) {\r\n                let granule = this.getGranule(columns[timeIndex]);\r\n                this.timeVariable.addTemporalGranule(granule);\r\n                this.timeVariable.addTemporalGranuleToSet(granule);\r\n                row.push(granule);\r\n            }\r\n\r\n            for (let optionalIndex of optinalIndices) {\r\n                if (+columns[optionalIndex] === +columns[optionalIndex]) //It's a number?\r\n                    row.push(+columns[optionalIndex]);\r\n                else\r\n                    row.push(columns[optionalIndex]);\r\n            }\r\n            // resRows.push(row);\r\n            this.dataRowsSaved.push(row);\r\n        }\r\n        // console.log(this.workerIndex, this.dataRowsSaved.length);\r\n    }\r\n\r\n    /*  processLastRow() {\r\n         console.log(this.workerIndex, this.dataRowsSaved, this.firstWorkerRow, this.lastWorkerRow);\r\n         if (this.lastWorkerRow.length === 0)\r\n             return;\r\n         else {\r\n             this.readLastLine();\r\n         }\r\n \r\n     } */\r\n\r\n    /**\r\n     * Convert the time string to the granularity we want.\r\n     * @param {string} timeString - The time as it was read from the file. \r\n     * @returns {number} - The granul\r\n     * @memberof CSVDataWorker\r\n     */\r\n    getGranule(timeString) {\r\n        let value;\r\n        // console.warn(timeString, this.timeGranularity);\r\n        /*\r\n        //if cyclic then ...\r\n        day of year -> dayOfYear (n temos )\r\n        month of year -> monthOfYear (temos)\r\n        day of month -> dayOfMonth (temos)\r\n        hour of day -> hourOfDay (temos)\r\n        minute of hour -> minuteOfHour (temos)\r\n        \r\n        //else continuous\r\n        year -> 2015, 2016 ...\r\n        month -> 2015_01, 2015_02 ... 2016_01 etc\r\n        day -> 2015_01_01, 2015_01_02 ...\r\n        hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n        minute\r\n        value\r\n        */\r\n\r\n        switch (this.timeGranularity) {\r\n            //CYCLIC\r\n            case 'monthOfYear': //Mes do ano\r\n                value = (new Date(timeString).getMonth() + 1); //GOOD\r\n                break;\r\n            case 'dayOfYear':\r\n                value = -1; //CHANGE to calculate day of year\r\n                break;\r\n            case 'dayOfMonth':\r\n                value = new Date(timeString).getDate(); //GOOD\r\n                break;\r\n            case 'hourOfDay':\r\n                value = new Date(timeString).getHours(); //GOOD\r\n                break;\r\n            case 'minuteOfHour':\r\n                value = new Date(timeString).getMinutes(); //GOOD\r\n                break;\r\n\r\n            //CONTINUOUS\r\n            case 'year':\r\n                value = new Date(timeString).getFullYear();\r\n                break;\r\n            case 'month': //Mes do ano\r\n                value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\r\n                break;\r\n            case 'day':\r\n                value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\r\n                // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\r\n                break;\r\n            case 'value':\r\n                value = +timeString;\r\n                break;\r\n        }\r\n        // console.log(value);\r\n        return value;\r\n    }\r\n}\r\nnew CSVDataWorker();",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 488,
    "kind": "variable",
    "name": "worker",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "static": true,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~worker",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 489,
    "kind": "class",
    "name": "CSVDataWorker",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "static": true,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/CSV/CSVDataWorker.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 490,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 491,
    "kind": "member",
    "name": "firstWorkerRow",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#firstWorkerRow",
    "access": "public",
    "description": "The first row read by this data worker.",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 492,
    "kind": "member",
    "name": "lastWorkerRow",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#lastWorkerRow",
    "access": "public",
    "description": "The last row of the last chunk read by the parser.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 493,
    "kind": "member",
    "name": "remainingChunkRow",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#remainingChunkRow",
    "access": "public",
    "description": "Save the remaining of the last row from the chunk that was read.\nIt's used when a chunk didn't end in a row delimitir character.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 494,
    "kind": "member",
    "name": "dataFile",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#dataFile",
    "access": "public",
    "description": "The data file.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "File"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 495,
    "kind": "member",
    "name": "startByte",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#startByte",
    "access": "public",
    "description": "The start byte for this worker.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 496,
    "kind": "member",
    "name": "endByte",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#endByte",
    "access": "public",
    "description": "The end byte for this worker.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 497,
    "kind": "member",
    "name": "chunkSize",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#chunkSize",
    "access": "public",
    "description": "The size of each chunk to read from the file.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 498,
    "kind": "member",
    "name": "workerIndex",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#workerIndex",
    "access": "public",
    "description": "The index of this worker. DELETE?",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 499,
    "kind": "member",
    "name": "numColumnsPerRow",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#numColumnsPerRow",
    "access": "public",
    "description": "Number of columns for each row. DELETE?",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 500,
    "kind": "member",
    "name": "rowDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#rowDelimiter",
    "access": "public",
    "description": "The row delimiter.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 501,
    "kind": "member",
    "name": "columnDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#columnDelimiter",
    "access": "public",
    "description": "The column delimiter.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 502,
    "kind": "member",
    "name": "headerIndices",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#headerIndices",
    "access": "public",
    "description": "The header indices. \nThe array is split into 5 positions: [0]categorical, [1]continuous, [2]geometry, [3]time and [4]optional variables. ",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "timeVariable",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#timeVariable",
    "access": "public",
    "description": "The time variable.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "TimeVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 504,
    "kind": "member",
    "name": "timeGranularity",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#timeGranularity",
    "access": "public",
    "description": "The granularity of the time variable.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 505,
    "kind": "member",
    "name": "categoricalVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#categoricalVariables",
    "access": "public",
    "description": "The categorical variables present in the user options.",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 506,
    "kind": "member",
    "name": "hasCategoricalVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#hasCategoricalVariables",
    "access": "public",
    "description": "If the options contain any categorical variable.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 507,
    "kind": "member",
    "name": "continuousVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#continuousVariables",
    "access": "public",
    "description": "The continuous variables.",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "Array<ContinuousVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 508,
    "kind": "member",
    "name": "optionalVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#optionalVariables",
    "access": "public",
    "description": "The optional variables.",
    "lineNumber": 115,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 509,
    "kind": "member",
    "name": "reader",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#reader",
    "access": "public",
    "description": "The FileReader used to read a portion of the file.",
    "lineNumber": 121,
    "type": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 510,
    "kind": "member",
    "name": "dataRowsSaved",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#dataRowsSaved",
    "access": "public",
    "description": "Used to save the rows directly read from the file",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "Array<Array<string|number>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 511,
    "kind": "member",
    "name": "finalDataRows",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#finalDataRows",
    "access": "public",
    "description": "The final data rows which contain all information to be sent to the main thread.",
    "lineNumber": 134,
    "type": {
      "nullable": null,
      "types": [
        "Array<Array<{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 512,
    "kind": "member",
    "name": "isLastLine",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#isLastLine",
    "access": "public",
    "description": "Will be true when we want to process the last line.",
    "lineNumber": 141,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "createFileReader",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#createFileReader",
    "access": "public",
    "description": "Create file reader.",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{FileReader} - the FileReader used to read a portion of the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": "the FileReader used to read a portion of the file."
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "onMessage",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#onMessage",
    "access": "public",
    "description": "When the worker receives a message. ",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "{protocolMessage: string, messageData:Object}"
        ],
        "spread": false,
        "optional": false,
        "name": "dataMessage",
        "description": "The data message that was sent by the main Thread."
      }
    ]
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "_generateRGBACodes",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#_generateRGBACodes",
    "access": "private",
    "description": "Generate RGBA codes for each element in each MVC/TG.",
    "lineNumber": 326,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "RGBAByMVC_TG",
        "description": "The start RGBA code for each MVC/TG."
      }
    ]
  },
  {
    "__docId__": 525,
    "kind": "method",
    "name": "verifyIntegrityRGBA",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#verifyIntegrityRGBA",
    "access": "public",
    "description": null,
    "lineNumber": 351,
    "undocument": true
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "_joinData",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#_joinData",
    "access": "private",
    "description": "Join the data into MVCs and TGs.",
    "lineNumber": 380,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map<string, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "mvcs",
        "description": "The generated MVCs map and respective index."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberTGs",
        "description": "The number of temporal granules."
      }
    ]
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "_createFinalRows",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#_createFinalRows",
    "access": "private",
    "description": "Create the final row to hold the information that the worker should send at the end to the main thread.",
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<any>} - the final row to hold the information that the worker should send at the end to the main thread."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberMVCs",
        "description": "Number of existing map variable combinations."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberTGs",
        "description": "Number of existing temporal granules ."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<any>"
      ],
      "spread": false,
      "description": "the final row to hold the information that the worker should send at the end to the main thread."
    }
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "_saveVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#_saveVariables",
    "access": "private",
    "description": "Recreate the variables sent by the main thread.",
    "lineNumber": 466,
    "params": [
      {
        "nullable": null,
        "types": [
          "{continousVariables: Array<ContinuousVariable>, categoricalVariables: Array<CategoricalVariable>, timeVariable: TimeVariable}"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Data sent by the main thread."
      }
    ]
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "readNextChunk",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#readNextChunk",
    "access": "public",
    "description": "Reads a chunk of bytes from the file.",
    "lineNumber": 528
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "readLastLine",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#readLastLine",
    "access": "public",
    "description": "Reads more 1000 bytes to finish the last line of the worker.",
    "lineNumber": 538
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "chunkReadFromFile",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#chunkReadFromFile",
    "access": "public",
    "description": "Called after a chunk is read from the file.",
    "lineNumber": 551,
    "params": [
      {
        "nullable": null,
        "types": [
          "ProgressEvent"
        ],
        "spread": false,
        "optional": false,
        "name": "e",
        "description": "Event associated with the read data."
      }
    ]
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "sendENDStartMessage",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#sendENDStartMessage",
    "access": "public",
    "description": null,
    "lineNumber": 576,
    "undocument": true
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "processChunk",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#processChunk",
    "access": "public",
    "description": "Process the chunk that was read from the file.",
    "see": [
      "https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Global_Objects/String/split",
      "https://image.prntscr.com/image/BkaRp8qSQuyt9phoSh71ZA.png",
      "https://image.prntscr.com/image/FAQ8CVH9S1W6X0RoZrOWfw.png - Edge case for \\r\\n.",
      "https://image.prntscr.com/image/yYXWcZwLQjSNYqIiuQEcKQ.png - Edge case example."
    ],
    "lineNumber": 597,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "chunkText",
        "description": "The text read from the file."
      }
    ]
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "processRows",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#processRows",
    "access": "public",
    "description": "Process the rows that are in the rows array. The first row of the 1st chunk read from the file should be ignored.",
    "lineNumber": 622,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "rows",
        "description": "The rows, each one in a position of the array."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "startRowIndex",
        "description": "The row to start processing."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "endRowIndex",
        "description": "The last row to process."
      }
    ]
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "getGranule",
    "memberof": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVDataWorker.js~CSVDataWorker#getGranule",
    "access": "public",
    "description": "Convert the time string to the granularity we want.",
    "lineNumber": 706,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The granul"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "timeString",
        "description": "The time as it was read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The granul"
    }
  },
  {
    "__docId__": 549,
    "kind": "file",
    "name": "src/Gisplay/Parser/CSV/CSVParser.js",
    "content": "//Import for Intellisense\r\nimport { DataVariable } from '../../VVs/DataVariable';\r\n\r\nlet CSVDataWorker = require(\"worker-loader?name=CSVDataWorker.js!./CSVDataWorker.js\");\r\nimport { Parser } from '../Parser';\r\nimport { GeoJSONIdsParser } from '../GeoJSON/GeoJSONIdsParser';\r\nimport { GisplayDefaults } from '../../GisplayDefaults';\r\n\r\n/**\r\n * Fast CSV Parser. This parser was created because current parsers that work on the browser do not provide the required performance for this thesis.\r\n * @export\r\n * @class NewCSVParser\r\n * @extends {Parser}\r\n */\r\nexport class CSVParser extends Parser {\r\n    /**\r\n     * \r\n     * @param {GisplayOptions} gisplayOptions - The options class.\r\n     * @param {WebGLRenderingContext} webgl - The WebGLRenderingContext.\r\n     * @memberof NewCSVParser\r\n     */\r\n    constructor(gisplayOptions, webgl) {\r\n        super(gisplayOptions, webgl);\r\n        console.time(\"csvParser\");\r\n\r\n        /**\r\n         * The start byte of the file.\r\n         * @type {number=0}\r\n         */\r\n        this.startByte = 0;\r\n        /**\r\n         * Number of bytes to read at the beginning of the file.\r\n         * @type {number=1024}\r\n         */\r\n        this.headerBytesSize = 1024;\r\n\r\n        //Load Programmer Options\r\n        let csvOpts = this.opts.getCSV();\r\n        /**\r\n         * The size of each chunk to be read from the file. The default is 10MiB. \r\n         * @type {number=1024*1024*10}\r\n         */\r\n        this.chunkSize = csvOpts.chunkSize || 1024 * 1024 * 10;\r\n        /**\r\n         * The char or string that is used to split columns of each row. Defaults is comma.\r\n         * @type {string=','}\r\n         */\r\n        this.columnDelimiter = ',';\r\n        /**\r\n         * The row delimiter. Defaults is \\n.\r\n         * CR = \\r (MAC); LF = \\n (LINUX); CRLF = \\r\\n (WINDOWS) \r\n         * @see https://en.wikipedia.org/wiki/Newline\r\n         * @see http://stackoverflow.com/a/1552782/\r\n         * @see https://stackoverflow.com/a/39259747/\r\n         * @type {string='\\n'}\r\n         */\r\n        this.rowDelimiter = '\\n';\r\n\r\n        let numWorkers = Math.max(Math.floor((this.fileSize / this.chunkSize)), 1);\r\n        numWorkers = numWorkers > 4 ? 4 : numWorkers;\r\n        // numWorkers = 4;\r\n        /**\r\n         * Number of data workers that will process the file in parallel.\r\n         * @type {number=4}\r\n         */\r\n        this.numDataWorkers = csvOpts.numWorkers || numWorkers;\r\n        /**\r\n         * The data workers that will read a portion of the CSV dataset.\r\n         * @type {Array<Worker>}\r\n         */\r\n        this.dataWorkers = new Array(this.numDataWorkers);\r\n        /**\r\n         * Information to be stored for each worker.\r\n         * @type {Array<any>}\r\n         */\r\n        this.dataWorkersInfo = new Array(this.numDataWorkers);\r\n\r\n        //REPLIES\r\n        /**\r\n         * The number of worker that replied with the terminated message.\r\n         * @type {number}\r\n         */\r\n        this.workerTerminatedReplies = 0;\r\n        /**\r\n         * Used to save the first and last rows of each worker after they're done processing their part. \r\n         * @type {Array<Array<string>>}\r\n         */\r\n        this.workerRemainingRows = [];//Array(this.numDataWorkers).fill([]);\r\n\r\n        if (this.urlVariable.hasIds())\r\n            new GeoJSONIdsParser(this.urlVariable.getGeoSpatialURL(), this.urlVariable.getIdOnGeoSpatialURL(), this.webglContext);\r\n\r\n        /**\r\n         * The Filereader.\r\n         * @type {FileReader}\r\n         */\r\n        this.reader = this.createFileReader();\r\n        this.readHeader();\r\n    }\r\n\r\n    /**\r\n     * Code that will be used in the future to decide how many workers to start and the amount of bytes each will have to deal with.\r\n     * @memberof CSVNewParser\r\n     */\r\n    unusedConstructorCode() {\r\n        //Decide num data workers based on file size.\r\n        if (this.numDataWorkers * this.chunkSize > this.fileSize) {\r\n            for (let i = 1, found = false; i < this.numDataWorkers && !found; i++) {//Update numDataworkers\r\n                if (this.chunkSize * i > this.fileSize) {\r\n                    this.numDataWorkers = i;\r\n                    found = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        let chunksByWorker = Math.ceil((this.fileSize / this.numDataWorkers) / this.chunkSize);\r\n        let totalChunks = Math.ceil(chunksByWorker * this.numDataWorkers);\r\n        this.numChunks = totalChunks > 0 ? totalChunks : 1; //NOT USED ATM\r\n    }\r\n\r\n    /**\r\n     * Creates a FileReader object and adds the load and error events to it.\r\n     * @returns {FileReader} - The Filereader object which will be used to read from the file.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    createFileReader() {\r\n        let reader = new FileReader();\r\n        reader.onload = (e) => { this.chunkLoaded(e.target.result); };\r\n        reader.onerror = (e) => { console.error(e); };\r\n        return reader;\r\n    }\r\n\r\n    /**\r\n     * Reads the first 1024 bytes (1KiB) (the value of this.headerBytesSize) of the file.\r\n     * @memberof NewCSVParser\r\n     */\r\n    readHeader() {\r\n        let start = Math.min(this.startByte, this.fileSize);\r\n        let end = Math.min(this.startByte + this.headerBytesSize, this.fileSize - 1);\r\n        this.reader.readAsText(this.dataFile.slice(start, end));\r\n    }\r\n\r\n    /**\r\n     * After the header chunk was loaded then look for \r\n     * @param {string} textRead - The string of text that was read from the file.  \r\n     * @memberof NewCSVParser\r\n     */\r\n    chunkLoaded(textRead) {\r\n        //To detect the rowDelimiter we can calculte the number of \\r, \\n and \\r\\n\r\n        let rowDelimiterDetected = this.detectRowDelimiter(textRead);\r\n        if (!rowDelimiterDetected)\r\n            this.readHeader();\r\n        else {\r\n            if (this.detectColumnDelimiter(textRead))\r\n                this.processHeader(textRead);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detects which is the row delimiter for the file in use.\r\n     * @param {string} textRead - The string of text that was read from the file.  \r\n     * @return {boolean} true, if the row delimiter was detected, false, otherwise.\r\n     * @memberof NewCSVParser\r\n     */\r\n    detectRowDelimiter(textRead) {\r\n        let R = textRead.split('\\r').length;\r\n        let N = textRead.split('\\n').length;\r\n        if (R === N)\r\n            this.rowDelimiter = '\\r\\n';\r\n        else if (R > N)\r\n            this.rowDelimiter = '\\r';\r\n        else\r\n            this.rowDelimiter = '\\n';\r\n\r\n        // logRed(\"R\", R, \"N\", N);\r\n        if (R > 1 && N > 1 && R !== N) //\r\n            throw new Error(`Dataset row delimiter is inconsistent! There are more than 1 row delimited by \\\\r and more than one row delimited by \\\\n. \r\n            Inspect your file with  HxD (https://mh-nexus.de/en/hxd/) and resolve inconsistencies.`);\r\n\r\n        let finalText = textRead.split(this.rowDelimiter);\r\n        if (finalText.length < 2) {\r\n            this.headerBytesSize *= 2;\r\n            console.warn('Not enought bytes read from the file. Attempting to double the number of bytes and trying again...');\r\n            return false;\r\n        }\r\n        else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * Detects the column separator for the file in use.\r\n     * @param {string} textRead - The string of text that was read from the file.  \r\n     * @see https://data-gov.tw.rpi.edu/wiki/CSV_files_use_delimiters_other_than_commas\r\n     * @memberof NewCSVParser\r\n     */\r\n    detectColumnDelimiter(textRead) {\r\n        let headerText = textRead.split(this.rowDelimiter)[0];\r\n        let numCommas = headerText.split(',').length - 1;\r\n        let numSemiColons = headerText.split(';').length - 1;\r\n        let numPipes = headerText.split('|').length - 1;\r\n        if (numCommas > 0 && numSemiColons === 0 && numPipes === 0)\r\n            this.columnDelimiter = ',';\r\n        else if (numCommas === 0 && numSemiColons > 0 && numPipes === 0)\r\n            this.columnDelimiter = ';';\r\n        else if (numCommas === 0 && numSemiColons === 0 && numPipes > 0)\r\n            this.columnDelimiter = '|';\r\n        else\r\n            throw new Error(`Couldn't detect the column delimiter. Something must be wrong with the dataset. Header text: ${headerText}`);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Process header using the programmer options and the header read from the file.\r\n     * @param {string} textRead - The string of text that was read from the file.   \r\n     * @memberof NewCSVParser\r\n     */\r\n    processHeader(textRead) {\r\n        let header = textRead.split(this.rowDelimiter)[0];\r\n        let columns = header.split(this.columnDelimiter);\r\n\r\n        let numColumns = columns.length; //To be used by Workers?\r\n        let headerIndices = [];\r\n        let catIndices = [];\r\n        let contIndices = [];\r\n        let timeIndex = [];\r\n        let optionalIndices = [];\r\n        let geoIndices = [];\r\n\r\n        catIndices = this.findVariablesIndices(this.categoricalVariables, columns);\r\n        contIndices = this.findVariablesIndices(this.continousVariables, columns);\r\n        timeIndex = this.hasTime ? columns.indexOf(this.timeVariable.getExternalName()) : -1;\r\n        optionalIndices = this.findVariablesIndices(this.optionalVariables, columns);\r\n        geoIndices = this.findGeometryIndices(columns);\r\n\r\n        // console.log(catIndices, contIndices, timeIndex, optionalIndices, numColumns);\r\n        this.verifyIndicesIntegrity(catIndices, contIndices, timeIndex, optionalIndices);\r\n        headerIndices = [catIndices, contIndices, geoIndices, timeIndex, optionalIndices];\r\n        this.startWorkers(headerIndices, numColumns);\r\n    }\r\n\r\n    /**\r\n     * For each variable of the given variables find the index of it's internal name on the header.\r\n     * @param {Array<DataVariable>} variables - The variables to look for it's indices.\r\n     * @param {Array<string>} headerColumns - The header columns\r\n     * @returns {Array<number>} - the index of each variable internal name on the header.\r\n     * @memberof NewCSVParser\r\n     */\r\n    findVariablesIndices(variables, headerColumns) {\r\n        let indices = [];\r\n        for (const variable of variables) {\r\n            let index = headerColumns.indexOf(variable.getExternalName());\r\n            if (index > -1)\r\n                indices.push(index);\r\n        }\r\n        return indices;\r\n    }\r\n\r\n    /**\r\n     * For the CSV file finds the indices of the geometry. If the geometry should be reused then it should return the index of the identifier.\r\n     * @param {Array<string>} columns - The header keys. \r\n     * @returns {number|Array<number>} - The id or the longitude and latitude indices.\r\n     * @memberof NewCSVParser\r\n     */\r\n    findGeometryIndices(columns) {\r\n        let id = this.urlVariable.getIdOnDataURL();\r\n        // console.warn(id);\r\n        if (id)\r\n            return columns.indexOf(id);\r\n        else {\r\n            let longitudeExternalName = this.geometryVariables[0].getExternalName();\r\n            let latitudeExternalName = this.geometryVariables[1].getExternalName();\r\n            let lngIndex = columns.indexOf(longitudeExternalName);\r\n            let latIndex = columns.indexOf(latitudeExternalName);\r\n            if (latIndex === -1 || lngIndex === -1)\r\n                throw new Error(\"Longitude or Latitude keys not found in the CSV header.\");\r\n            return [lngIndex, latIndex];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies if there's any error in any given variable external name.\r\n     * @param {Array<number>} catIndices - The indices of all categorical variables.\r\n     * @param {Array<number>} contIndices - The indices of all continuous variables.\r\n     * @param {number} timeIndex - The index of the time variable.\r\n     * @param {Array<number>} optionalIndices - The indices of the optional variables.\r\n     * @throws {Error} - At least one variable external name wasn't found in the CSV file header. \r\n     * @memberof NewCSVParser\r\n     */\r\n    verifyIndicesIntegrity(catIndices, contIndices, timeIndex, optionalIndices) {\r\n        let errCt = 0;\r\n        if (this.categoricalVariables.length !== catIndices.length)\r\n            errCt++;\r\n        if (this.continousVariables.length !== contIndices.length)\r\n            errCt++;\r\n        if (this.hasTime && timeIndex === -1)\r\n            errCt++;\r\n        if (this.optionalVariables.length !== optionalIndices.length)\r\n            errCt++;\r\n\r\n        if (errCt > 0)\r\n            throw new Error(`At least ${errCt} variable(s) external names weren't found in the CSV file header.`);\r\n    }\r\n\r\n    /**\r\n     * Creates the workers that will parse the file in chunks.\r\n     * @param {Array<Array<number>>} headerIndices - The indices of the optional variables, if any.\r\n     * @param {number} numColumnsPerRow - The number of columns each row must contain.\r\n     * @see https://stackoverflow.com/a/44782052/\r\n     * @memberof NewCSVParser\r\n     */\r\n    startWorkers(headerIndices, numColumnsPerRow) {\r\n        let CSVWorkerOptions = {\r\n            dataFile: this.dataFile,\r\n            chunkSize: Math.max(this.headerBytesSize, this.chunkSize), //UserDef or 10MB ?\r\n            columnDelimiter: this.columnDelimiter, //UserDef or comma\r\n            rowDelimiter: this.rowDelimiter, //UserDef or \\n \r\n            numColumnsPerRow: numColumnsPerRow, //Used to make sure every line has the same number of \r\n            workerIndex: -1, //worker index\r\n            startByte: 0, //Start Byte for worker\r\n            endByte: 0, //End byte for worker\r\n            headerIndices: headerIndices, //The header indices\r\n\r\n            categoricalVariables: this._cloneCategoricalVariables(), //this.categoricalVariables,\r\n            continuousVariables: this.continousVariables,\r\n            timeVariable: this.timeVariable,\r\n            // hasIds: this.urlVariable.hasIds(),\r\n\r\n            optionalVariables: this.optionalVariables,\r\n            // webglContext: this.webglContext,\r\n            classCalcRequired: this.classCalculationRequired(),\r\n            timeGranularity: headerIndices[3] >= 0 ? this.timeVariable.getGranularity() : ''\r\n        };\r\n\r\n        let numDataWorkers = this.numDataWorkers;\r\n        let bytesByDataWorker = Math.round(this.fileSize / numDataWorkers);\r\n        //Loop by this.numDataWorkers e start each with some information\r\n        for (let i = 0; i < this.numDataWorkers; i++) {\r\n            CSVWorkerOptions.workerIndex = i;\r\n            CSVWorkerOptions.startByte = i * bytesByDataWorker;\r\n            CSVWorkerOptions.endByte = i < numDataWorkers - 1 ? (i + 1) * bytesByDataWorker : this.fileSize;\r\n            this.dataWorkers[i] = new CSVDataWorker();\r\n\r\n            console.log(CSVWorkerOptions);\r\n\r\n            this.dataWorkers[i].postMessage({\r\n                protocolMessage: GisplayDefaults.MESSAGES_CSV().TO_START,\r\n                messageData: {\r\n                    workerOptions: CSVWorkerOptions\r\n                }\r\n            });\r\n            this.dataWorkers[i].onmessage = (e) => { this.receiveWorkersMessage(e.data); };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the categorical variable to remove the gisplayMap object because it can't be cloned to send to Web Workers.\r\n     * @returns \r\n     * @memberof CSVNewParser\r\n     */\r\n    _cloneCategoricalVariables() {\r\n        let catVarsToSend = [];//new Array(this.categoricalVariables.length);\r\n        for (const catVar of this.categoricalVariables) {\r\n            catVarsToSend.push(Object.assign(Object.create(Object.getPrototypeOf(catVar)), catVar));\r\n        }\r\n        for (let catVar of catVarsToSend)\r\n            catVar.gisplayMap = null;\r\n        console.log(catVarsToSend);\r\n        return catVarsToSend;\r\n    }\r\n\r\n    /**\r\n     * Receives the message that was sent by any Worker.\r\n     * @param {{protocolMessage: string, messageData:Object}} message - The message that was sent by the worker.\r\n     * @memberof CSVNewParser\r\n     */\r\n    receiveWorkersMessage(message) {\r\n        let protocolMessages = GisplayDefaults.MESSAGES_CSV();\r\n        switch (message.protocolMessage) {\r\n            case protocolMessages.END_START: { //Worker processed it's part\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    this.workerTerminatedReplies = 0;\r\n                    this.sendMessageToWorkers(protocolMessages.TO_LIMITS_CAT);\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.END_LIMITS_CAT: {\r\n                //Save the limits/categories and time granules sent by the W\r\n                let catVarsCategories = message.messageData.categoricalVariables;\r\n                for (const catVar of this.categoricalVariables)\r\n                    if (catVar.classCalculationRequired())\r\n                        catVar.addCategories(catVarsCategories.get(catVar.getInternalName()));\r\n\r\n                let continousVariables = message.messageData.continousVariables;\r\n                for (const contVar of this.continousVariables) {\r\n                    let minMax = continousVariables.get(contVar.getInternalName());\r\n                    contVar.setMinMax(minMax[0]);\r\n                    contVar.setMinMax(minMax[1]);\r\n                    contVar.setStep();\r\n                }\r\n\r\n                if (this.hasTime)\r\n                    this.timeVariable.addTemporalGranulesToSet(message.messageData.timeVariable);\r\n\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    //Now we have the TGs and Categories but still need to calculate the histograms for each continuous variable\r\n                    //Send min/max of each Cont var to the Ws\r\n                    /*   console.log(\"ALL REPLIED\");\r\n                      console.log('---------------------------------------');\r\n                      console.log(this.categoricalVariables);\r\n                      console.log(this.continousVariables);\r\n                      console.log(this.timeVariable);\r\n                    */\r\n                    this.workerTerminatedReplies = 0;\r\n                    let continuousVarsMinMax = [];\r\n                    for (const contVar of this.continousVariables)\r\n                        continuousVarsMinMax.push([contVar.getMin(), contVar.getMax()]);\r\n                    this.sendMessageToWorkers(protocolMessages.TO_LIMITS_CAT_RES, continuousVarsMinMax);\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.END_LIMITS_CAT_RES: {\r\n                let histograms = message.messageData.histograms;\r\n                for (let [i, contVar] of this.continousVariables.entries())\r\n                    if (contVar.classCalculationRequired())\r\n                        contVar.updateHistogram(histograms[i]);\r\n\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    this.workerTerminatedReplies = 0;\r\n\r\n                    for (let contVar of this.continousVariables)\r\n                        contVar.createBins();\r\n\r\n                    /*      console.log(\"ALL REPLIED SEE CONT VARS\");\r\n                         console.log('---------------------------------------');\r\n                         console.log(this.continousVariables); */\r\n\r\n                    // Generate MVCs and TGs because we already have everything we need to do so\r\n                    //Each Cat Var generate Map of categories to index\r\n                    //Each cont var generate classes\r\n                    //Time Var generate indices for each granule\r\n                    for (const catVar of this.categoricalVariables) {\r\n                        if (catVar.classCalculationRequired())\r\n                            catVar.updateCategoricalInformation();\r\n                    }\r\n                    for (const contVar of this.continousVariables)\r\n                        if (contVar.classCalculationRequired())\r\n                            contVar.calculateClasses();\r\n\r\n                    if (this.hasTime) {\r\n                        this.timeVariable.createTemporalGranulesMap(this.timeVariable.getTemporalGranulesSet());\r\n                        this.timeVariable.sortTemporalGranules();\r\n                    }\r\n\r\n                    this.createMapVariableCombinations(); //@TODO: SHouldn't be called if not needed\r\n\r\n                    //Send combinations created to the Ws\r\n                    this.sendTO_JOIN_DATAMessage();\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.END_JOIN_DATA: {\r\n                //Should receive the information about each W\r\n                //Number of elements per MVC/TG\r\n                this.dataWorkersInfo[message.messageData.workerIndex] = message.messageData.numElemsPerTG;\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    this.workerTerminatedReplies = 0;\r\n                    console.log(\"All Ws joined their data\");\r\n                    console.log(this.dataWorkersInfo);\r\n                    //Generate start and end RGBA for each W MVC/TG \r\n                    let rgbasByWorker = this._generateStartRGBAsForWorkers();   //Should send to each worker: 1. the start RGBA of each TG for each MVC \r\n                    this.sendMessageToWorkers(protocolMessages.TO_GENERATE_RGBA, rgbasByWorker);\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.END_GENERATE_RGBA: {\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    this.workerTerminatedReplies = 0;\r\n                    console.log(\"All Ws Generated RGBA Values\");\r\n                    //All replied then we can start receiving data to build the final MVCs and TGs\r\n                    this.sendMessageToWorkers(protocolMessages.TO_SEND_DATA);\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.END_SEND_DATA: {\r\n                let finalDataRows = message.messageData.finalDataRows;\r\n                //Put each row into its MVC/TG ...\r\n                // console.log(this.workerTerminatedReplies, finalDataRows);\r\n                // this.categoricalVariables[0].values = ['N', 'Y']; /// HERE FIND SOLUTION FOR THIS <<<<<<<<<<<<<<COMMENTED 21/01/2018\r\n                // console.warn(this.mapVarCombinations.length);\r\n                console.warn(finalDataRows);\r\n                // console.error(\"Worker==\", this.workerTerminatedReplies + 1);\r\n                for (let i = 0; i < finalDataRows.length; i++) { //MVCs\r\n                    for (let j = 0; j < finalDataRows[i].length; j++) { //TGs\r\n                        if (finalDataRows[i][j].RGBA.length > 0) {\r\n                            // if (i === 1 && j === 0 && this.workerTerminatedReplies + 1 === 2\r\n                            //     || i === 1 && j === 0 && this.workerTerminatedReplies + 1 === 3) {\r\n                            // }\r\n                            /*  console.warn(i, j, this.workerTerminatedReplies + 1);\r\n                             console.log(this.printFirstRGBA(finalDataRows[i][j].RGBA), this.printLastRGBA(finalDataRows[i][j].RGBA));\r\n                             console.log(finalDataRows[i][j].RGBA);\r\n                             console.log(finalDataRows[i][j].numberRGBA); */\r\n                            this.mapVarCombinations[i].temporalGranules[j].addSetOfRows(finalDataRows[i][j]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for (const mvc of this.mapVarCombinations) //Update the current RGBA for each Map var combination\r\n                    mvc.updateCurrentRGBA();\r\n\r\n                // console.error(\"Worker==\", this.workerTerminatedReplies + 1);\r\n                // console.error(\"-------------------------------------------------------------------\");\r\n                if (++this.workerTerminatedReplies === this.numDataWorkers) {\r\n                    //DONE\r\n                    this.terminateDataWorkers();\r\n                    console.log(\"ALL Ws sent their data and are terminated\");\r\n                    this.geometryPrimitive = !this.urlVariable.hasIds() ? GisplayDefaults.getPrimitive().CSVPOINT : GisplayDefaults.getPrimitive().CSVIDS;\r\n                    this.endParser();\r\n                }\r\n                else\r\n                    this.sendMessageToWorkers(protocolMessages.TO_SEND_DATA);\r\n            }\r\n        }\r\n    }\r\n\r\n    printFirstRGBA(RGBA) {\r\n        let firstRGBA = [];\r\n        for (let i = 0; i < 4; i++)\r\n            firstRGBA.push(RGBA[i])\r\n        return firstRGBA;\r\n    }\r\n\r\n    printLastRGBA(RGBA) {\r\n        let lastRGBA = [];\r\n        for (let i = RGBA.length - 4; i < RGBA.length; i++)\r\n            lastRGBA.push(RGBA[i]);\r\n        return lastRGBA;\r\n    }\r\n\r\n    /**\r\n     * Generate the start RGBA codes for all possible combinations of MVC/TG in ascending order by worker.\r\n     * @returns {Array<Array<number>>} -  the start RGBA codes for all possible combinations of MVC/TG in ascending order by worker.\r\n     * @memberof CSVNewParser\r\n     */\r\n    _generateStartRGBAsForWorkersOLD() {\r\n        let rgbasByWorker = GisplayDefaults.cloneNestedArray(this.dataWorkersInfo);//.slice(0); //To send with the startRGBA for each MVC/TG\r\n        for (let mvc of this.mapVarCombinationStrToIndexMap.keys()) {\r\n            let mvcIndex = this.mapVarCombinationStrToIndexMap.get(mvc);\r\n            let rgba = this.mapVarCombinations[mvcIndex].getStartingRGBA(),\r\n                rgbaNum = GisplayDefaults.RGBAToNumber(...rgba);\r\n\r\n            let first = true,\r\n                numElems = 0,\r\n                numTGs = this.mapVarCombinations[mvcIndex].getTemporalGranules().length;\r\n            for (let tgIndex = 0; tgIndex < numTGs; tgIndex++) {\r\n                for (let [workerIndex, worker] of this.dataWorkers.entries()) {\r\n                    numElems += this.dataWorkersInfo[workerIndex][mvcIndex][tgIndex] + 1;\r\n                    if (first) {\r\n                        rgbasByWorker[workerIndex][mvcIndex][tgIndex] = rgba;\r\n                        first = false;\r\n                    } else {\r\n                        let newRGBANum = GisplayDefaults.RGBAToNumber(...rgba) + numElems;\r\n                        let newRGBA = GisplayDefaults.numberToRGBA(newRGBANum);\r\n                        rgbasByWorker[workerIndex][mvcIndex][tgIndex] = newRGBA;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let numWorkers = this.dataWorkers.length;\r\n        for (let i = 0; i < numWorkers; i++)\r\n            console.log(rgbasByWorker[i]);\r\n        return rgbasByWorker;\r\n    }\r\n\r\n    _generateStartRGBAsForWorkers() {\r\n        let rgbasByWorker = GisplayDefaults.cloneNestedArray(this.dataWorkersInfo);//.slice(0); //To send with the startRGBA for each MVC/TG\r\n        for (let mvc of this.mapVarCombinationStrToIndexMap.keys()) {\r\n            let mvcIndex = this.mapVarCombinationStrToIndexMap.get(mvc);\r\n            let rgba = this.mapVarCombinations[mvcIndex].getStartingRGBA();\r\n\r\n            let index = 0,\r\n                numElems = GisplayDefaults.RGBAToNumber(...rgba),\r\n                numTGs = this.mapVarCombinations[mvcIndex].getTemporalGranules().length;\r\n            for (let [workerIndex, worker] of this.dataWorkers.entries()) {\r\n                if (index++ === 0)\r\n                    rgbasByWorker[workerIndex][mvcIndex] = rgba;\r\n                else {\r\n                    rgba = GisplayDefaults.numberToRGBA(numElems);\r\n                    rgbasByWorker[workerIndex][mvcIndex] = rgba;\r\n                }\r\n                numElems += this.dataWorkersInfo[workerIndex][mvcIndex] + 1;\r\n            }\r\n        }\r\n        let numWorkers = this.dataWorkers.length;\r\n        for (let i = 0; i < numWorkers; i++)\r\n            console.log(rgbasByWorker[i]);\r\n        return rgbasByWorker;\r\n    }\r\n\r\n    /**\r\n     * Send message with name: TO_JOIN, and this way the Ws can join the data given the MVCs and TGs created. \r\n     * @memberof CSVNewParser\r\n     */\r\n    sendTO_JOIN_DATAMessage() {\r\n        let protocolMessages = GisplayDefaults.MESSAGES_CSV();\r\n        let MVCs = this.mapVarCombinationStrToIndexMap;\r\n        let sortedTGs = this.hasTime ? this.timeVariable.getSortedTemporalGranules() : [0];\r\n        /*   console.log(MVCs);\r\n          console.log(sortedTGs); */\r\n        //Needs to send the cat vars, the cont vars and the time variable and the mvcs created\r\n        this.sendMessageToWorkers(protocolMessages.TO_JOIN_DATA, {\r\n            categoricalVariables: this._cloneCategoricalVariables(),//this.categoricalVariables,\r\n            continuousVariables: this.continousVariables,\r\n            timeVariable: this.timeVariable,\r\n            mvcs: MVCs,\r\n            numberMVCs: MVCs.size,\r\n            numberTGs: sortedTGs.length\r\n        });\r\n    }\r\n\r\n    sendMessageToWorkers(message, dataToSend) {\r\n        let protocolMessages = GisplayDefaults.MESSAGES_CSV();\r\n        switch (message) {\r\n            /*  case protocolMessages.TO_REMAINING_ROWS1: {\r\n                 this.dataWorkers[0].postMessage({\r\n                     protocolMessage: message,\r\n                     messageData: dataToSend\r\n                 });\r\n                 break;\r\n             } */\r\n            case protocolMessages.TO_LIMITS_CAT: {\r\n                for (const dataWorker of this.dataWorkers)\r\n                    dataWorker.postMessage({ protocolMessage: message });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_LIMITS_CAT_RES: {\r\n                for (const dataWorker of this.dataWorkers)\r\n                    dataWorker.postMessage({\r\n                        protocolMessage: message,\r\n                        messageData: dataToSend\r\n                    });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_JOIN_DATA: {\r\n                for (const dataWorker of this.dataWorkers)\r\n                    dataWorker.postMessage({\r\n                        protocolMessage: message,\r\n                        messageData: dataToSend\r\n                    });\r\n                break;\r\n            }\r\n            case protocolMessages.TO_GENERATE_RGBA: {\r\n                for (const [i, dataWorker] of this.dataWorkers.entries()) {\r\n                    dataWorker.postMessage({\r\n                        protocolMessage: message,\r\n                        messageData: dataToSend[i] //Only the rgbas for this worker\r\n                    });\r\n                }\r\n                break;\r\n            }\r\n            case protocolMessages.TO_SEND_DATA: {\r\n                this.dataWorkers[this.workerTerminatedReplies].postMessage({\r\n                    protocolMessage: message,\r\n                    messageData: dataToSend\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send terminate event to all data workers after their job is done.\r\n     * @memberof NewCSVParser\r\n     */\r\n    terminateDataWorkers() {\r\n        for (const dataWorker of this.dataWorkers)\r\n            dataWorker.terminate();\r\n        delete this.dataWorkers;\r\n    }\r\n\r\n    /**\r\n     * Split Transitory data, join points if needed and dispatch the parser end event.\r\n     * @memberof Parser\r\n     */\r\n    endParser() {\r\n        if (!this.urlVariable.hasIds()) {\r\n            this.setGeometryPrimitiveTGs();\r\n            this.setNumElementsTemporalGranules();\r\n\r\n            console.time(\"joinPoints\");\r\n            if (this.geometryVariables.length > 1) {\r\n                this.joinMapVarCombinationData();\r\n                this.joinPickingColors();\r\n            }\r\n            console.timeEnd(\"joinPoints\");\r\n        }\r\n        this.dispatchParseEndEvent();\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Parser/CSV/CSVParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 550,
    "kind": "variable",
    "name": "CSVDataWorker",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVDataWorker",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/CSV/CSVParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 551,
    "kind": "class",
    "name": "CSVParser",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/CSV/CSVParser.js",
    "importStyle": "{CSVParser}",
    "description": "Fast CSV Parser. This parser was created because current parsers that work on the browser do not provide the required performance for this thesis.",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "NewCSVParser"
      }
    ],
    "interface": false,
    "extends": [
      "Parser"
    ]
  },
  {
    "__docId__": 552,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayOptions",
        "description": "The options class."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webgl",
        "description": "The WebGLRenderingContext."
      }
    ]
  },
  {
    "__docId__": 553,
    "kind": "member",
    "name": "startByte",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#startByte",
    "access": "public",
    "description": "The start byte of the file.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "number=0"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 554,
    "kind": "member",
    "name": "headerBytesSize",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#headerBytesSize",
    "access": "public",
    "description": "Number of bytes to read at the beginning of the file.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "number=1024"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 555,
    "kind": "member",
    "name": "chunkSize",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#chunkSize",
    "access": "public",
    "description": "The size of each chunk to be read from the file. The default is 10MiB. ",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number=1024*1024*10"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 556,
    "kind": "member",
    "name": "columnDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#columnDelimiter",
    "access": "public",
    "description": "The char or string that is used to split columns of each row. Defaults is comma.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "string=','"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 557,
    "kind": "member",
    "name": "rowDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#rowDelimiter",
    "access": "public",
    "description": "The row delimiter. Defaults is \\n.\nCR = \\r (MAC); LF = \\n (LINUX); CRLF = \\r\\n (WINDOWS) ",
    "see": [
      "https://en.wikipedia.org/wiki/Newline",
      "http://stackoverflow.com/a/1552782/",
      "https://stackoverflow.com/a/39259747/"
    ],
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string='\\n'"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 558,
    "kind": "member",
    "name": "numDataWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#numDataWorkers",
    "access": "public",
    "description": "Number of data workers that will process the file in parallel.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "number=4"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 559,
    "kind": "member",
    "name": "dataWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#dataWorkers",
    "access": "public",
    "description": "The data workers that will read a portion of the CSV dataset.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Array<Worker>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 560,
    "kind": "member",
    "name": "dataWorkersInfo",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#dataWorkersInfo",
    "access": "public",
    "description": "Information to be stored for each worker.",
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "Array<any>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 561,
    "kind": "member",
    "name": "workerTerminatedReplies",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#workerTerminatedReplies",
    "access": "public",
    "description": "The number of worker that replied with the terminated message.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 562,
    "kind": "member",
    "name": "workerRemainingRows",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#workerRemainingRows",
    "access": "public",
    "description": "Used to save the first and last rows of each worker after they're done processing their part. ",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "Array<Array<string>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 563,
    "kind": "member",
    "name": "reader",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#reader",
    "access": "public",
    "description": "The Filereader.",
    "lineNumber": 97,
    "type": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 564,
    "kind": "method",
    "name": "unusedConstructorCode",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#unusedConstructorCode",
    "access": "public",
    "description": "Code that will be used in the future to decide how many workers to start and the amount of bytes each will have to deal with.",
    "lineNumber": 105
  },
  {
    "__docId__": 566,
    "kind": "member",
    "name": "numChunks",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#numChunks",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "createFileReader",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#createFileReader",
    "access": "public",
    "description": "Creates a FileReader object and adds the load and error events to it.",
    "lineNumber": 126,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{FileReader} - The Filereader object which will be used to read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": "The Filereader object which will be used to read from the file."
    }
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "readHeader",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#readHeader",
    "access": "public",
    "description": "Reads the first 1024 bytes (1KiB) (the value of this.headerBytesSize) of the file.",
    "lineNumber": 137
  },
  {
    "__docId__": 569,
    "kind": "method",
    "name": "chunkLoaded",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#chunkLoaded",
    "access": "public",
    "description": "After the header chunk was loaded then look for ",
    "lineNumber": 148,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "textRead",
        "description": "The string of text that was read from the file."
      }
    ]
  },
  {
    "__docId__": 570,
    "kind": "method",
    "name": "detectRowDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#detectRowDelimiter",
    "access": "public",
    "description": "Detects which is the row delimiter for the file in use.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "textRead",
        "description": "The string of text that was read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if the row delimiter was detected, false, otherwise."
    }
  },
  {
    "__docId__": 575,
    "kind": "method",
    "name": "detectColumnDelimiter",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#detectColumnDelimiter",
    "access": "public",
    "description": "Detects the column separator for the file in use.",
    "see": [
      "https://data-gov.tw.rpi.edu/wiki/CSV_files_use_delimiters_other_than_commas"
    ],
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "textRead",
        "description": "The string of text that was read from the file."
      }
    ]
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "processHeader",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#processHeader",
    "access": "public",
    "description": "Process header using the programmer options and the header read from the file.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "textRead",
        "description": "The string of text that was read from the file."
      }
    ]
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "findVariablesIndices",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#findVariablesIndices",
    "access": "public",
    "description": "For each variable of the given variables find the index of it's internal name on the header.",
    "lineNumber": 248,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the index of each variable internal name on the header."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<DataVariable>"
        ],
        "spread": false,
        "optional": false,
        "name": "variables",
        "description": "The variables to look for it's indices."
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "headerColumns",
        "description": "The header columns"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the index of each variable internal name on the header."
    }
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "findGeometryIndices",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#findGeometryIndices",
    "access": "public",
    "description": "For the CSV file finds the indices of the geometry. If the geometry should be reused then it should return the index of the identifier.",
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number|Array<number>} - The id or the longitude and latitude indices."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "columns",
        "description": "The header keys."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number",
        "Array<number>"
      ],
      "spread": false,
      "description": "The id or the longitude and latitude indices."
    }
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "verifyIndicesIntegrity",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#verifyIndicesIntegrity",
    "access": "public",
    "description": "Verifies if there's any error in any given variable external name.",
    "lineNumber": 289,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "catIndices",
        "description": "The indices of all categorical variables."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "contIndices",
        "description": "The indices of all continuous variables."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeIndex",
        "description": "The index of the time variable."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "optionalIndices",
        "description": "The indices of the optional variables."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "At least one variable external name wasn't found in the CSV file header."
      }
    ]
  },
  {
    "__docId__": 583,
    "kind": "method",
    "name": "startWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#startWorkers",
    "access": "public",
    "description": "Creates the workers that will parse the file in chunks.",
    "see": [
      "https://stackoverflow.com/a/44782052/"
    ],
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Array<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "headerIndices",
        "description": "The indices of the optional variables, if any."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numColumnsPerRow",
        "description": "The number of columns each row must contain."
      }
    ]
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "_cloneCategoricalVariables",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#_cloneCategoricalVariables",
    "access": "private",
    "description": "Clone the categorical variable to remove the gisplayMap object because it can't be cloned to send to Web Workers.",
    "lineNumber": 360,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "receiveWorkersMessage",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#receiveWorkersMessage",
    "access": "public",
    "description": "Receives the message that was sent by any Worker.",
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "{protocolMessage: string, messageData:Object}"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message that was sent by the worker."
      }
    ]
  },
  {
    "__docId__": 591,
    "kind": "member",
    "name": "geometryPrimitive",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#geometryPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 516,
    "undocument": true
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "printFirstRGBA",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#printFirstRGBA",
    "access": "public",
    "description": null,
    "lineNumber": 525,
    "undocument": true
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "printLastRGBA",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#printLastRGBA",
    "access": "public",
    "description": null,
    "lineNumber": 532,
    "undocument": true
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "_generateStartRGBAsForWorkersOLD",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#_generateStartRGBAsForWorkersOLD",
    "access": "private",
    "description": "Generate the start RGBA codes for all possible combinations of MVC/TG in ascending order by worker.",
    "lineNumber": 544,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} -  the start RGBA codes for all possible combinations of MVC/TG in ascending order by worker."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "the start RGBA codes for all possible combinations of MVC/TG in ascending order by worker."
    }
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "_generateStartRGBAsForWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#_generateStartRGBAsForWorkers",
    "access": "private",
    "description": null,
    "lineNumber": 574,
    "undocument": true
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "sendTO_JOIN_DATAMessage",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#sendTO_JOIN_DATAMessage",
    "access": "public",
    "description": "Send message with name: TO_JOIN, and this way the Ws can join the data given the MVCs and TGs created. ",
    "lineNumber": 603
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "sendMessageToWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#sendMessageToWorkers",
    "access": "public",
    "description": null,
    "lineNumber": 620,
    "undocument": true
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "terminateDataWorkers",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#terminateDataWorkers",
    "access": "public",
    "description": "Send terminate event to all data workers after their job is done.",
    "lineNumber": 674
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "endParser",
    "memberof": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/CSV/CSVParser.js~CSVParser#endParser",
    "access": "public",
    "description": "Split Transitory data, join points if needed and dispatch the parser end event.",
    "lineNumber": 684
  },
  {
    "__docId__": 600,
    "kind": "file",
    "name": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "content": "import { GisplayDefaults } from '../../GisplayDefaults';\r\n\r\nconst earcut = require('../../../lib/earcut');\r\n// import { earcut } from '../../../lib/earcut';\r\n// import earcut from 'script-loader!../../../lib/earcut';\r\n\r\n/**\r\n * GeoJSONIds Parser.\r\n * @export\r\n * @class GeoJSONIdsParser\r\n */\r\nexport class GeoJSONIdsParser {\r\n\r\n    /**\r\n     * Creates an instance of GeoJSONIdsParser.\r\n     * @param {Blob} geoSpatialURL - The file to read and process. \r\n     * @param {string} geoSpatialId - The id of the geometry on the geospatial file.\r\n     * @param {WebGLRenderingContext} webgl - The WebGLRenderingContext.\r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    constructor(geoSpatialURL, geoSpatialId, webgl) {\r\n        /**\r\n         * The id of the geometry on the geospatial file.\r\n         * @type {string}\r\n         */\r\n        this.geoSpatialId = geoSpatialId;\r\n        /**\r\n         * The WebGL Rendering context.\r\n         * @type {WebGLRenderingContext}\r\n         */\r\n        this.webglContext = webgl;\r\n        /**\r\n         * The initial index for the polygon or line.\r\n         * @type {number}\r\n         */\r\n        this.initialIndex = 0;\r\n        /**\r\n         * The color number to be used for each polygon/line/point that is read from the file.\r\n         * @type {number}\r\n         */\r\n        this.RGBAColorNumber = 1;\r\n        /** \r\n         * An array that holds all points for all polygons/lines. \r\n         * @type {Array<number>|WebGLBuffer}\r\n         */\r\n        this.allPoints = [];\r\n        /** \r\n         * An array that holds all colors for all polygons/lines. One color for each vertex.\r\n         * @type {Array<number>|WebGLBuffer}\r\n         */\r\n        this.allColors = [];\r\n\r\n        /** \r\n         * The identifier of the type of primitive (Point, polygon or line).\r\n         * @type {number}\r\n         */\r\n        this.geometryPrimitive;\r\n        /**\r\n         * The Filereader.\r\n         * @type {FileReader}\r\n         */\r\n        this.reader = this.createFileReader();\r\n        this.reader.readAsText(geoSpatialURL);\r\n    }\r\n\r\n    /**\r\n     * Creates a FileReader object and adds the load and error events.\r\n     * @returns {FileReader} - The Filereader object which will be used to read from the file.\r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    createFileReader() {\r\n        let reader = new FileReader();\r\n        reader.onloadend = (e) => { this.processFile(e.target.result); };\r\n        reader.onerror = (e) => { console.error(e); };\r\n        return reader;\r\n    }\r\n\r\n    /**\r\n     * Process the GeoJSON file.\r\n     * @param {Object} fileData - The GeoJSON data that was read from the file. \r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    processFile(fileData) {\r\n        let geojson = JSON.parse(fileData);\r\n        console.log(geojson);\r\n        console.time(\"geojsonIdsParser\");\r\n        let geometryIdsMap = new Map();\r\n        for (let feature of geojson.features)\r\n            geometryIdsMap.set(feature.properties[this.geoSpatialId], this.processFeature(feature));\r\n        // this.endParser(geometryIdsMap);\r\n\r\n        if (GisplayDefaults.hasPolygons(this.geometryPrimitive) || GisplayDefaults.hasLines(this.geometryPrimitive)) { //POLYGON OR LINES\r\n            this.joinAllPoints();\r\n            this.joinAllColors();\r\n        }\r\n\r\n        console.log(geometryIdsMap);\r\n        this.dispatchIdGeometryEndEvent(geometryIdsMap);\r\n        console.timeEnd(\"geojsonIdsParser\");\r\n    }\r\n\r\n    /**\r\n     * Process point or polygon.\r\n     * @param {Object} feature - The feature to process.\r\n     * @returns {Polygon|Array<number>} - The processed polygon or the point coordinates.\r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    processFeature(feature) {\r\n        if (this.geometryPrimitive === undefined)\r\n            this._setGeometryPrimitive(feature.geometry.type);\r\n\r\n        if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\r\n            return this.processPolygon(feature);\r\n        } else if (feature.geometry.type === 'Point') {\r\n            return this.processPoint(feature);\r\n        } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\r\n            return this.processLine(feature);\r\n        }\r\n        else\r\n            throw new Error(\"GeoJSON feature is not a Polygon, a Point or a Line\");\r\n    }\r\n\r\n    /**\r\n     * Set the type of geometry primitive for the data read. Only need to be called once. \r\n     * @param {string} geometryType - The type of geometry. \r\n     * @memberof GeoJSONParser\r\n     */\r\n    _setGeometryPrimitive(geometryType) {\r\n        switch (geometryType) {\r\n            case 'Point':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().POINT;\r\n                break;\r\n            case 'Polygon':\r\n            case 'MultiPolygon':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().POLYGON;\r\n                break;\r\n            case 'LineString':\r\n            case 'MultiLineString':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().LINE;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the point and it's RGBA color.\r\n     * @param {{geometry: JSON, properties: JSON}} point - The geometry and properties of the point.\r\n     * @returns {{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - The point coordinates and the RGBA that identifies it.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    processPoint(point) {\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        return { spatial: point.geometry.coordinates, RGBA };\r\n    }\r\n\r\n    /**\r\n     * Add the polygon points to the array of all polygon points and saves the polygon borders and triangulation indices.\r\n     * The triangles and vertices calculated by earcut triangulation.\r\n     * @param {{geometry: JSON, properties: JSON}} polygon - The geometry and properties of the polygon.\r\n     * @returns {Array<{triangles: Array<number>, vertices: Array<number>}>} - An array of Polygons. Each polygon has it's vertices (lng,lat) and triangles (which vertices to connect to create triangles).\r\n     * @see http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons\r\n     * @see https://github.com/mapbox/earcut/\r\n     * @memberOf GeoJSONParser\r\n     */\r\n    processPolygon(polygon) {\r\n        let polygonIndices = [], //Vertices given by earcut\r\n            bordersIndices = []; //Save all triangles for the processed polygon or multipolygon\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        if (polygon.geometry.type === \"Polygon\") { //@TODO: [Demos never use this if statement.]\r\n\r\n            let outsidepolygon = polygon.geometry.coordinates[0]; //See: http://geojson.org/geojson-spec.html#polygon\r\n            let tempVerts = new Array();\r\n\r\n            for (let out = 0; out < outsidepolygon.length - 1; out++) {\r\n                tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\r\n                this.allPoints.push(outsidepolygon[out][0], outsidepolygon[out][1]);\r\n                this.allColors.push(...RGBA);\r\n            }\r\n\r\n            let earcutVertices = earcut(tempVerts);\r\n            let finalVertices = earcutVertices.map((e) => e + this.initialIndex);\r\n            for (let finalVertex of finalVertices)\r\n                polygonIndices.push(finalVertex);\r\n\r\n            this._createBorders(tempVerts.length / 2, bordersIndices);\r\n            this.initialIndex += tempVerts.length / 2;\r\n        }\r\n        else if (polygon.geometry.type == \"MultiPolygon\") { //See http://geojson.org/geojson-spec.html#multipolygon\r\n            for (const cs of polygon.geometry.coordinates) { //For each polygon\r\n                let tempVerts = new Array();\r\n\r\n                let outsidepolygon = cs[0];\r\n                for (const c of outsidepolygon) {\r\n                    tempVerts.push(c[0], c[1]);\r\n                    this.allPoints.push(c[0], c[1]);\r\n                    this.allColors.push(...RGBA);\r\n                }\r\n\r\n                let earcutVertices = earcut(tempVerts);\r\n                let finalVertices = earcutVertices.map((e) => e + this.initialIndex);\r\n                for (let finalVertex of finalVertices)\r\n                    polygonIndices.push(finalVertex);\r\n\r\n                this._createBorders(tempVerts.length / 2, bordersIndices);\r\n                this.initialIndex += (tempVerts.length / 2); //Update the first index for the next polygon\r\n            }\r\n        }\r\n        return { spatial: { polygonIndices, bordersIndices }, RGBA };\r\n    }\r\n\r\n    /**\r\n     * Create the border indices for the polygon starting at it's initial index.\r\n     * @param {number} numVertices - The number of vertices of the polygon. \r\n     * @param {Array<number>} bordersIndices - The array of indices. If it's a multipolygon it might contain some indices otherwise it's empty.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    _createBorders(numVertices, bordersIndices) {\r\n        //Loop tempVerts and look create indices for this \r\n        bordersIndices.push(this.initialIndex);\r\n        let currentIndex = this.initialIndex;\r\n        for (let i = 1; i < numVertices; i++) {\r\n            currentIndex++;\r\n            bordersIndices.push(currentIndex, currentIndex);\r\n        }\r\n        bordersIndices.push(this.initialIndex);\r\n    }\r\n\r\n    /**\r\n     * Process the line (LineString or MultiLineString).\r\n     * @param {Object} feature - The GeoJSON Feature. \r\n     * @returns {Array<number>|Array<Array<number>>} - the line (array of points) or a group of lines (array of arrays of points).\r\n     * @see http://wiki.geojson.org/GeoJSON_draft_version_6#MultiLineString\r\n     * @memberof GeoJSONParser\r\n     */\r\n    processLine(feature) {\r\n        let lineIndices = [];\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        if (feature.geometry.type === 'LineString') {\r\n            /**\r\n                 {\r\n                    \"type\": \"LineString\",\r\n                    \"coordinates\": [\r\n                        [100.0, 0.0], [101.0, 1.0]\r\n                    ]\r\n                }\r\n            */\r\n\r\n            let lngLatPoints = [];\r\n            for (const pt of feature.geometry.coordinates) {\r\n                lngLatPoints.push(pt[0], pt[1]); //Push lng,lat\r\n                this.allPoints.push(pt[0], pt[1]);\r\n                this.allColors.push(...RGBA);\r\n            }\r\n            this._createLines(lngLatPoints.length / 2, lineIndices);\r\n            this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line\r\n        }\r\n        else {\r\n            /**\r\n                {\r\n                    \"type\": \"MultiLineString\",\r\n                    \"coordinates\": [\r\n                        [ [100.0, 0.0], [101.0, 1.0] ],\r\n                        [ [102.0, 2.0], [103.0, 3.0] ]\r\n                    ]\r\n                }\r\n             */\r\n            for (const line of feature.geometry.coordinates) { //Loop over each line inside multiLineStr\r\n                let lngLatPoints = [];\r\n                for (const pt of line) { //Loop over each point of this line\r\n                    lngLatPoints.push(pt[0], pt[1]); //Push lng/lat\r\n                    this.allPoints.push(pt[0], pt[1]);\r\n                    this.allColors.push(...RGBA);\r\n                }\r\n                // points.push(linePoints);// [[100, 0, 101, 1], [102, 2, 103, 3]]\r\n                this._createLines(lngLatPoints.length / 2, lineIndices);\r\n                this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line\r\n            }\r\n        }\r\n        // return lineIndices;//this.bindLineToWebGLContext(points);\r\n        return { spatial: { lineIndices }, RGBA };//this.bindLineToWebGLContext(points);\r\n    }\r\n\r\n    /**\r\n     * Create line segments between each two indices.\r\n     * @param {number} numIndices - The number of indices to add.\r\n     * @param {Array<number>} lineIndices - The indices for the line (If it's a multilinestring may already contain indices).\r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    _createLines(numIndices, lineIndices) {\r\n        lineIndices.push(this.initialIndex);\r\n        let currentIndex = this.initialIndex;\r\n        for (let i = 1; i < numIndices - 1; i++) {\r\n            currentIndex++;\r\n            lineIndices.push(currentIndex, currentIndex);\r\n        }\r\n        lineIndices.push(++currentIndex);\r\n    }\r\n\r\n    /**\r\n     * Join all points of all polygons/lines into a single WebGL buffer.\r\n     * @memberof Parser\r\n     */\r\n    joinAllPoints() {\r\n        let webglContext = this.webglContext;\r\n        const vertArray = new Float32Array(this.allPoints);\r\n        const bufferP = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);\r\n        this.allPoints = bufferP;\r\n    }\r\n\r\n    /**\r\n     * Join all points of all polygons/lines into a single WebGL buffer.\r\n     * @memberof Parser\r\n     */\r\n    joinAllColors() {\r\n        let webglContext = this.webglContext;\r\n        const vertArray = new Uint8Array(this.allColors);\r\n        const bufferP = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);\r\n        this.allColors = bufferP;\r\n    }\r\n\r\n    /**\r\n     * Dispatch the event for the geometry ids.\r\n     * @param {Map<string, Polygon|Array<number>>} geometryIdsMap - The map with ids and respective geometry. \r\n     * @memberof Parser\r\n     */\r\n    dispatchIdGeometryEndEvent(geometryIdsMap) {\r\n        document.dispatchEvent(new CustomEvent(\"geometryIdsEnd\", {  //Retornar pelo menos os dados processados e as classes \r\n            detail: {\r\n                geometryIdsMap: geometryIdsMap,\r\n                allPoints: this.allPoints,\r\n                allColors: this.allColors,\r\n                geometryPrimitive: this.geometryPrimitive\r\n            }\r\n        }));\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 601,
    "kind": "variable",
    "name": "earcut",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~earcut",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 602,
    "kind": "class",
    "name": "GeoJSONIdsParser",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js",
    "importStyle": "{GeoJSONIdsParser}",
    "description": "GeoJSONIds Parser.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GeoJSONIdsParser"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 603,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#constructor",
    "access": "public",
    "description": "Creates an instance of GeoJSONIdsParser.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "geoSpatialURL",
        "description": "The file to read and process."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "geoSpatialId",
        "description": "The id of the geometry on the geospatial file."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webgl",
        "description": "The WebGLRenderingContext."
      }
    ]
  },
  {
    "__docId__": 604,
    "kind": "member",
    "name": "geoSpatialId",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#geoSpatialId",
    "access": "public",
    "description": "The id of the geometry on the geospatial file.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 605,
    "kind": "member",
    "name": "webglContext",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#webglContext",
    "access": "public",
    "description": "The WebGL Rendering context.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "WebGLRenderingContext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 606,
    "kind": "member",
    "name": "initialIndex",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#initialIndex",
    "access": "public",
    "description": "The initial index for the polygon or line.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 607,
    "kind": "member",
    "name": "RGBAColorNumber",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#RGBAColorNumber",
    "access": "public",
    "description": "The color number to be used for each polygon/line/point that is read from the file.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 608,
    "kind": "member",
    "name": "allPoints",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#allPoints",
    "access": "public",
    "description": "An array that holds all points for all polygons/lines. ",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>",
        "WebGLBuffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 609,
    "kind": "member",
    "name": "allColors",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#allColors",
    "access": "public",
    "description": "An array that holds all colors for all polygons/lines. One color for each vertex.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>",
        "WebGLBuffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 610,
    "kind": "member",
    "name": "reader",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#reader",
    "access": "public",
    "description": "The Filereader.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "createFileReader",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#createFileReader",
    "access": "public",
    "description": "Creates a FileReader object and adds the load and error events.",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{FileReader} - The Filereader object which will be used to read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": "The Filereader object which will be used to read from the file."
    }
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "processFile",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#processFile",
    "access": "public",
    "description": "Process the GeoJSON file.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fileData",
        "description": "The GeoJSON data that was read from the file."
      }
    ]
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "processFeature",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#processFeature",
    "access": "public",
    "description": "Process point or polygon.",
    "lineNumber": 108,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Polygon|Array<number>} - The processed polygon or the point coordinates."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "feature",
        "description": "The feature to process."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Polygon",
        "Array<number>"
      ],
      "spread": false,
      "description": "The processed polygon or the point coordinates."
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "_setGeometryPrimitive",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#_setGeometryPrimitive",
    "access": "private",
    "description": "Set the type of geometry primitive for the data read. Only need to be called once. ",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryType",
        "description": "The type of geometry."
      }
    ]
  },
  {
    "__docId__": 615,
    "kind": "member",
    "name": "geometryPrimitive",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#geometryPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 131,
    "undocument": true
  },
  {
    "__docId__": 618,
    "kind": "method",
    "name": "processPoint",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#processPoint",
    "access": "public",
    "description": "Returns the point and it's RGBA color.",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - The point coordinates and the RGBA that identifies it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometry: JSON, properties: JSON}"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": "The geometry and properties of the point."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}"
      ],
      "spread": false,
      "description": "The point coordinates and the RGBA that identifies it."
    }
  },
  {
    "__docId__": 619,
    "kind": "method",
    "name": "processPolygon",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#processPolygon",
    "access": "public",
    "description": "Add the polygon points to the array of all polygon points and saves the polygon borders and triangulation indices.\nThe triangles and vertices calculated by earcut triangulation.",
    "see": [
      "http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons",
      "https://github.com/mapbox/earcut/"
    ],
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<{triangles: Array<number>, vertices: Array<number>}>} - An array of Polygons. Each polygon has it's vertices (lng,lat) and triangles (which vertices to connect to create triangles)."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GeoJSONParser"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometry: JSON, properties: JSON}"
        ],
        "spread": false,
        "optional": false,
        "name": "polygon",
        "description": "The geometry and properties of the polygon."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<{triangles: Array<number>, vertices: Array<number>}>"
      ],
      "spread": false,
      "description": "An array of Polygons. Each polygon has it's vertices (lng,lat) and triangles (which vertices to connect to create triangles)."
    }
  },
  {
    "__docId__": 622,
    "kind": "method",
    "name": "_createBorders",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#_createBorders",
    "access": "private",
    "description": "Create the border indices for the polygon starting at it's initial index.",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numVertices",
        "description": "The number of vertices of the polygon."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "bordersIndices",
        "description": "The array of indices. If it's a multipolygon it might contain some indices otherwise it's empty."
      }
    ]
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "processLine",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#processLine",
    "access": "public",
    "description": "Process the line (LineString or MultiLineString).",
    "see": [
      "http://wiki.geojson.org/GeoJSON_draft_version_6#MultiLineString"
    ],
    "lineNumber": 234,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>|Array<Array<number>>} - the line (array of points) or a group of lines (array of arrays of points)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "feature",
        "description": "The GeoJSON Feature."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>|Array<Array<number>>"
      ],
      "spread": false,
      "description": "the line (array of points) or a group of lines (array of arrays of points)."
    }
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "_createLines",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#_createLines",
    "access": "private",
    "description": "Create line segments between each two indices.",
    "lineNumber": 288,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numIndices",
        "description": "The number of indices to add."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "lineIndices",
        "description": "The indices for the line (If it's a multilinestring may already contain indices)."
      }
    ]
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "joinAllPoints",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#joinAllPoints",
    "access": "public",
    "description": "Join all points of all polygons/lines into a single WebGL buffer.",
    "lineNumber": 302
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "joinAllColors",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#joinAllColors",
    "access": "public",
    "description": "Join all points of all polygons/lines into a single WebGL buffer.",
    "lineNumber": 315
  },
  {
    "__docId__": 631,
    "kind": "method",
    "name": "dispatchIdGeometryEndEvent",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser#dispatchIdGeometryEndEvent",
    "access": "public",
    "description": "Dispatch the event for the geometry ids.",
    "lineNumber": 329,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map<string, Polygon|Array<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryIdsMap",
        "description": "The map with ids and respective geometry."
      }
    ]
  },
  {
    "__docId__": 632,
    "kind": "file",
    "name": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "content": "// let GeoJSONWorker = require(\"worker-loader?name=worker.js!./GeoJSONWorker.js\");\r\nimport { Parser } from '../Parser';\r\nimport { GisplayDefaults } from '../../GisplayDefaults';\r\nimport { GisplayError } from '../../GisplayError';\r\n\r\nconst earcut = require('../../../lib/earcut');\r\n// import { earcut } from '../../../lib/earcut';\r\n// import earcut from 'script-loader!../../../lib/earcut';\r\n\r\n/**\r\n * GeoJSON Parser.\r\n * @export\r\n * @class GeoJSONParser\r\n */\r\nexport class GeoJSONParser extends Parser {\r\n    /**\r\n     * Creates an instance of GeoJSONParser.\r\n     * @param {GisplayOptions} gisplayOptions - The options class.\r\n     * @param {WebGLRenderingContext} webgl - The WebGLRenderingContext.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    constructor(gisplayOptions, webgl) {\r\n        super(gisplayOptions, webgl);\r\n        /**\r\n         * The color number to be used for each polygon/line that is read from the file.\r\n         * @type {number}\r\n         */\r\n        this.RGBAColorNumber = 1;\r\n        /**\r\n         * The initial index for the polygons or lines.\r\n         * @type {number}\r\n         */\r\n        this.initialIndex = 0;\r\n\r\n        /**\r\n         * The transitory array that holds data temporarily. \r\n         * @type {Array<Object>}\r\n         */\r\n        this.transitoryArray = [];\r\n        /**\r\n         * This is the maximum length of each array of the transitory data array.\r\n         * Why 100K? Because, when we have arrays with millions of positions this slows down the access.\r\n         * [ [       ], [            ], [....   ]\r\n         *   0   99999  100K   199999  200K...\r\n         * @type {number}\r\n         */\r\n        this.maxArrayLength = 100 * 1000; //100K\r\n        /**\r\n         * The number of rows/features read from the file.\r\n         * @type {number}\r\n         */\r\n        this.countTempRows = 0;\r\n        /**\r\n         * The index inside the \r\n         * @type {number}\r\n         */\r\n        this.currentTransitoryArrayIndex = 0;\r\n\r\n        /**\r\n         * The Filereader.\r\n         * @type {FileReader}\r\n         */\r\n        this.reader = this.createFileReader();\r\n        this.reader.readAsText(this.dataFile);\r\n        /**\r\n         * Hold data while we calculate the classes.\r\n         */\r\n        this.data = [];\r\n    }\r\n\r\n    /**\r\n     * Creates a FileReader object and adds the load and error events.\r\n     * @returns {FileReader} - The Filereader object which will be used to read from the file.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    createFileReader() {\r\n        let reader = new FileReader();\r\n        reader.onloadend = (e) => { this.processFile(e.target.result); };\r\n        reader.onerror = (e) => { console.error(e); };\r\n        return reader;\r\n    }\r\n\r\n    /**\r\n     * Process the GeoJSON file.\r\n     * @param {Object} fileData - The GeoJSON data that was read from the file. \r\n     * @memberof GeoJSONParser\r\n     */\r\n    processFile(fileData) {\r\n        let geojson = JSON.parse(fileData);\r\n        console.log(geojson);\r\n        console.time(\"geojsonParser\");\r\n        let i = 0,\r\n            limit = Number.MAX_SAFE_INTEGER;\r\n        if (!this.classCalculationRequired()) {\r\n            for (let feature of geojson.features) {\r\n                if (i++ === limit)\r\n                    break;\r\n                let mvCombStr = ''; //String that identifies the map variable combination\r\n                let contValues = []; //Values of the continuous variables\r\n                let geometry = this.processFeature(feature);\r\n\r\n                let time = [];\r\n                let optionals = [];\r\n                for (let catVar of this.categoricalVariables)\r\n                    mvCombStr += catVar.findIndex(feature.properties[catVar.getExternalName()]);\r\n                for (let contVar of this.continousVariables) {\r\n                    let contVarValue = feature.properties[contVar.getExternalName()]; //Value read from the continuous variable \r\n                    mvCombStr += contVar.findClassIntervalIndex(contVarValue); // Class of contVarValue\r\n\r\n                    contVar.setMinMax(contVarValue); //??\r\n\r\n                    contValues.push(contVarValue);\r\n                }\r\n                if (this.hasTime)\r\n                    time[0] = feature.properties[this.timeVariable.getExternalName()];\r\n                for (let optional of this.optionalVariables)\r\n                    optionals.push(feature.properties[optional.getExternalName()]);\r\n\r\n                let row = [contValues, geometry, time, optionals];\r\n                if (!this.errorsAlreadyChecked) //Verify if has errors on Parsing Options\r\n                    this.hasErrors(row);\r\n\r\n                /*   if (this.findCombinationIndex(mvCombStr) === undefined)\r\n                      console.log(mvCombStr, i, feature, this.mapVarCombinations); */\r\n\r\n                this.mapVarCombinations[this.findCombinationIndex(mvCombStr)].addDataRow(row, this.geometryPrimitive);\r\n            }\r\n        } else {\r\n            for (let feature of geojson.features) {\r\n                if (i++ === limit)\r\n                    break;\r\n                let catValues = [];\r\n                let contValues = []; //Values of the continuous variables\r\n                let geometry = this.processFeature(feature);\r\n\r\n                let time = [];\r\n                let optionals = [];\r\n\r\n                for (let catVar of this.categoricalVariables) {\r\n                    let category = feature.properties[catVar.getExternalName()];\r\n                    if (catVar.classCalculationRequired())\r\n                        catVar.addCategory(category);\r\n                    catValues.push(category);\r\n                }\r\n                for (let contVar of this.continousVariables) {\r\n                    let contVarValue = feature.properties[contVar.getExternalName()]; //Value read from the continuous variable \r\n                    if (contVar.classCalculationRequired())\r\n                        contVar.setMinMax(contVarValue); //??\r\n                    else\r\n                        contVar.addValueToBins(contVarValue);\r\n\r\n                    contValues.push(contVarValue);\r\n                }\r\n\r\n                if (this.hasTime)\r\n                    time[0] = feature.properties[this.timeVariable.getExternalName()];  // time[0] = this.hasTime ? feature.properties[this.timeVariable.getExternalName()] : undefined;\r\n\r\n                for (let optional of this.optionalVariables)\r\n                    optionals.push(feature.properties[optional.getExternalName()]);\r\n\r\n                let row = [[catValues, contValues], geometry, time, optionals];\r\n                // console.log(row);\r\n                /*   if (!this.errorsAlreadyChecked) //Verify if has errors on Parsing Options\r\n                      this.hasErrors(row); */\r\n                this.addTransitoryData(row);\r\n            }\r\n        }\r\n        // this.numPoints = this.allPoints.length / 2;\r\n        console.log(this.allPoints, this.transitoryArray);\r\n        this.endParser('geojson');\r\n        console.timeEnd(\"geojsonParser\");\r\n    }\r\n\r\n    /**\r\n     * Process the GeoJSON file.\r\n     * @param {Object} fileData - The GeoJSON data that was read from the file. \r\n     * @memberof GeoJSONParser\r\n     */\r\n    processFileNew(fileData) {\r\n        let geojson = JSON.parse(fileData);\r\n        console.log(geojson);\r\n        console.time(\"geojsonParser\");\r\n        let i = 0,\r\n            limit = Number.MAX_SAFE_INTEGER; //In case we want to read only a part of the file\r\n\r\n        if (this.classCalculationRequired()) {\r\n            for (let feature of geojson.features) {\r\n                if (++i === limit)\r\n                    break;\r\n                // let mvCombStr = ''; //String that identifies the map variable combination\r\n                let catValues = [];\r\n                let contValues = []; //Values of the continuous variables\r\n                let geometry = this.processFeature(feature);\r\n\r\n                let time = [];\r\n                let optionals = [];\r\n\r\n                for (let catVar of this.categoricalVariables) {\r\n                    let category = feature.properties[catVar.getExternalName()];\r\n                    if (catVar.classCalculationRequired())\r\n                        catVar.addCategory(category);\r\n                    catValues.push(category);\r\n                }\r\n                for (let contVar of this.continousVariables) { //Cont Vars that DO NOT require class calculation\r\n                    let contVarValue = feature.properties[contVar.getExternalName()]; //Value read from the continuous variable \r\n                    if (contVar.classCalculationRequired())\r\n                        contVar.addValueToBins(contVarValue);\r\n                    //     mvCombStr += contVar.findClassIntervalIndex(contVarValue); // Class of contVarValue\r\n                    // else\r\n                    contVar.setMinMax(contVarValue);\r\n                    contValues.push(contVarValue);\r\n                }\r\n\r\n                if (this.hasTime)\r\n                    time[0] = GisplayDefaults.getGranule(feature.properties[this.timeVariable.getExternalName()]);  // time[0] = this.hasTime ? feature.properties[this.timeVariable.getExternalName()] : undefined;\r\n\r\n                for (let optional of this.optionalVariables)\r\n                    optionals.push(feature.properties[optional.getExternalName()]);\r\n\r\n                let row = [[catValues, contValues], geometry, time, optionals];\r\n                // console.log(row);\r\n                /*   if (!this.errorsAlreadyChecked) //Verify if has errors on Parsing Options\r\n                      this.hasErrors(row); */\r\n                /*  console.log(row);\r\n                 console.log(this.transitoryArray); */\r\n                this.addTransitoryData(row);\r\n            }\r\n        } else {\r\n\r\n        }\r\n        console.log(this.allPoints, this.transitoryArray);\r\n        this.endParser();\r\n        console.timeEnd(\"geojsonParser\");\r\n    }\r\n\r\n    /**\r\n     * Split each row that was read from the file to it's respective visual variable combination.\r\n     * @memberof Parser\r\n     */\r\n    splitTransitoryData() {\r\n        console.time(\"splitTransitoryData\");\r\n        // console.log(\"CATVAR\", this.categoricalVariables[0].classCalculationRequired());\r\n        for (let catVar of this.categoricalVariables)\r\n            if (catVar.classCalculationRequired())\r\n                catVar.updateCategoricalInformation(); //Only if its color\r\n\r\n        for (let i = 0; i < this.continousVariables.length; i++) {\r\n            let contVar = this.continousVariables[i];\r\n            if (contVar.classCalculationRequired()) {  //For each cont var that needs class cal then calculate\r\n                contVar.createBins();\r\n                for (let subArray of this.transitoryArray)\r\n                    for (let row of subArray)\r\n                        contVar.addValueToBins(row[0][1][i]);\r\n            }\r\n            contVar.calculateClasses();\r\n        }\r\n\r\n        if (this.timeVariable) {\r\n            this.timeVariable.createTemporalGranulesMap(this.timeVariable.getTemporalGranulesSet());\r\n            this.timeVariable.sortTemporalGranules();\r\n        }\r\n\r\n        //Calculate and create VVCombinations and indexMap\r\n        this.createMapVariableCombinations();\r\n\r\n        //for takes 2.5 seconds for 1M rows (with points )\r\n        console.time(\"for\");\r\n        //Split data to it's respective VVCombination\r\n        for (let subArray of this.transitoryArray) {\r\n            for (let row of subArray) {\r\n                let vvCombStr = '';\r\n                let indexCat = 0;\r\n                for (let catVar of this.categoricalVariables)\r\n                    vvCombStr += catVar.findIndex(row[0][0][indexCat++]);\r\n                let indexCont = 0;\r\n                for (let contVar of this.continousVariables)\r\n                    vvCombStr += contVar.findClassIntervalIndex(row[0][1][indexCont++]);\r\n                row[0] = row[0][1];\r\n                this.mapVarCombinations[this.findCombinationIndex(vvCombStr)].addDataRow(row, this.geometryPrimitive);\r\n                // break; // <<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n            }\r\n        }\r\n        console.timeEnd(\"for\");\r\n\r\n        console.timeEnd(\"splitTransitoryData\");\r\n        // console.log(this);\r\n        // delete this.transitoryArray;\r\n    }\r\n\r\n    /**\r\n     * Process point or polygon.\r\n     * @param {Object} feature - The feature to process.\r\n     * @returns {Polygon|Array<number>} - The processed polygon or the point coordinates.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    processFeature(feature) {\r\n        if (this.geometryPrimitive === undefined)\r\n            this._setGeometryPrimitive(feature.geometry.type);\r\n\r\n        if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\r\n            return this.processPolygon(feature);\r\n        } else if (feature.geometry.type === 'Point') {\r\n            return this.processPoint(feature);\r\n        } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\r\n            return this.processLine(feature);\r\n        }\r\n        else\r\n            throw new GisplayError(\"GeoJSON feature is not a Polygon, a Point or a Line\");\r\n    }\r\n\r\n    /**\r\n     * Returns the point and it's RGBA color.\r\n     * @param {{geometry: JSON, properties: JSON}} point - The geometry and properties of the point.\r\n     * @returns {{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - The point coordinates and the RGBA that identifies it.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    processPoint(point) {\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        return { spatial: point.geometry.coordinates, RGBA };\r\n    }\r\n\r\n    /**\r\n     * Set the type of geometry primitive for the data read. Only need to be called once. \r\n     * @param {string} geometryType - The type of geometry. \r\n     * @memberof GeoJSONParser\r\n     */\r\n    _setGeometryPrimitive(geometryType) {\r\n        switch (geometryType) {\r\n            case 'Point':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().POINT;\r\n                break;\r\n            case 'Polygon':\r\n            case 'MultiPolygon':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().POLYGON;\r\n                break;\r\n            case 'LineString':\r\n            case 'MultiLineString':\r\n                this.geometryPrimitive = GisplayDefaults.getPrimitive().LINE;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the polygon points to the array of all polygon points and saves the polygon borders and triangulation indices.\r\n     * The triangles and vertices calculated by earcut triangulation.\r\n     * @param {{geometry: JSON, properties: JSON}} polygon - The geometry and properties of the polygon.\r\n     * @returns {{spatial: {polygonIndices:Array<number>, bordersIndices:Array<number>}, RGBA:Array<number>}} - An array of Polygons and the RGBA color that identifies said polygon. Each polygon has it's indices (triangles and borders) in the allPoints array.\r\n     * @see http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons\r\n     * @see https://github.com/mapbox/earcut/\r\n     * @memberOf GeoJSONParser\r\n     */\r\n    processPolygon(polygon) {\r\n        let polygonIndices = [], //Vertices given by earcut\r\n            bordersIndices = []; //Save all triangles for the processed polygon or multipolygon\r\n\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        if (polygon.geometry.type === \"Polygon\") { //@TODO: [Demos never use this if statement.]\r\n\r\n            let outsidepolygon = polygon.geometry.coordinates[0]; //See: http://geojson.org/geojson-spec.html#polygon\r\n            let tempVerts = new Array(); //THIS POLYGON\r\n\r\n            for (let out = 0; out < outsidepolygon.length - 1; out++) {\r\n                tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\r\n                this.allPoints.push(outsidepolygon[out][0], outsidepolygon[out][1]);\r\n                this.allColors.push(...RGBA);\r\n            }\r\n            /* tempVerts.pop();\r\n            tempVerts.pop();\r\n            this.allPoints.pop();\r\n            this.allPoints.pop(); */\r\n\r\n            let earcutVertices = earcut(tempVerts);\r\n            let finalVertices = earcutVertices.map((e) => e + this.initialIndex);\r\n            for (let finalVertex of finalVertices)\r\n                polygonIndices.push(finalVertex);\r\n\r\n            this._createBorders(tempVerts.length / 2, bordersIndices);\r\n            this.initialIndex += tempVerts.length / 2;\r\n        }\r\n        else if (polygon.geometry.type == \"MultiPolygon\") { //See http://geojson.org/geojson-spec.html#multipolygon\r\n            for (const cs of polygon.geometry.coordinates) { //For each polygon\r\n                let tempVerts = new Array();\r\n\r\n                let outsidepolygon = cs[0];\r\n                for (const c of outsidepolygon) {\r\n                    tempVerts.push(c[0], c[1]);\r\n                    this.allPoints.push(c[0], c[1]);\r\n                    this.allColors.push(...RGBA);\r\n                }\r\n\r\n                /*  tempVerts.pop();\r\n                 tempVerts.pop();\r\n                 this.allPoints.pop();\r\n                 this.allPoints.pop(); */\r\n\r\n                let earcutVertices = earcut(tempVerts);\r\n                console.log(earcutVertices);\r\n                let finalVertices = earcutVertices.map((e) => e + this.initialIndex);\r\n                for (let finalVertex of finalVertices)\r\n                    polygonIndices.push(finalVertex);\r\n\r\n                this._createBorders(tempVerts.length / 2, bordersIndices);\r\n                this.initialIndex += (tempVerts.length / 2); //Update the first index for the next polygon\r\n            }\r\n        }\r\n        return { spatial: { polygonIndices, bordersIndices }, RGBA };\r\n    }\r\n\r\n    /**\r\n     * Create the border indices for the polygon starting at it's initial index.\r\n     * @param {number} numVertices - The number of vertices of the polygon. \r\n     * @param {Array<number>} bordersIndices - The array of indices. If it's a multipolygon it might contain some indices otherwise it's empty.\r\n     * @memberof GeoJSONParser\r\n     */\r\n    _createBorders(numVertices, bordersIndices) {\r\n        //Loop tempVerts and look create indices for this \r\n        bordersIndices.push(this.initialIndex);\r\n        let currentIndex = this.initialIndex;\r\n        for (let i = 1; i < numVertices; i++) {\r\n            currentIndex++;\r\n            bordersIndices.push(currentIndex, currentIndex);\r\n        }\r\n        bordersIndices.push(this.initialIndex);\r\n    }\r\n\r\n    /**\r\n     * Process the line (LineString or MultiLineString).\r\n     * @param {{geometry: JSON, properties: JSON}} feature - The GeoJSON Feature. \r\n     * @returns  {{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - the line (array of points) or a group of lines (array of arrays of points).\r\n     * @see http://wiki.geojson.org/GeoJSON_draft_version_6#MultiLineString\r\n     * @memberof GeoJSONParser\r\n     */\r\n    processLine(feature) {\r\n        let lineIndices = [];\r\n        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);\r\n        if (feature.geometry.type === 'LineString') {\r\n            /**\r\n                 {\r\n                    \"type\": \"LineString\",\r\n                    \"coordinates\": [\r\n                        [100.0, 0.0], [101.0, 1.0]\r\n                    ]\r\n                }\r\n            */\r\n            let lngLatPoints = [];\r\n            for (const pt of feature.geometry.coordinates) {\r\n                lngLatPoints.push(pt[0], pt[1]); //Push lng,lat\r\n                this.allPoints.push(pt[0], pt[1]);\r\n                this.allColors.push(...RGBA);\r\n            }\r\n\r\n            this._createLines(lngLatPoints.length / 2, lineIndices);\r\n            this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line\r\n        }\r\n        else {\r\n            /**\r\n                {\r\n                    \"type\": \"MultiLineString\",\r\n                    \"coordinates\": [\r\n                        [ [100.0, 0.0], [101.0, 1.0] ],\r\n                        [ [102.0, 2.0], [103.0, 3.0] ]\r\n                    ]\r\n                }\r\n             */\r\n            for (const line of feature.geometry.coordinates) { //Loop over each line inside multiLineStr\r\n                let lngLatPoints = [];\r\n                for (const pt of line) { //Loop over each point of this line\r\n                    lngLatPoints.push(pt[0], pt[1]); //Push lng/lat\r\n                    this.allPoints.push(pt[0], pt[1]);\r\n                    this.allColors.push(...RGBA);\r\n                }\r\n                // points.push(linePoints);// [[100, 0, 101, 1], [102, 2, 103, 3]]\r\n\r\n                this._createLines(lngLatPoints.length / 2, lineIndices);\r\n                this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line\r\n            }\r\n        }\r\n        return { spatial: { lineIndices }, RGBA };//this.bindLineToWebGLContext(points);\r\n    }\r\n\r\n    /**\r\n     * Create line segments between each two indices.\r\n     * @param {number} numIndices - The number of indices to add.\r\n     * @param {Array<number>} lineIndices - The indices for the line (If it's a multilinestring may already contain indices).\r\n     * @memberof GeoJSONIdsParser\r\n     */\r\n    _createLines(numIndices, lineIndices) {\r\n        lineIndices.push(this.initialIndex);\r\n        let currentIndex = this.initialIndex;\r\n        for (let i = 1; i < numIndices - 1; i++) {\r\n            currentIndex++;\r\n            lineIndices.push(currentIndex, currentIndex);\r\n        }\r\n        lineIndices.push(++currentIndex);\r\n    }\r\n\r\n    /**\r\n     * Split Transitory data, join points if needed and dispatch the parser end event.\r\n     * @memberof Parser\r\n     */\r\n    endParser() {\r\n        if (this.classCalculationRequired())\r\n            this.splitTransitoryData();\r\n\r\n        this.setGeometryPrimitiveTGs(); //Set the type of Geo for each TG (same as this.geoPrimitive)\r\n\r\n        if (GisplayDefaults.hasPolygons(this.geometryPrimitive) || GisplayDefaults.hasLines(this.geometryPrimitive)) {\r\n            this.joinAllPoints();\r\n            this.joinAllColors();\r\n        } else //POINTS\r\n            this.joinPickingColors();\r\n\r\n        this.setNumElementsTemporalGranules();\r\n\r\n        console.time(\"joinDATA\");\r\n        this.joinMapVarCombinationData();\r\n        console.timeEnd(\"joinDATA\");\r\n\r\n        this.dispatchParseEndEvent();\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 633,
    "kind": "variable",
    "name": "earcut",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~earcut",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 634,
    "kind": "class",
    "name": "GeoJSONParser",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/GeoJSON/GeoJSONParser.js",
    "importStyle": "{GeoJSONParser}",
    "description": "GeoJSON Parser.",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GeoJSONParser"
      }
    ],
    "interface": false,
    "extends": [
      "src/Gisplay/Parser/Parser.js~Parser"
    ]
  },
  {
    "__docId__": 635,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#constructor",
    "access": "public",
    "description": "Creates an instance of GeoJSONParser.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayOptions",
        "description": "The options class."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webgl",
        "description": "The WebGLRenderingContext."
      }
    ]
  },
  {
    "__docId__": 636,
    "kind": "member",
    "name": "RGBAColorNumber",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#RGBAColorNumber",
    "access": "public",
    "description": "The color number to be used for each polygon/line that is read from the file.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 637,
    "kind": "member",
    "name": "initialIndex",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#initialIndex",
    "access": "public",
    "description": "The initial index for the polygons or lines.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 638,
    "kind": "member",
    "name": "transitoryArray",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#transitoryArray",
    "access": "public",
    "description": "The transitory array that holds data temporarily. ",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "Array<Object>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 639,
    "kind": "member",
    "name": "maxArrayLength",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#maxArrayLength",
    "access": "public",
    "description": "This is the maximum length of each array of the transitory data array.\nWhy 100K? Because, when we have arrays with millions of positions this slows down the access.\n[ [       ], [            ], [....   ]\n  0   99999  100K   199999  200K...",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 640,
    "kind": "member",
    "name": "countTempRows",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#countTempRows",
    "access": "public",
    "description": "The number of rows/features read from the file.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 641,
    "kind": "member",
    "name": "currentTransitoryArrayIndex",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#currentTransitoryArrayIndex",
    "access": "public",
    "description": "The index inside the ",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 642,
    "kind": "member",
    "name": "reader",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#reader",
    "access": "public",
    "description": "The Filereader.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 643,
    "kind": "member",
    "name": "data",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#data",
    "access": "public",
    "description": "Hold data while we calculate the classes.",
    "lineNumber": 68
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "createFileReader",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#createFileReader",
    "access": "public",
    "description": "Creates a FileReader object and adds the load and error events.",
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{FileReader} - The Filereader object which will be used to read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileReader"
      ],
      "spread": false,
      "description": "The Filereader object which will be used to read from the file."
    }
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "processFile",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processFile",
    "access": "public",
    "description": "Process the GeoJSON file.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fileData",
        "description": "The GeoJSON data that was read from the file."
      }
    ]
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "processFileNew",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processFileNew",
    "access": "public",
    "description": "Process the GeoJSON file.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "fileData",
        "description": "The GeoJSON data that was read from the file."
      }
    ]
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "splitTransitoryData",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#splitTransitoryData",
    "access": "public",
    "description": "Split each row that was read from the file to it's respective visual variable combination.",
    "lineNumber": 240
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "processFeature",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processFeature",
    "access": "public",
    "description": "Process point or polygon.",
    "lineNumber": 296,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Polygon|Array<number>} - The processed polygon or the point coordinates."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "feature",
        "description": "The feature to process."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Polygon",
        "Array<number>"
      ],
      "spread": false,
      "description": "The processed polygon or the point coordinates."
    }
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "processPoint",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processPoint",
    "access": "public",
    "description": "Returns the point and it's RGBA color.",
    "lineNumber": 317,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - The point coordinates and the RGBA that identifies it."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometry: JSON, properties: JSON}"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": "The geometry and properties of the point."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}"
      ],
      "spread": false,
      "description": "The point coordinates and the RGBA that identifies it."
    }
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "_setGeometryPrimitive",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#_setGeometryPrimitive",
    "access": "private",
    "description": "Set the type of geometry primitive for the data read. Only need to be called once. ",
    "lineNumber": 327,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryType",
        "description": "The type of geometry."
      }
    ]
  },
  {
    "__docId__": 651,
    "kind": "member",
    "name": "geometryPrimitive",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#geometryPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 330,
    "undocument": true
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "processPolygon",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processPolygon",
    "access": "public",
    "description": "Add the polygon points to the array of all polygon points and saves the polygon borders and triangulation indices.\nThe triangles and vertices calculated by earcut triangulation.",
    "see": [
      "http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons",
      "https://github.com/mapbox/earcut/"
    ],
    "lineNumber": 352,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{spatial: {polygonIndices:Array<number>, bordersIndices:Array<number>}, RGBA:Array<number>}} - An array of Polygons and the RGBA color that identifies said polygon. Each polygon has it's indices (triangles and borders) in the allPoints array."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "GeoJSONParser"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometry: JSON, properties: JSON}"
        ],
        "spread": false,
        "optional": false,
        "name": "polygon",
        "description": "The geometry and properties of the polygon."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{spatial: {polygonIndices:Array<number>, bordersIndices:Array<number>}, RGBA:Array<number>}"
      ],
      "spread": false,
      "description": "An array of Polygons and the RGBA color that identifies said polygon. Each polygon has it's indices (triangles and borders) in the allPoints array."
    }
  },
  {
    "__docId__": 657,
    "kind": "method",
    "name": "_createBorders",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#_createBorders",
    "access": "private",
    "description": "Create the border indices for the polygon starting at it's initial index.",
    "lineNumber": 415,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numVertices",
        "description": "The number of vertices of the polygon."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "bordersIndices",
        "description": "The array of indices. If it's a multipolygon it might contain some indices otherwise it's empty."
      }
    ]
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "processLine",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#processLine",
    "access": "public",
    "description": "Process the line (LineString or MultiLineString).",
    "see": [
      "http://wiki.geojson.org/GeoJSON_draft_version_6#MultiLineString"
    ],
    "lineNumber": 433,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}} - the line (array of points) or a group of lines (array of arrays of points)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{geometry: JSON, properties: JSON}"
        ],
        "spread": false,
        "optional": false,
        "name": "feature",
        "description": "The GeoJSON Feature."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{spatial: {lineIndices:Array<number>}, RGBA:Array<number>}"
      ],
      "spread": false,
      "description": "the line (array of points) or a group of lines (array of arrays of points)."
    }
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "_createLines",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#_createLines",
    "access": "private",
    "description": "Create line segments between each two indices.",
    "lineNumber": 487,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numIndices",
        "description": "The number of indices to add."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "lineIndices",
        "description": "The indices for the line (If it's a multilinestring may already contain indices)."
      }
    ]
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "endParser",
    "memberof": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser#endParser",
    "access": "public",
    "description": "Split Transitory data, join points if needed and dispatch the parser end event.",
    "lineNumber": 501
  },
  {
    "__docId__": 663,
    "kind": "file",
    "name": "src/Gisplay/Parser/Parser.js",
    "content": "//Import for Intellisense\r\nimport { URLVariable } from '../VVs/URLVariable';\r\nimport { DataVariable } from '../VVs/DataVariable';\r\nimport { TimeVariable } from '../VVs/TimeVariable';\r\nimport { CategoricalVariable } from '../VVs/CategoricalVariable';\r\nimport { ContinuousVariable } from '../VVs/ContinuousVariable';\r\n\r\nimport { MapVariableCombination } from '../VVs/MapVariableCombination';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayOptions } from '../GisplayOptions';\r\nimport { GisplayError } from '../GisplayError';\r\n\r\n/**\r\n * General parser class.\r\n * @class Parser\r\n */\r\nexport class Parser {\r\n\r\n    /**\r\n     * Creates an instance of Parser.\r\n     * @param {GisplayOptions} gisplayOptions - The options class.\r\n     * @param {WebGLRenderingContext} webgl - The WebGLRenderingContext.\r\n     * @memberof Parser\r\n     */\r\n    constructor(gisplayOptions, webgl) {\r\n        /**\r\n         * All the options for the Gisplay AAPI.\r\n         * @type {GisplayOptions}\r\n         */\r\n        this.opts = gisplayOptions;\r\n        /**\r\n         * All the categorical variables that were created with the given options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\r\n        this.categoricalVariables = this.opts.getCategoricalVariables();\r\n        /**\r\n         * All the continuous variables that were created with the given options.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\r\n        this.continousVariables = this.opts.getContinousVariables();\r\n        /**\r\n         * The time variable or null if there's no Time in the dataset.\r\n         * @type {TimeVariable}\r\n         */\r\n        this.timeVariable = this.opts.getTimeVariable();\r\n        /**\r\n         * An array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable.\r\n         * @type Array<Variable>}\r\n         */\r\n        this.optionalVariables = this.opts.getOptionalVariables();\r\n        /**\r\n         * The URLVariable.\r\n         * @type {URLVariable} \r\n         */\r\n        this.urlVariable = this.opts.getURLVariable();\r\n        /**\r\n         * The geometry variables (longitude and latitude).\r\n         * @type {Array<DataVariable>}\r\n         */\r\n        this.geometryVariables = this.opts.getGeometryVariables();\r\n\r\n        let URLVariable = this.urlVariable;\r\n        /**\r\n         * The file with the data.\r\n         * @type {File}\r\n         */\r\n        this.dataFile = URLVariable.getDataFile();\r\n        /**\r\n         * The size of the file in bytes.\r\n         * @type {number}\r\n         */\r\n        this.fileSize = URLVariable.getDataFileSize();\r\n        /**\r\n         * The name of the file.\r\n         * @type {string}\r\n         */\r\n        this.fileName = URLVariable.getDataFileName();\r\n\r\n        /**\r\n         * The WebGLRenderingContext.\r\n         * @type {WebGLRenderingContext}\r\n         */\r\n        this.webglContext = webgl;\r\n        /**\r\n         * The dataset contains time or not.\r\n         * @type {boolean}\r\n         */\r\n        this.hasTime = this.timeVariable ? true : false;\r\n\r\n        //COMBINATIONS\r\n        /**\r\n         * Map where each key is a combination string and it's value is the index of it's position in the visual variable combinations array.\r\n         * @type {Map<string, number>}\r\n         */\r\n        this.mapVarCombinationStrToIndexMap = new Map();\r\n        /**\r\n         * Array of visual variable combinations.\r\n         * @type {Array<MapVariableCombination>}\r\n         */\r\n        this.mapVarCombinations = [];\r\n        if (!this.classCalculationRequired())\r\n            this.createMapVariableCombinations(); //Call method to create VVCombinations and associated info\r\n\r\n        //SAVE DATA FOR POLYGONS OR LINES\r\n        /** \r\n         * The identifier of the type of primitive (Point, polygon or line).\r\n         * @type {number}\r\n         */\r\n        this.geometryPrimitive;\r\n        /** \r\n         * An array that holds all points of all polygons/lines. \r\n         * @type {Array<number>|WebGLBuffer}\r\n         */\r\n        this.allPoints = [];\r\n        /**\r\n         * An array that holds all colors for all polygons/lines. One color for each vertex.\r\n         * @type {Array<number>|WebGLBuffer}\r\n         */\r\n        this.allColors = [];\r\n    }\r\n\r\n    /**\r\n     * Returns true if there's the need to calculate the classes for any visual variable or not.\r\n     * @returns {boolean} true, if any continuous variable requires class calculation.\r\n     * @memberof GisplayOptions\r\n     */\r\n    classCalculationRequired() {\r\n        for (let catVariable of this.categoricalVariables)\r\n            if (catVariable.classCalculationRequired()) //If at least one cont or time \r\n                return true;\r\n        for (let contVariable of this.continousVariables)\r\n            if (contVariable.classCalculationRequired()) //If at least one cont or time \r\n                return true;\r\n        if (this.timeVariable)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Verify if the row has errors or not. This method is called by the respective Parser for each row or just for one row.\r\n     * The programmer may decide to never call this method if he is sure the given options are all correct.\r\n     * Basically will look if all given options (visual variables, Geometry, time and extra variables) are according to it's specification in the Parsing options.\r\n     * @param {Array<Object>} row - Any row given to look for existing errors.\r\n     * @memberof Parser\r\n     */\r\n    hasErrors(row) {\r\n        let [vvs, geo, time, optionals] = [...row];\r\n        let geometryExists = geo !== undefined;\r\n        let timeExists = time !== undefined && time.lenght === 1;\r\n\r\n        if (!geometryExists || (this.hasTime && !timeExists)\r\n            || !this.continousVariables && vvs[0].length > 0\r\n            || this.optionalVariables.length !== optionals.length) {\r\n            console.log(row);\r\n            throw new Error(\"Found errors parsing file.\");\r\n        }\r\n        this.errorsAlreadyChecked = true;\r\n    }\r\n\r\n    /**\r\n     * Create combinations of map variables. \r\n     * This method must only be executed when the classes for all continuous variables are calculated, otherwise it won't work.\r\n     * @see https://stackoverflow.com/a/33352604 - Create array with index 0..n-1\r\n     * @memberof Parser\r\n     */\r\n    createMapVariableCombinations() {\r\n        let categoricalVariables = this.categoricalVariables;\r\n        let continuousVariables = this.continousVariables;\r\n\r\n        let indices = [];\r\n        for (let catVar of categoricalVariables) {\r\n            let numCategories = catVar.getVisualVariableMapping().size;\r\n            indices.push([...Array(numCategories).keys()]); //.map(x => ++x) https://stackoverflow.com/a/33352604\r\n        }\r\n        for (let contVar of continuousVariables) {\r\n            let numIntervals = contVar.getClassIntervals().length;\r\n            indices.push([...Array(numIntervals).keys()]);\r\n        }\r\n\r\n        //Create visual variable combination strings\r\n        let vvCombinationStrs = this.generateVVCombinationStrings(indices);\r\n        let startingRGBAs = this.calculateStartingRGBAs(vvCombinationStrs.length);\r\n        // console.warn(startingRGBAs);\r\n        for (let [index, vvCombStr] of vvCombinationStrs.entries()) {\r\n            // console.warn(index, vvCombStr);\r\n            this.mapVarCombinations.push(\r\n                new MapVariableCombination(\r\n                    vvCombStr,\r\n                    [...categoricalVariables, ...continuousVariables],\r\n                    startingRGBAs[index],\r\n                    this.timeVariable ? Array(this.timeVariable.granuleIndex).keys() : [],\r\n                    this.webglContext,\r\n                    this.anyQualifierIsAttribute()\r\n                ));\r\n        }\r\n        // console.log(this.VVCombinations);\r\n        this.mapVarCombinationStrToIndexMap = this.createMVCombinationStrToIndexMap(vvCombinationStrs); // Create the combination string -> index map\r\n    }\r\n\r\n    /**\r\n     * Generates the visual variable combination strings.\r\n     * If there's only one visual variable then return it's indices as an array of strings, otherwise, if there's more than one \r\n     * visual variable, then call the recursive method.\r\n     * @param {Array<number>|Array<Array<number>>} indices \r\n     * @returns {Array<string>|Array<Array<string>>}\r\n     * @memberof Parser\r\n     */\r\n    generateVVCombinationStrings(indices) {\r\n        let vvCombinationStrs = [];\r\n        if (indices.length === 1)\r\n            for (let indice of indices[0])\r\n                vvCombinationStrs.push('' + indice);\r\n        else\r\n            vvCombinationStrs = this.generateVVCombinationStringsRec(indices);\r\n        return vvCombinationStrs;\r\n    }\r\n\r\n    /**\r\n     * Recursive method that generates all possible combinations of values, given the arrays of values possible values for each visual variable.\r\n     * These values can be indeces (0..n) of classes or categories and/or strings of categories.\r\n     * @param {Array<Array<string|number>>} visVarsValues - Array with visual variable values \r\n     * @returns {Array<string>} - the resulting combinations of the given values.\r\n     * @see https://stackoverflow.com/q/4331092\r\n     * @memberof Parser\r\n     */\r\n    generateVVCombinationStringsRec(visVarsValues) {\r\n        if (visVarsValues.lenght === 0)\r\n            return [];\r\n        else if (visVarsValues.length === 1)\r\n            return visVarsValues[0];\r\n        else {\r\n            let result = [];\r\n            let rec = this.generateVVCombinationStringsRec(visVarsValues.slice(1));\r\n            for (let i = 0; i < rec.length; i++)\r\n                for (let j = 0; j < visVarsValues[0].length; j++)\r\n                    result.push('' + visVarsValues[0][j] + rec[i]);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the first RGBA color for each visual variable combination.\r\n     * This first color can be used to quickly identify the containing visual variable combination of the clicked element (Picking).\r\n     * @param {number} nCombs - Number of combinations of visual variables. \r\n     * @returns {Array<Uint8Array>} - the color (RGBA) that starts \r\n     * @memberof Parser\r\n     */\r\n    calculateStartingRGBAs(nCombs) {\r\n        let colorPerCombination = Math.round(Math.pow(256, 4) / nCombs); //4MM / number combinations\r\n        let startingPoints = [];\r\n        let [r, g, b, a] = [0, 0, 0, 1];\r\n        startingPoints.push([r, g, b, a]);\r\n        for (let i = 1; i < nCombs; i++)\r\n            startingPoints.push(GisplayDefaults.numberToRGBA(i * colorPerCombination));\r\n        return startingPoints;\r\n    }\r\n\r\n    /**\r\n     * Creates a Map with as many keys as map variable combinations. \r\n     * Each combination will have an index generated sequentially.\r\n     * @param {Array<string>} combinations - The calculated combinations.\r\n     * @returns {Map<string, number>} - a map with each key being the map variable combination and the value is the respective index, generated sequentially.\r\n     * @memberof Parser\r\n     */\r\n    createMVCombinationStrToIndexMap(combinations) {\r\n        let associationMap = new Map();\r\n        let index = 0;\r\n        for (let combination of combinations)\r\n            associationMap.set(combination, index++);\r\n        return associationMap;\r\n    }\r\n\r\n    /**\r\n     * Retuns the index of the given visual variable combination string.\r\n     * @param {string} combinationString - The name of the visual variable combination.\r\n     * @returns {number} - the index of the given visual variable combination string. \r\n     * @memberof Parser\r\n     */\r\n    findCombinationIndex(combinationString) {\r\n        return this.mapVarCombinationStrToIndexMap.get(combinationString);\r\n    }\r\n\r\n    /**\r\n     * This is the event called when the data is completly processed and should be send back to the Map (type) to be drawn and used accordingly.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events\r\n     * @memberof Parser\r\n     */\r\n    dispatchParseEndEvent() {\r\n        console.log(\"ParserEnd event\");\r\n        document.dispatchEvent(new CustomEvent(\"parserEnd\", {  //Retornar pelo menos os dados processados e as classes \r\n            detail: {\r\n                mapVariableCombinations: this.mapVarCombinations,\r\n                mapVariableCombinationToIndexMap: this.mapVarCombinationStrToIndexMap,\r\n                categoricalVariables: this.categoricalVariables,\r\n                continousVariables: this.continousVariables,\r\n                allPoints: this.allPoints,\r\n                allColors: this.allColors\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Returns true if any of the continuous variables has 'attribute' qualifier on the shader.\r\n     * @returns {boolean} - true if any of the continuous variables has 'attribute' qualifier on the shader, false, otherwise.\r\n     * @memberof Parser\r\n     */\r\n    anyQualifierIsAttribute() {\r\n        return this.continousVariables.filter((cv) => cv.qualifierIsAttribute()).length > 0;\r\n    }\r\n\r\n    //DELETE THIS\r\n    /**\r\n     * Create transitory sub arrays\r\n     * @param {number} numElements - Number of elements on the dataset. \r\n     * @memberof Parser\r\n     */\r\n    createTransitoryDataArray(numElements) {\r\n        let numSubArrays = Math.ceil(numElements / (100 * 1000));\r\n        for (let i = 0; i < numSubArrays; i++)\r\n            this.transitoryArray[i] = [];\r\n        window.ta = this.transitoryArray; //TODO: DELETE\r\n    }\r\n\r\n    /**\r\n     * Add one row to the transitory data array.\r\n     * @param {Array<Object>} row - The row with visual variables, geometry, time (if exists) and extra variables (if any).\r\n     * @memberof Parser\r\n     */\r\n    addTransitoryData(row) {\r\n        if (this.countTempRows++ % (this.maxArrayLength) === 0 && this.countTempRows !== 1)\r\n            this.currentTransitoryArrayIndex++;\r\n        if (!this.transitoryArray[this.currentTransitoryArrayIndex]) //Create the sub-array if it does not exist\r\n            this.transitoryArray[this.currentTransitoryArrayIndex] = [];\r\n        this.transitoryArray[this.currentTransitoryArrayIndex].push(row);\r\n    }\r\n\r\n    /**\r\n     * Split each row that was read from the file to it's respective visual variable combination.\r\n     * @memberof Parser\r\n     */\r\n    splitTransitoryData_OLD() {\r\n        console.time(\"splitTransitoryData\");\r\n        //For each cont var that needs class cal then calculate\r\n        for (let contVar of this.continousVariables)\r\n            if (contVar.classCalculationRequired())\r\n                contVar.calculateClasses();\r\n\r\n        //Calculate and create VVCombinations and indexMap\r\n        this.createMapVariableCombinations();\r\n\r\n        //for takes 2.5 seconds for 1M rows (with points )\r\n        console.time(\"for\");\r\n        //Split data to it's respective VVCombination\r\n        for (let subArray of this.transitoryArray) {\r\n            for (let row of subArray) {\r\n                let vvCombStr = row[0][0];\r\n                let index = 0;\r\n                for (let contVar of this.continousVariables) {\r\n                    if (contVar.classCalculationRequired())\r\n                        vvCombStr += contVar.findClassIntervalIndex(row[0][1][index]);\r\n                    index++;\r\n                }\r\n                // console.log(row);\r\n                row[0] = row[0][1];\r\n                // console.log(row); // <<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n                this.mapVarCombinations[this.findCombinationIndex(vvCombStr)].addDataRow(row);\r\n                // break; // <<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n            }\r\n        }\r\n        console.timeEnd(\"for\");\r\n\r\n        console.timeEnd(\"splitTransitoryData\");\r\n        // console.log(this);\r\n        // delete this.transitoryArray;\r\n    }\r\n\r\n    /**\r\n     * Split each row that was read from the file to it's respective visual variable combination.\r\n     * @memberof Parser\r\n     */\r\n    splitTransitoryData() {\r\n        throw new GisplayError('Not yet implemented method to split transitory data array for this parser');\r\n    }\r\n\r\n    /**\r\n     * For each temporal granularity inside of each visual variable combination, join all data points in a single WebGLBuffer.\r\n     * @memberof Parser\r\n     */\r\n    joinMapVarCombinationData() {\r\n        for (const mvc of this.mapVarCombinations)\r\n            mvc.joinTemporalGranuleData(this.webglContext, this.geometryPrimitive);\r\n    }\r\n\r\n    /**\r\n     * If the primitive to draw are points then join all RGBA identifiers into one WebGLBuffer.\r\n     * @memberof Parser\r\n     */\r\n    joinPickingColors() {\r\n        for (const mvc of this.mapVarCombinations)\r\n            mvc.joinPickingColors();\r\n    }\r\n\r\n    /**\r\n     * For each temporal granule inside each map variable combination, update it's numElements variable.\r\n     * @memberof Parser\r\n     */\r\n    setNumElementsTemporalGranules() {\r\n        for (const mvc of this.mapVarCombinations)\r\n            for (const tg of mvc.getTemporalGranules())\r\n                tg.setNumElements();\r\n    }\r\n\r\n    /**\r\n     * Join all points of all polygons/lines into a single WebGL buffer.\r\n     * @memberof Parser\r\n     */\r\n    joinAllPoints() {\r\n        let webglContext = this.webglContext;\r\n        const vertArray = new Float32Array(this.allPoints);\r\n        const bufferP = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);\r\n        this.allPoints = bufferP;\r\n    }\r\n\r\n    /**\r\n     * Join all points of all polygons/lines into a single WebGL buffer.\r\n     * @memberof Parser\r\n     */\r\n    joinAllColors() {\r\n        let webglContext = this.webglContext;\r\n        const vertArray = new Uint8Array(this.allColors);\r\n        const bufferP = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);\r\n        this.allColors = bufferP;\r\n    }\r\n\r\n    /**\r\n     * Set the geometry primitive of each Temporal Granule.\r\n     * @memberof Parser\r\n     */\r\n    setGeometryPrimitiveTGs() {\r\n        // console.error(this.geometryPrimitive);\r\n        for (const mvc of this.mapVarCombinations)\r\n            for (const tg of mvc.getTemporalGranules())\r\n                tg.setGeometryPrimitive(this.geometryPrimitive);\r\n    }\r\n\r\n    /**\r\n     * Split Transitory data, join points if needed and dispatch the parser end event.\r\n     * @memberof Parser\r\n     */\r\n    endParser(parserName) {\r\n        // console.error(this.transitoryArray);\r\n        throw new GisplayError(`Parser has no endParser method...`);\r\n        /*     switch (parserName) {\r\n                case 'csv': {\r\n                    if (this.urlVariable.hasIds()) {\r\n                        console.error(\"HASURLS\");\r\n                        console.log(this.mapVarCombinations);\r\n                        this.dispatchParseEndEvent();\r\n                    }\r\n                    else {\r\n                        this.setGeometryPrimitiveTGs();\r\n    \r\n                        this.setNumElementsTemporalGranules();\r\n                        console.time(\"joinPoints\");\r\n                        // this.geometryPrimitive = 0;\r\n                        if (this.geometryVariables.length > 1) {\r\n                            this.joinMapVarCombinationData();\r\n                            this.joinPickingColors();\r\n                        }\r\n                        console.timeEnd(\"joinPoints\");\r\n                        this.dispatchParseEndEvent(); //TODO: Move to the end of the Map?\r\n                    }\r\n                    break;\r\n                }\r\n                case 'geojson': {\r\n                    if (this.classCalculationRequired())\r\n                        this.splitTransitoryData();\r\n    \r\n                    this.setGeometryPrimitiveTGs(); //Set the type of Geo for each TG (same as this.geoPrimitive)\r\n                   \r\n                    if (GisplayDefaults.hasPolygons(this.geometryPrimitive) || GisplayDefaults.hasLines(this.geometryPrimitive)){\r\n                        this.joinAllPoints();\r\n                        this.joinAllColors();\r\n                    } else{\r\n                        this.joinPickingColors();\r\n                    }\r\n    \r\n                    this.setNumElementsTemporalGranules();\r\n    \r\n                    console.time(\"joinDATA\");\r\n                    this.joinMapVarCombinationData();\r\n                    console.timeEnd(\"joinDATA\");\r\n                    this.dispatchParseEndEvent();\r\n                    break;\r\n                }\r\n            } */\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Parser/Parser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 664,
    "kind": "class",
    "name": "Parser",
    "memberof": "src/Gisplay/Parser/Parser.js",
    "static": true,
    "longname": "src/Gisplay/Parser/Parser.js~Parser",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Parser/Parser.js",
    "importStyle": "{Parser}",
    "description": "General parser class.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Parser"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 665,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#constructor",
    "access": "public",
    "description": "Creates an instance of Parser.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "GisplayOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayOptions",
        "description": "The options class."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webgl",
        "description": "The WebGLRenderingContext."
      }
    ]
  },
  {
    "__docId__": 666,
    "kind": "member",
    "name": "opts",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#opts",
    "access": "public",
    "description": "All the options for the Gisplay AAPI.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "GisplayOptions"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 667,
    "kind": "member",
    "name": "categoricalVariables",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#categoricalVariables",
    "access": "public",
    "description": "All the categorical variables that were created with the given options.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "Array<CategoricalVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 668,
    "kind": "member",
    "name": "continousVariables",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#continousVariables",
    "access": "public",
    "description": "All the continuous variables that were created with the given options.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "Array<ContinuousVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 669,
    "kind": "member",
    "name": "timeVariable",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#timeVariable",
    "access": "public",
    "description": "The time variable or null if there's no Time in the dataset.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "TimeVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 670,
    "kind": "member",
    "name": "optionalVariables",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#optionalVariables",
    "access": "public",
    "description": "An array with extra variables used mainly for picking information or an empty array when the programmer didn't give any extra variable.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 671,
    "kind": "member",
    "name": "urlVariable",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#urlVariable",
    "access": "public",
    "description": "The URLVariable.",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "URLVariable"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 672,
    "kind": "member",
    "name": "geometryVariables",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#geometryVariables",
    "access": "public",
    "description": "The geometry variables (longitude and latitude).",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "Array<DataVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 673,
    "kind": "member",
    "name": "dataFile",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#dataFile",
    "access": "public",
    "description": "The file with the data.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "File"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 674,
    "kind": "member",
    "name": "fileSize",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#fileSize",
    "access": "public",
    "description": "The size of the file in bytes.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "fileName",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#fileName",
    "access": "public",
    "description": "The name of the file.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 676,
    "kind": "member",
    "name": "webglContext",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#webglContext",
    "access": "public",
    "description": "The WebGLRenderingContext.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "WebGLRenderingContext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 677,
    "kind": "member",
    "name": "hasTime",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#hasTime",
    "access": "public",
    "description": "The dataset contains time or not.",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 678,
    "kind": "member",
    "name": "mapVarCombinationStrToIndexMap",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#mapVarCombinationStrToIndexMap",
    "access": "public",
    "description": "Map where each key is a combination string and it's value is the index of it's position in the visual variable combinations array.",
    "lineNumber": 95,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 679,
    "kind": "member",
    "name": "mapVarCombinations",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#mapVarCombinations",
    "access": "public",
    "description": "Array of visual variable combinations.",
    "lineNumber": 100,
    "type": {
      "nullable": null,
      "types": [
        "Array<MapVariableCombination>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 680,
    "kind": "member",
    "name": "allPoints",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#allPoints",
    "access": "public",
    "description": "An array that holds all points of all polygons/lines. ",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>",
        "WebGLBuffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 681,
    "kind": "member",
    "name": "allColors",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#allColors",
    "access": "public",
    "description": "An array that holds all colors for all polygons/lines. One color for each vertex.",
    "lineNumber": 119,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>",
        "WebGLBuffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 682,
    "kind": "method",
    "name": "classCalculationRequired",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#classCalculationRequired",
    "access": "public",
    "description": "Returns true if there's the need to calculate the classes for any visual variable or not.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} true, if any continuous variable requires class calculation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if any continuous variable requires class calculation."
    }
  },
  {
    "__docId__": 683,
    "kind": "method",
    "name": "hasErrors",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#hasErrors",
    "access": "public",
    "description": "Verify if the row has errors or not. This method is called by the respective Parser for each row or just for one row.\nThe programmer may decide to never call this method if he is sure the given options are all correct.\nBasically will look if all given options (visual variables, Geometry, time and extra variables) are according to it's specification in the Parsing options.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "Any row given to look for existing errors."
      }
    ]
  },
  {
    "__docId__": 684,
    "kind": "member",
    "name": "errorsAlreadyChecked",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#errorsAlreadyChecked",
    "access": "public",
    "description": null,
    "lineNumber": 157,
    "undocument": true
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "createMapVariableCombinations",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#createMapVariableCombinations",
    "access": "public",
    "description": "Create combinations of map variables. \nThis method must only be executed when the classes for all continuous variables are calculated, otherwise it won't work.",
    "see": [
      "https://stackoverflow.com/a/33352604 - Create array with index 0..n-1"
    ],
    "lineNumber": 166
  },
  {
    "__docId__": 687,
    "kind": "method",
    "name": "generateVVCombinationStrings",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#generateVVCombinationStrings",
    "access": "public",
    "description": "Generates the visual variable combination strings.\nIf there's only one visual variable then return it's indices as an array of strings, otherwise, if there's more than one \nvisual variable, then call the recursive method.",
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>|Array<Array<string>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>|Array<Array<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "indices",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>|Array<Array<string>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "generateVVCombinationStringsRec",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#generateVVCombinationStringsRec",
    "access": "public",
    "description": "Recursive method that generates all possible combinations of values, given the arrays of values possible values for each visual variable.\nThese values can be indeces (0..n) of classes or categories and/or strings of categories.",
    "see": [
      "https://stackoverflow.com/q/4331092"
    ],
    "lineNumber": 226,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the resulting combinations of the given values."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Array<string|number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "visVarsValues",
        "description": "Array with visual variable values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the resulting combinations of the given values."
    }
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "calculateStartingRGBAs",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#calculateStartingRGBAs",
    "access": "public",
    "description": "Calculates the first RGBA color for each visual variable combination.\nThis first color can be used to quickly identify the containing visual variable combination of the clicked element (Picking).",
    "lineNumber": 248,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Uint8Array>} - the color (RGBA) that starts "
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nCombs",
        "description": "Number of combinations of visual variables."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Uint8Array>"
      ],
      "spread": false,
      "description": "the color (RGBA) that starts"
    }
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "createMVCombinationStrToIndexMap",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#createMVCombinationStrToIndexMap",
    "access": "public",
    "description": "Creates a Map with as many keys as map variable combinations. \nEach combination will have an index generated sequentially.",
    "lineNumber": 265,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<string, number>} - a map with each key being the map variable combination and the value is the respective index, generated sequentially."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "combinations",
        "description": "The calculated combinations."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": "a map with each key being the map variable combination and the value is the respective index, generated sequentially."
    }
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "findCombinationIndex",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#findCombinationIndex",
    "access": "public",
    "description": "Retuns the index of the given visual variable combination string.",
    "lineNumber": 279,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given visual variable combination string. "
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "combinationString",
        "description": "The name of the visual variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given visual variable combination string."
    }
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "dispatchParseEndEvent",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#dispatchParseEndEvent",
    "access": "public",
    "description": "This is the event called when the data is completly processed and should be send back to the Map (type) to be drawn and used accordingly.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events"
    ],
    "lineNumber": 288
  },
  {
    "__docId__": 693,
    "kind": "method",
    "name": "anyQualifierIsAttribute",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#anyQualifierIsAttribute",
    "access": "public",
    "description": "Returns true if any of the continuous variables has 'attribute' qualifier on the shader.",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if any of the continuous variables has 'attribute' qualifier on the shader, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if any of the continuous variables has 'attribute' qualifier on the shader, false, otherwise."
    }
  },
  {
    "__docId__": 694,
    "kind": "method",
    "name": "createTransitoryDataArray",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#createTransitoryDataArray",
    "access": "public",
    "description": "Create transitory sub arrays",
    "lineNumber": 317,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numElements",
        "description": "Number of elements on the dataset."
      }
    ]
  },
  {
    "__docId__": 695,
    "kind": "method",
    "name": "addTransitoryData",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#addTransitoryData",
    "access": "public",
    "description": "Add one row to the transitory data array.",
    "lineNumber": 329,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "The row with visual variables, geometry, time (if exists) and extra variables (if any)."
      }
    ]
  },
  {
    "__docId__": 696,
    "kind": "method",
    "name": "splitTransitoryData_OLD",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#splitTransitoryData_OLD",
    "access": "public",
    "description": "Split each row that was read from the file to it's respective visual variable combination.",
    "lineNumber": 341
  },
  {
    "__docId__": 697,
    "kind": "method",
    "name": "splitTransitoryData",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#splitTransitoryData",
    "access": "public",
    "description": "Split each row that was read from the file to it's respective visual variable combination.",
    "lineNumber": 381
  },
  {
    "__docId__": 698,
    "kind": "method",
    "name": "joinMapVarCombinationData",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#joinMapVarCombinationData",
    "access": "public",
    "description": "For each temporal granularity inside of each visual variable combination, join all data points in a single WebGLBuffer.",
    "lineNumber": 389
  },
  {
    "__docId__": 699,
    "kind": "method",
    "name": "joinPickingColors",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#joinPickingColors",
    "access": "public",
    "description": "If the primitive to draw are points then join all RGBA identifiers into one WebGLBuffer.",
    "lineNumber": 398
  },
  {
    "__docId__": 700,
    "kind": "method",
    "name": "setNumElementsTemporalGranules",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#setNumElementsTemporalGranules",
    "access": "public",
    "description": "For each temporal granule inside each map variable combination, update it's numElements variable.",
    "lineNumber": 407
  },
  {
    "__docId__": 701,
    "kind": "method",
    "name": "joinAllPoints",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#joinAllPoints",
    "access": "public",
    "description": "Join all points of all polygons/lines into a single WebGL buffer.",
    "lineNumber": 417
  },
  {
    "__docId__": 703,
    "kind": "method",
    "name": "joinAllColors",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#joinAllColors",
    "access": "public",
    "description": "Join all points of all polygons/lines into a single WebGL buffer.",
    "lineNumber": 430
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "setGeometryPrimitiveTGs",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#setGeometryPrimitiveTGs",
    "access": "public",
    "description": "Set the geometry primitive of each Temporal Granule.",
    "lineNumber": 443
  },
  {
    "__docId__": 706,
    "kind": "method",
    "name": "endParser",
    "memberof": "src/Gisplay/Parser/Parser.js~Parser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Parser/Parser.js~Parser#endParser",
    "access": "public",
    "description": "Split Transitory data, join points if needed and dispatch the parser end event.",
    "lineNumber": 454
  },
  {
    "__docId__": 707,
    "kind": "file",
    "name": "src/Gisplay/Shaders/ShadersInfo.js",
    "content": "import { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayError } from '../GisplayError';\r\n\r\n/**\r\n * Contains all the information about the shaders currently in use.\r\n * @export\r\n * @class ShadersInfo\r\n */\r\nexport class ShadersInfo {\r\n\r\n    /**\r\n     * Creates an instance of ShadersInfo.\r\n     * @param {Array<{name:string, type:string, qualifier: string}>} vertexKeys - The vertex shader keys.\r\n     * @param {Array<{name:string, type:string, qualifier: string}>} fragmentKeys - The fragment shader keys.\r\n     * @memberof Shaders\r\n     */\r\n    constructor(vertexKeys, fragmentKeys) {\r\n        let vv_type = \"vv_type\"; //If we want to change from vv_type to other thing just change here\r\n        let shaderMap = new Map();\r\n        if (vertexKeys)\r\n            for (const key of vertexKeys)\r\n                shaderMap.set(key[vv_type], key);\r\n        if (fragmentKeys)\r\n            for (const key of fragmentKeys)\r\n                shaderMap.set(key[vv_type], key);\r\n        // console.log(shaderMap);\r\n\r\n        if (!vertexKeys && !fragmentKeys)\r\n            throw new GisplayError(\"No vertex or fragment shader variable information was found on shaders.json.\");\r\n\r\n        /**\r\n         * Contains all information that was processed for each variable in the vertex and fragment shaders.\r\n         * @type{Map<string, {name: string, type: number, qualifier: string}>}\r\n         */\r\n        this.shaderVariablesMap = shaderMap;\r\n        /**\r\n         * The position string on the vertex shader. All Gisplay shaders use the string 'position' as default.\r\n         * @type {string='position'}\r\n         */\r\n        this.positionString = GisplayDefaults.POSITION();\r\n        /**\r\n         * The matrix projection string on the vertex shader. All Gisplay shaders use the string 'Mproj' as default.\r\n         * @type {string='Mproj'}\r\n         */\r\n        this.matrixProjectionString = GisplayDefaults.MPROJ();\r\n        /**\r\n         * The color string on the fragment shader. Can be overriden by the user on the shaders.json file and respective shader.frag file.\r\n         * @type {string='color'}\r\n         */\r\n        this.colorString = shaderMap.get(GisplayDefaults.COLOR()) ? shaderMap.get(GisplayDefaults.COLOR()).name : GisplayDefaults.COLOR();\r\n        /**\r\n         * The opacity string on the fragment shader.\r\n         * @type {string='opacity'}\r\n         */\r\n        this.opacityString = shaderMap.get(GisplayDefaults.OPACITY()) ? shaderMap.get(GisplayDefaults.OPACITY()).name : GisplayDefaults.OPACITY();\r\n        /**\r\n         * The texture pattern string on the fragment shader.\r\n         * @type {string}\r\n         */\r\n        this.textureString = shaderMap.get(GisplayDefaults.TEXTURE()) ? shaderMap.get(GisplayDefaults.TEXTURE()).name : GisplayDefaults.TEXTURE();\r\n        /**\r\n         * The shape string on the fragment shader. \r\n         * @type {string}\r\n         */\r\n        this.shapeString = shaderMap.get(GisplayDefaults.SHAPE()) ? shaderMap.get(GisplayDefaults.SHAPE()).name : GisplayDefaults.SHAPE();\r\n        // console.error(shaderMap, this.shapeString);\r\n        /**\r\n         * The size string on the vertex shader.\r\n         * @type {string}\r\n         */\r\n        this.sizeString = shaderMap.get(GisplayDefaults.SIZE()) ? shaderMap.get(GisplayDefaults.SIZE()).name : GisplayDefaults.SIZE();\r\n        /**\r\n         * The orientation string on the fragment shader.\r\n         * @type {string}\r\n         */\r\n        this.orientationString = shaderMap.get(GisplayDefaults.ORIENTATION()) ? shaderMap.get(GisplayDefaults.ORIENTATION()).name : GisplayDefaults.ORIENTATION();\r\n    }\r\n\r\n    /**\r\n     * The name of the position variable on the vertex shader. By default all Gisplay API shaders \r\n     * use 'position' as the name for the position variable.\r\n     * @returns \r\n     * @memberof ShadersInfo\r\n     */\r\n    getPositionName() {\r\n        return this.positionString;\r\n    }\r\n\r\n    /**\r\n     * The name of the matrix projection variable on the vertex shader. By default all Gisplay API shaders\r\n     * use 'Mproj' as the name for the matrix projection variable.\r\n     * @returns \r\n     * @memberof ShadersInfo\r\n     */\r\n    getMatrixProjectionName() {\r\n        return this.matrixProjectionString;\r\n    }\r\n\r\n    /**\r\n     * The name of the color variable on the fragment shader. The API will try to use 'color' if none is given but there's no \r\n     * way to know if this is correct, and if it isn't then errors may occur.\r\n     * @returns {string} - the name of the color variable on the fragment shader.\r\n     * @memberof ShadersInfo\r\n     */\r\n    getColorName() {\r\n        return this.colorString;\r\n    }\r\n\r\n    /**\r\n     * The name of the opacity variable on the fragment shader. The API will try to use 'opacity' if none is given but there's no\r\n     * way to know if this is correct, and if it isn't then errors may occur.\r\n     * @returns {string} - the name of the opacity variable on the fragment shader.\r\n     * @memberof ShadersInfo\r\n     */\r\n    getOpacityName() {\r\n        return this.opacityString;\r\n    }\r\n\r\n    /**\r\n     * The name of the size variable on the vertex shader. The API will try to use 'size' if none is given but there's no\r\n     * way to know if this is correct, and if it isn't then errors may occur.\r\n     * @returns {string} - the name of the size variable on the vertex shader.\r\n     * @memberof ShadersInfo\r\n     */\r\n    getSizeVarName() {\r\n        return this.sizeString;\r\n    }\r\n\r\n    /**\r\n     * The name of the shape variable on the fragment shader. The API will try to use 'shape' if none is given but there's no\r\n     * way to know if this is correct, and if it isn't then errors may occur.\r\n     * @returns {string} - the name of the shape variable on the fragment shader.\r\n     * @memberof ShadersInfo\r\n     */\r\n    getShapeName() {\r\n        return this.shapeString;\r\n    }\r\n\r\n    /**\r\n     * The name of the texture pattern variable on the fragment shader.  The API will try to use 'texture' if none is given but there's no\r\n     * way to know if this is correct, and if it isn't then errors may occur.\r\n     * Keep in mind that the texture string is not provided by the programmer but instead the pattern index.\r\n     * @returns {string} - The name of the texture pattern variable on the fragment shader. \r\n     * @memberof ShadersInfo\r\n     */\r\n    getTextureName() {\r\n        return this.textureString;\r\n    }\r\n\r\n    /**\r\n     * The name of the orientation variable on the fragment shader.  The API will use 'orientation' if none is given.\r\n     * @returns {string} - the name of the orientation variable on the fragment shader.\r\n     * @memberof ShadersInfo\r\n     */\r\n    getOrientationName() {\r\n        return this.orientationString;\r\n    }\r\n\r\n    /**\r\n     * Returns the mapping between the visual variables and their associated information. \r\n     * @returns {Map<string, {name: string, type: number, qualifier: string}>} - the map of variables and their associated information. \r\n     * @memberof ShadersInfo\r\n     */\r\n    getShaderVariablesMap() {\r\n        return this.shaderVariablesMap;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/Shaders/ShadersInfo.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 708,
    "kind": "class",
    "name": "ShadersInfo",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js",
    "static": true,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/Shaders/ShadersInfo.js",
    "importStyle": "{ShadersInfo}",
    "description": "Contains all the information about the shaders currently in use.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ShadersInfo"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 709,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#constructor",
    "access": "public",
    "description": "Creates an instance of ShadersInfo.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<{name:string, type:string, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexKeys",
        "description": "The vertex shader keys."
      },
      {
        "nullable": null,
        "types": [
          "Array<{name:string, type:string, qualifier: string}>"
        ],
        "spread": false,
        "optional": false,
        "name": "fragmentKeys",
        "description": "The fragment shader keys."
      }
    ]
  },
  {
    "__docId__": 710,
    "kind": "member",
    "name": "shaderVariablesMap",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#shaderVariablesMap",
    "access": "public",
    "description": "Contains all information that was processed for each variable in the vertex and fragment shaders.\n@type{Map<string, {name: string, type: number, qualifier: string}>}",
    "lineNumber": 35
  },
  {
    "__docId__": 711,
    "kind": "member",
    "name": "positionString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#positionString",
    "access": "public",
    "description": "The position string on the vertex shader. All Gisplay shaders use the string 'position' as default.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "string='position'"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 712,
    "kind": "member",
    "name": "matrixProjectionString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#matrixProjectionString",
    "access": "public",
    "description": "The matrix projection string on the vertex shader. All Gisplay shaders use the string 'Mproj' as default.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "string='Mproj'"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 713,
    "kind": "member",
    "name": "colorString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#colorString",
    "access": "public",
    "description": "The color string on the fragment shader. Can be overriden by the user on the shaders.json file and respective shader.frag file.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "string='color'"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 714,
    "kind": "member",
    "name": "opacityString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#opacityString",
    "access": "public",
    "description": "The opacity string on the fragment shader.",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "string='opacity'"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 715,
    "kind": "member",
    "name": "textureString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#textureString",
    "access": "public",
    "description": "The texture pattern string on the fragment shader.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 716,
    "kind": "member",
    "name": "shapeString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#shapeString",
    "access": "public",
    "description": "The shape string on the fragment shader. ",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 717,
    "kind": "member",
    "name": "sizeString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#sizeString",
    "access": "public",
    "description": "The size string on the vertex shader.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 718,
    "kind": "member",
    "name": "orientationString",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#orientationString",
    "access": "public",
    "description": "The orientation string on the fragment shader.",
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 719,
    "kind": "method",
    "name": "getPositionName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getPositionName",
    "access": "public",
    "description": "The name of the position variable on the vertex shader. By default all Gisplay API shaders \nuse 'position' as the name for the position variable.",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "getMatrixProjectionName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getMatrixProjectionName",
    "access": "public",
    "description": "The name of the matrix projection variable on the vertex shader. By default all Gisplay API shaders\nuse 'Mproj' as the name for the matrix projection variable.",
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 721,
    "kind": "method",
    "name": "getColorName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getColorName",
    "access": "public",
    "description": "The name of the color variable on the fragment shader. The API will try to use 'color' if none is given but there's no \nway to know if this is correct, and if it isn't then errors may occur.",
    "lineNumber": 105,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the color variable on the fragment shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the color variable on the fragment shader."
    }
  },
  {
    "__docId__": 722,
    "kind": "method",
    "name": "getOpacityName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getOpacityName",
    "access": "public",
    "description": "The name of the opacity variable on the fragment shader. The API will try to use 'opacity' if none is given but there's no\nway to know if this is correct, and if it isn't then errors may occur.",
    "lineNumber": 115,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the opacity variable on the fragment shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the opacity variable on the fragment shader."
    }
  },
  {
    "__docId__": 723,
    "kind": "method",
    "name": "getSizeVarName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getSizeVarName",
    "access": "public",
    "description": "The name of the size variable on the vertex shader. The API will try to use 'size' if none is given but there's no\nway to know if this is correct, and if it isn't then errors may occur.",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the size variable on the vertex shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the size variable on the vertex shader."
    }
  },
  {
    "__docId__": 724,
    "kind": "method",
    "name": "getShapeName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getShapeName",
    "access": "public",
    "description": "The name of the shape variable on the fragment shader. The API will try to use 'shape' if none is given but there's no\nway to know if this is correct, and if it isn't then errors may occur.",
    "lineNumber": 135,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the shape variable on the fragment shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the shape variable on the fragment shader."
    }
  },
  {
    "__docId__": 725,
    "kind": "method",
    "name": "getTextureName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getTextureName",
    "access": "public",
    "description": "The name of the texture pattern variable on the fragment shader.  The API will try to use 'texture' if none is given but there's no\nway to know if this is correct, and if it isn't then errors may occur.\nKeep in mind that the texture string is not provided by the programmer but instead the pattern index.",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The name of the texture pattern variable on the fragment shader. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The name of the texture pattern variable on the fragment shader."
    }
  },
  {
    "__docId__": 726,
    "kind": "method",
    "name": "getOrientationName",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getOrientationName",
    "access": "public",
    "description": "The name of the orientation variable on the fragment shader.  The API will use 'orientation' if none is given.",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the orientation variable on the fragment shader."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the orientation variable on the fragment shader."
    }
  },
  {
    "__docId__": 727,
    "kind": "method",
    "name": "getShaderVariablesMap",
    "memberof": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo#getShaderVariablesMap",
    "access": "public",
    "description": "Returns the mapping between the visual variables and their associated information. ",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<string, {name: string, type: number, qualifier: string}>} - the map of variables and their associated information. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<string, {name: string, type: number, qualifier: string}>"
      ],
      "spread": false,
      "description": "the map of variables and their associated information."
    }
  },
  {
    "__docId__": 728,
    "kind": "file",
    "name": "src/Gisplay/VVs/CategoricalVariable.js",
    "content": "import { MapVariable } from './MapVariable';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayError } from '../GisplayError';\r\n// import { GisplayMap } from '../Maps/GisplayMap';\r\n\r\n/**\r\n * Represents a categorical map variable.\r\n * Categorical data, is for those aspects of your data where you make a distinction between different groups, and where you typically can list a small number of categories. This includes product type, gender, age group, etc.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class CategoricalVariable\r\n */\r\nexport class CategoricalVariable extends MapVariable {\r\n\r\n    /**\r\n     * Creates an instance of CategoricalVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The name of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Map<string, string|number>} visualVariableMapping - The mapping for the given visual variable.\r\n     * @param {GisplayMap} gisplayMap - The GisplayMap. It's used when we need to get the colors for the variable.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    constructor(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, gisplayMap) {\r\n        super(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping);\r\n        /**\r\n         * The categories for this categorical variable.\r\n         * @type {Set<string>}\r\n         */\r\n        this.categories = new Set();\r\n        if (visualVariableMapping && visualVariableMapping.size > 0) { //The mapping was given by the programmer (Map<\"ABC\"->\"red\", \"DEF\"->\"blue\" etc> )\r\n            /**\r\n             * Map containing the values for this categorical map variable and an integer to represent each of these values.\r\n             * @type {Map<string, number>} \r\n             */\r\n            this.valueToIndexMap = this._createCategoricalVarMap(visualVariableMapping.keys());\r\n            this._setIndexToUsableValueMap();\r\n        }\r\n\r\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\r\n        this.classCalculationRequiredBool = this.visualVariableMapping.size === 0;\r\n        /**\r\n         * The GisplayMap object.\r\n         * @type {GisplayMap}\r\n         */\r\n        this.gisplayMap = gisplayMap;\r\n        console.error(this);\r\n    }\r\n\r\n    /**\r\n     * For each category in this categorical variable, create one index which will be used as substitute.\r\n     * This replacement will save up a lot of space. \r\n     * @param {Array<string>} values - The categories that this visual variable holds. \r\n     * @returns {Map<string, number>} - the map which contains a sequential integer to represent each category.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    _createCategoricalVarMap(values) {\r\n        let map = new Map();\r\n        let index = 0;\r\n        for (let value of values)\r\n            map.set(value, index++);\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Returns the value to index map.\r\n     * @returns {Map<string, number>} - the map containing the values for this categorical visual variable and an integer to represent each of these values.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    getValueIndexMapping() {\r\n        return this.valueToIndexMap;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given category.\r\n     * @param {string} value - The category to find. \r\n     * @returns {number} - the index of the given category.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    findIndex(value) {\r\n        return this.getValueIndexMapping().get(value);\r\n    }\r\n\r\n    /**\r\n     * Set each index (of each category) to it's respective value (color, or number in the shape/texture image).\r\n     * E.g. 0 -> [255,0,0] etc or 0 -> 14 (index in image).\r\n     * @private\r\n     * @memberof CategoricalVariable\r\n     */\r\n    _setIndexToUsableValueMap() {\r\n        let typeOfVisualVariable = this.getTypeOfVisualVariable();\r\n        let valueToIndexMapKeys = this.valueToIndexMap.keys();\r\n        console.warn(valueToIndexMapKeys);\r\n        console.warn(this.getVisualVariableMapping());\r\n\r\n        switch (typeOfVisualVariable) {\r\n            case GisplayDefaults.COLOR():\r\n                for (let mapkey of valueToIndexMapKeys) {\r\n                    let index = this.valueToIndexMap.get(mapkey); // 0, 1..\r\n                    let color = this.visualVariableMapping.get(mapkey); // [255, 0, 0], [122, 220, 85] ...\r\n                    this.indexToUsableValueMap.set(index, color);\r\n                }\r\n                break;\r\n            case GisplayDefaults.SHAPE():\r\n                for (let mapkey of valueToIndexMapKeys) { // \"Y\", \"N\"\r\n                    let index = this.valueToIndexMap.get(mapkey); // 0, 1..\r\n                    let shapeName = this.visualVariableMapping.get(mapkey); // \"terrain\", \"bricks\", \"triangle\"\r\n                    let shapeIndex = GisplayDefaults.findShapeIndex(shapeName); // 6, 7, 12, 13\r\n                    // console.log(index, shapeName, textureIndex);\r\n                    this.indexToUsableValueMap.set(index, shapeIndex);\r\n                }\r\n                break;\r\n            case GisplayDefaults.TEXTURE():\r\n                for (let mapkey of valueToIndexMapKeys) { // \"Y\", \"N\"\r\n                    let index = this.valueToIndexMap.get(mapkey); // 0, 1..\r\n                    let patternName = this.visualVariableMapping.get(mapkey); // \"terrain\", \"bricks\", \"triangle\"\r\n                    let patternIndex = GisplayDefaults.findPatternIndex(patternName); // 6, 7, 12, 13\r\n                    console.log(index, patternName, patternIndex);\r\n                    this.indexToUsableValueMap.set(index, patternIndex);\r\n                }\r\n                break;\r\n            case GisplayDefaults.SIZE():\r\n                throw new GisplayError(\"Visual variable: size, can't be used with a categorical variable.\");\r\n            case GisplayDefaults.ORIENTATION():\r\n                console.log(valueToIndexMapKeys, this.valueToIndexMap, this.visualVariableMapping);\r\n                for (let mapkey of valueToIndexMapKeys) { // \"Y\", \"N\"\r\n                    let index = this.valueToIndexMap.get(mapkey); // 0, 1..\r\n                    let orientationValue = this.visualVariableMapping.get(mapkey); // 0, 28, 90 (degrees)\r\n                    console.log(index, orientationValue);\r\n                    this.indexToUsableValueMap.set(index, orientationValue);\r\n                }\r\n            // throw new Error(\"Index to orientation value not yet implemented in Categorical Variable. Should look like COLOR + SHAPE/TEXTURE combined\");\r\n        }\r\n        console.log(\"CAT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\r\n    }\r\n\r\n    /**\r\n     * Add a categorie to the set of categories in this categorical variable.\r\n     * @param {string} category - The category to add to this categorical variable. \r\n     */\r\n    addCategory(category) {\r\n        this.categories.add(category);\r\n    }\r\n\r\n    /**\r\n     * Add the given categories to the set of categories of this Categorical variable.\r\n     * @param {Set<string>} categories - The categories given. \r\n     */\r\n    addCategories(categories) {\r\n        for (const category of categories.keys())\r\n            this.addCategory(category);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of categories for this Categorical variable.\r\n     * @returns {Set<string>} - the set of categories for this Categorical variable.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    getCategories() {\r\n        return this.categories;\r\n    }\r\n\r\n    /**\r\n     * Update the information when all categories are on the Set. \r\n     * Used when the categories weren't given by the programmer.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    updateCategoricalInformation() {\r\n        this.valueToIndexMap = this._createCategoricalVarMap(this.categories.keys());\r\n\r\n        let categories = Array.from(this.categories);\r\n        console.error(this.valueToIndexMap.size);\r\n        if(this.valueToIndexMap.size < 2)\r\n            throw new GisplayError(`Only one category (${Array.from(this.valueToIndexMap.keys())}) in the dataset. `);\r\n        let colors = this.gisplayMap.getDefaultColors(this.valueToIndexMap.size, GisplayDefaults.QUALITATIVE());\r\n        for (let [i, category] of categories.entries()) \r\n            this.visualVariableMapping.set(category, colors[i]);\r\n        \r\n        this._setIndexToUsableValueMap();\r\n    }\r\n\r\n    /**\r\n     * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n     * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n     * @memberof CategoricalVariable\r\n     */\r\n    classCalculationRequired() {\r\n        return this.classCalculationRequiredBool; // the map has no K->V pairs\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/CategoricalVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 729,
    "kind": "class",
    "name": "CategoricalVariable",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/CategoricalVariable.js",
    "importStyle": "{CategoricalVariable}",
    "description": "Represents a categorical map variable.\nCategorical data, is for those aspects of your data where you make a distinction between different groups, and where you typically can list a small number of categories. This includes product type, gender, age group, etc.",
    "see": [
      "https://eagereyes.org/basics/data-continuous-vs-categorical"
    ],
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CategoricalVariable"
      }
    ],
    "interface": false,
    "extends": [
      "src/Gisplay/VVs/MapVariable.js~MapVariable"
    ]
  },
  {
    "__docId__": 730,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#constructor",
    "access": "public",
    "description": "Creates an instance of CategoricalVariable.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "The external name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "typeOfVisualVariable",
        "description": "The name of visual variable (e.g. color, shape, size, orientation or texture)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariableQualifier",
        "description": "The shader variable qualifier."
      },
      {
        "nullable": null,
        "types": [
          "Map<string, string|number>"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVariableMapping",
        "description": "The mapping for the given visual variable."
      },
      {
        "nullable": null,
        "types": [
          "GisplayMap"
        ],
        "spread": false,
        "optional": false,
        "name": "gisplayMap",
        "description": "The GisplayMap. It's used when we need to get the colors for the variable."
      }
    ]
  },
  {
    "__docId__": 731,
    "kind": "member",
    "name": "categories",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#categories",
    "access": "public",
    "description": "The categories for this categorical variable.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Set<string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 732,
    "kind": "member",
    "name": "valueToIndexMap",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#valueToIndexMap",
    "access": "public",
    "description": "Map containing the values for this categorical map variable and an integer to represent each of these values.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 733,
    "kind": "member",
    "name": "classCalculationRequiredBool",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#classCalculationRequiredBool",
    "access": "public",
    "description": " \nBoolean that stores true if class calcutation is required, false, otherwise.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 734,
    "kind": "member",
    "name": "gisplayMap",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#gisplayMap",
    "access": "public",
    "description": "The GisplayMap object.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "GisplayMap"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 735,
    "kind": "method",
    "name": "_createCategoricalVarMap",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#_createCategoricalVarMap",
    "access": "private",
    "description": "For each category in this categorical variable, create one index which will be used as substitute.\nThis replacement will save up a lot of space. ",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<string, number>} - the map which contains a sequential integer to represent each category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "The categories that this visual variable holds."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": "the map which contains a sequential integer to represent each category."
    }
  },
  {
    "__docId__": 736,
    "kind": "method",
    "name": "getValueIndexMapping",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#getValueIndexMapping",
    "access": "public",
    "description": "Returns the value to index map.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<string, number>} - the map containing the values for this categorical visual variable and an integer to represent each of these values."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<string, number>"
      ],
      "spread": false,
      "description": "the map containing the values for this categorical visual variable and an integer to represent each of these values."
    }
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "findIndex",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#findIndex",
    "access": "public",
    "description": "Returns the index of the given category.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The category to find."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given category."
    }
  },
  {
    "__docId__": 738,
    "kind": "method",
    "name": "_setIndexToUsableValueMap",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#_setIndexToUsableValueMap",
    "access": "private",
    "description": "Set each index (of each category) to it's respective value (color, or number in the shape/texture image).\nE.g. 0 -> [255,0,0] etc or 0 -> 14 (index in image).",
    "lineNumber": 94
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "addCategory",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#addCategory",
    "access": "public",
    "description": "Add a categorie to the set of categories in this categorical variable.",
    "lineNumber": 145,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "The category to add to this categorical variable."
      }
    ]
  },
  {
    "__docId__": 740,
    "kind": "method",
    "name": "addCategories",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#addCategories",
    "access": "public",
    "description": "Add the given categories to the set of categories of this Categorical variable.",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "categories",
        "description": "The categories given."
      }
    ]
  },
  {
    "__docId__": 741,
    "kind": "method",
    "name": "getCategories",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#getCategories",
    "access": "public",
    "description": "Returns the set of categories for this Categorical variable.",
    "lineNumber": 163,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Set<string>} - the set of categories for this Categorical variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<string>"
      ],
      "spread": false,
      "description": "the set of categories for this Categorical variable."
    }
  },
  {
    "__docId__": 742,
    "kind": "method",
    "name": "updateCategoricalInformation",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#updateCategoricalInformation",
    "access": "public",
    "description": "Update the information when all categories are on the Set. \nUsed when the categories weren't given by the programmer.",
    "lineNumber": 172
  },
  {
    "__docId__": 744,
    "kind": "method",
    "name": "classCalculationRequired",
    "memberof": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable#classCalculationRequired",
    "access": "public",
    "description": "This map variable requires it's classes to be calculated or not. Categorical variables always return false.",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if we need to calculate the classes, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if we need to calculate the classes, false, otherwise."
    }
  },
  {
    "__docId__": 745,
    "kind": "file",
    "name": "src/Gisplay/VVs/ContinuousVariable.js",
    "content": "import { MapVariable } from './MapVariable';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayError } from '../GisplayError';\r\n\r\n/**\r\n * Represents a continuous variable.\r\n * Continous data, is data where the values can change continuously, and you cannot count the number of different values (e.g. weight, price, profits, counts, etc). \r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class ContinuousVariable\r\n */\r\nexport class ContinuousVariable extends MapVariable {\r\n    /**\r\n     * Creates an instance of ContinuousVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @param {Array<number>} classBreaks - The classes for this map variable.\r\n     * @param {string} numberOfClasses - The number of classes for this continuous variable.\r\n     * @param {string} classBreakMethod - The class breaks method to be used.\r\n     * @param {Array<number|string>} classBreakMethodParams - The parameters for the class break method.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    constructor(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, classBreaks, numberOfClasses, classBreakMethod, classBreakMethodParams) {\r\n        super(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping);\r\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<number>}\r\n         */\r\n        this.classBreaks = classBreaks;\r\n        /**\r\n         * The number of classes for the map variable.\r\n         * @type {number}\r\n         */\r\n        this.numberOfClasses = visualVariableMapping ? visualVariableMapping.length : numberOfClasses; //TODO: Send this on the constructor\r\n        /**\r\n         * The method to use to calculate classes for the map variable.\r\n         * @type {string}\r\n         */\r\n        this.classBreakMethod = classBreakMethod;\r\n        /**\r\n         * Returns the array of params for the class break method.\r\n         *  @type{Array<number|string>} \r\n         */\r\n        this.classBreakMethodParams = classBreakMethodParams;\r\n\r\n        /**\r\n         * Number of bins. This value is hardcoded to 100. But it should work even if changed to another integer value.\r\n         * @type {number}\r\n         */\r\n        this.numBins = 100;\r\n        /**\r\n         * The minimum value.\r\n         * @type {number}\r\n         */\r\n        this.min = Number.MAX_SAFE_INTEGER - 1;\r\n        /**\r\n         * The maximum value.\r\n         * @type {number}\r\n         */\r\n        this.max = Number.MIN_SAFE_INTEGER + 1;\r\n\r\n        this.newMin = Number.MAX_SAFE_INTEGER;\r\n        this.newMax = Number.MIN_SAFE_INTEGER;\r\n\r\n        /**\r\n         * Amount between any two bins.\r\n         * @type {number}\r\n         */\r\n        this.step = -1;\r\n        /**\r\n         * The bin limits.\r\n         * @type {Array<number>}\r\n         */\r\n        this.bins = new Array(100).fill(-1);\r\n        /**\r\n         * Histogram with number of values by bin interval. \r\n         * @type {Array<number>}\r\n         */\r\n        this.histogram = new Array(100).fill(0); //Array with 100 elements each filled with the value 0\r\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<Array<number>>}\r\n         */\r\n        this.classIntervals;\r\n\r\n        if (this.classBreaks) {\r\n            this.min = this.classBreaks[0];\r\n            this.max = this.classBreaks[this.classBreaks.length - 1];\r\n            this.step = (this.getMax() - this.getMin()) / (this.numBins);\r\n\r\n            this.bins = this.buildBinIntervals();\r\n            this.classIntervals = this.calculateClassIntervals(this.classBreaks);\r\n        }\r\n        if (this.getVisualVariableMapping())\r\n            this._setIndexToUsableValueMap();\r\n\r\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\r\n        this.classCalculationRequiredBool = this.classBreaks === undefined;\r\n        console.log(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the method to be used to calculate the classes for this map variable.\r\n     * @returns {string} - the method to be used to calculate the classes for this variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getClassBreakMethod() {\r\n        return this.classBreakMethod;\r\n    }\r\n\r\n    /**\r\n     * Returns the class intervals for this map variable.\r\n     * @returns {Array<number>} - the class intervals for the visual variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getClassBreaks() {\r\n        return this.classBreaks;\r\n    }\r\n\r\n    /**\r\n     * Sets the class breaks to the calculated class breaks.\r\n     * @param {Array<number>} calculatedClassBreaks - The array of class intervals for the visual variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    setClassBreaks(calculatedClassBreaks) {\r\n        this.classBreaks = calculatedClassBreaks;\r\n    }\r\n\r\n    /**\r\n     * Returns true, if the class breaks weren't given by the programmer for the map variable, false, otherwise. \r\n     * @returns {boolean} - true, if the class breaks weren't given by the programmer for the visual variable, false, otherwise.  \r\n     * @memberof ContinuousVariable\r\n     */\r\n    classCalculationRequired() {\r\n        return this.classCalculationRequiredBool;\r\n    }\r\n\r\n    /**\r\n     * Calculates class intervals for this variable.\r\n     * @param {Array<number>} classBreaks - The class breaks given by the programmer. \r\n     * @returns {Array<Array<number>>} - the start and end for each class of this variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    calculateClassIntervals(classBreaks) {\r\n        console.error(\"classBreaks = \", classBreaks, this)\r\n        let res = [];\r\n\r\n        /*     \r\n            [min, a[, [a, b[, [b,c[, [c,max] -> caso em que o min dos dados  !== do a\r\n            min - todos os valore menores que a\r\n            [a,b,c] ->  [min, a[, [a, b[, [b,c[, [c,max] \r\n            Se min for == a ento n cabe \r\n            >= a && < a \r\n\r\n            1 intervalos todos os inferiores a \"a\"\r\n            o ultimo intervalo  todos os >= a c \r\n        */\r\n        for (let i = 0; i < classBreaks.length - 1; i++)\r\n            res.push([classBreaks[i], classBreaks[i + 1]]);\r\n        /*   if (this.classBreaks !== undefined) {\r\n              res.push([this.min, classBreaks[0]]);\r\n              for (let i = 0; i < classBreaks.length - 1; i++)\r\n                  res.push([classBreaks[i], classBreaks[i + 1]]);\r\n              res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n          } else {\r\n              // res.push([this.min, classBreaks[0]]);\r\n              for (let i = 0; i < classBreaks.length - 1; i++)\r\n                  res.push([classBreaks[i], classBreaks[i + 1]]);\r\n              // res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n          } */\r\n        return res;\r\n        // return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the class intervals for this class.\r\n     * @returns {Array<Array<number>>} - the class intervals for this class. \r\n     * @memberof ContinuousVariable\r\n     */\r\n    getClassIntervals() {\r\n        return this.classIntervals;\r\n    }\r\n\r\n    /**\r\n     * Find the class index of the given value.\r\n     * It's inside a class if it's value is equal or higher than the starting point and less than the end point.\r\n     * @param {number} value - The value of the element.\r\n     * @returns {number} - The  index of the class.\r\n     * @memberof Parser\r\n     */\r\n    findClassIntervalIndex(value) {\r\n        let classIntervals = this.getClassIntervals();\r\n        for (let [index, classInterval] of classIntervals.entries())\r\n            if (value >= classInterval[0] && value < classInterval[1])\r\n                return index;\r\n        if (value < classIntervals[0][0])\r\n            return 0;\r\n        return classIntervals.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Set the min and max values if the given value changes them.\r\n     * @param {number} value - The given vaue. \r\n     * @memberof ContinuousVariable\r\n     */\r\n    setMinMax(value) {\r\n        if (value < this.min)\r\n            this.min = value;\r\n        if (value > this.max)\r\n            this.max = value;\r\n        /* if (value < this.newMin)\r\n            this.newMin = value;\r\n        if (value > this.newMax)\r\n            this.newMax = value; */\r\n    }\r\n\r\n    /*\r\n    #####################################################################\r\n    ######################     CLASS CALCULATION      ###################\r\n    #####################################################################\r\n    */\r\n    /**\r\n     * Returns the minimum value for the visual variable.\r\n     * @returns {number} - the minimum value for the visual variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getMin() {\r\n        return this.min;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum value for the visual variable.\r\n     * @returns {number} -  the maximum value for the visual variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getMax() {\r\n        return this.max;\r\n    }\r\n\r\n    /**\r\n     * Update the step vaue.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    setStep() {\r\n        this.step = (this.getMax() - this.getMin()) / (this.numBins);\r\n    }\r\n\r\n    /**\r\n     * Returns the step between each bin value.\r\n     * @returns {number} - the step between each bin value.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getStep() {\r\n        return this.step;\r\n    }\r\n\r\n    /**\r\n     * Returns the histogram for this continuous variable.\r\n     * @returns {Array<number>} - the histogram for this continuous variable.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getHistogram() {\r\n        return this.histogram;\r\n    }\r\n\r\n    /**\r\n     * Updates the histogram of this continuous variable with the histogram values\r\n     * @param {Array<number>} histogram - The given histogram\r\n     * @memberof ContinuousVariable\r\n     */\r\n    updateHistogram(histogram) {\r\n        for (let i = 0; i < histogram.length; i++)\r\n            this.histogram[i] += histogram[i];\r\n    }\r\n\r\n    /**\r\n     * Return the number of classes.\r\n     * @returns {numer} - the number of classes.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    getNumberOfClasses() {\r\n        return this.numberOfClasses;\r\n    }\r\n\r\n    /**\r\n     * Create 100 bins with equal intervals between the minimum and maximum value.\r\n     * @param {number} min - The minimum for this continuous variable. \r\n     * @param {number} max - The maximum for this continuous variable.\r\n     * @returns {Array<number>} - The bins that will be used to calculate the classes.\r\n     * @memberof LegendClasses\r\n     */\r\n    buildBinIntervals() {\r\n        // let step = (max - min) / this.numBins;\r\n        if (this.step === -1)\r\n            this.setStep();\r\n        let resBins = [];\r\n        let min = this.min;\r\n        let max = this.max;\r\n        // resBins.push(min);\r\n        for (let i = min; i < max; i += this.step)\r\n            resBins.push(i);\r\n\r\n        if (Math.round(resBins[resBins.length - 1]) === max || max - resBins[resBins.length - 1] < 0.0001) //min = 0, max = 199.2 Math.round(199.19999999999976) = 199 <-- ERROR\r\n            resBins[resBins.length - 1] = max;\r\n        else\r\n            resBins.push(max);\r\n        return resBins;\r\n    }\r\n\r\n    /**\r\n     * Create the bins array with 101? values that represent the intervals.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    createBins() {\r\n        this.bins = this.buildBinIntervals();\r\n    }\r\n\r\n    /**\r\n     * Add the value to the respective bin index.\r\n     * This method works at O(1) instead of O(n), since it only needs to calculate the index and add one to it's bin.\r\n     * The alternative was to loop through all the bins and find where this value would fit.\r\n     * @param {number} value - The value to insert into one of the bins. \r\n     * @see http://prntscr.com/gdn1wu - Reason for if statement\r\n     * @memberof ContinuousVariable\r\n     */\r\n    addValueToBins(value) {\r\n        let binIndex = Math.floor((value - this.min) / this.step);\r\n        if (value >= this.max) //The case it is equal to the max value then change index to the previous.\r\n            binIndex = this.numBins - 1;\r\n        else if (value <= this.min)\r\n            binIndex = 0;\r\n        this.histogram[binIndex]++;\r\n        // console.log(\"value\", value, \"binIndex\", binIndex);\r\n    }\r\n\r\n    /**\r\n     * Calculates the classes for the visual variable using the method specified by the programmer.\r\n     * @memberof ContinuousVariable\r\n     */\r\n    calculateClasses() {\r\n        //Usando os bins faz calculo de classes e alterar guardar nos classIntervals\r\n        switch (this.getClassBreakMethod()) {\r\n            case 'quantiles':\r\n                this.classIntervals = this.calculateClassIntervals(this.quantiles());\r\n                break;\r\n            case 'equalintervals':\r\n                // console.log('equalintervals');\r\n                this.classIntervals = this.calculateClassIntervals(this.equalIntervals());\r\n                break;\r\n            default:\r\n                throw new GisplayError(`Continuous Variable: ${this.getInternalName()}. Given method for class calculation does not exist. `);\r\n        }\r\n\r\n        if (this.classIntervals.length !== this.numberOfClasses)\r\n            throw new GisplayError(\"The number of calculated class intervals is different from the number of classes\");\r\n    }\r\n\r\n    /**\r\n     * Calculate the intervals for each class using the quantiles method.\r\n     * @param {Array<number>} histogram - Histogram with quantity of values by bin interval. \r\n     * @param {number} binValues - The bin values between the minimum and the maximum.\r\n     * @param {number} numRows - Number of rows read from the file.\r\n     * @param {number} numClasses - Number of classes to calculate.\r\n     * @returns {Array<number>} -  The resulting classes using the quantiles method.\r\n     * @see https://en.wikipedia.org/wiki/Quantile\r\n     * @memberof ContinuousVariable\r\n     */\r\n    quantiles(numberOfClasses = this.getNumberOfClasses()) {\r\n        let numRows = 0;\r\n        for (let i = 0, length = this.histogram.length; i < length; i++)\r\n            numRows += this.histogram[i];\r\n\r\n        let numValsPerClass = numRows / numberOfClasses;\r\n        // console.log(numRows, this.getNumberOfClasses(), numValsPerClass);\r\n        let classes = [];\r\n        classes.push(this.bins[0]);\r\n        let sum = 0;\r\n        for (let i = 0; i < this.histogram.length - 1; i++) {\r\n            sum += this.histogram[i];\r\n            if (sum >= numValsPerClass) {\r\n                classes.push(this.bins[i + 1]);\r\n                sum = 0;\r\n            }\r\n        }\r\n        classes.push(this.bins[this.bins.length - 1]);\r\n        // console.log(classes);\r\n        // console.log(this);\r\n        if (classes.length < numberOfClasses)\r\n            console.warn(`Quantiles method couldn't create ${numberOfClasses} classes, instead it created ${classes.length - 1} classes. [${classes}]`);\r\n        else if (classes.length - 1 > numberOfClasses)\r\n            throw new GisplayError(`Something went wrong with quantiles method. Number of classes calculated is: ${classes.length - 1}, the intended values was ${this.getNumberOfClasses()}`);\r\n        return classes;\r\n    }\r\n\r\n    /**\r\n     * Taking the calculated bins, this method will calculate the intervals for each class using the equal intervals method.\r\n     * @param {number} binValues - The bin values between the minimum and the maximum.\r\n     * @param {number} numClasses - Number of classes to calculate.\r\n     * @returns {Array<number>} - The resulting classes using the equal intervals method.\r\n     * @see http://wiki.gis.com/wiki/index.php/Equal_Interval_classification\r\n     * @memberof ContinuousVariable\r\n     */\r\n    equalIntervals(numberOfClasses = this.getNumberOfClasses()) {\r\n        let interval = Math.round((this.getMax() - this.getMin()) / numberOfClasses); //To give a integer (this.bins.length - 1) / this.numClasses;\r\n        // console.log(\"EquInt interval=\", interval);\r\n        // console.log(this.getMin(), this.getMax(), numberOfClasses);\r\n        let classes = [];\r\n        classes.push(this.bins[0]);\r\n        let currentValue = this.getMin(); // Current value\r\n        for (let i = 0; i < numberOfClasses - 1; i++) {\r\n            currentValue += interval;\r\n            classes.push(this._findBin(currentValue));\r\n        }\r\n        classes.push(this.bins[this.bins.length - 1]);\r\n\r\n        // console.log(\"equalIntervals = \", classes);\r\n        return classes;\r\n    }\r\n\r\n    /**\r\n     * Find the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first.\r\n     * @param {number} value - The value used to find the correct bin. \r\n     * @returns {number} - the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first. \r\n     * @private \r\n     * @memberof ContinuousVariable\r\n     */\r\n    _findBin(value) {\r\n        for (let i = 0; i < this.bins.length - 1; i++) {\r\n            let val1 = this.bins[i];\r\n            let val2 = this.bins[i + 1];\r\n            if (value >= val1 && value < val2) {\r\n                let distToVal1 = value - val1;\r\n                let distToVal2 = val2 - value;\r\n                if (distToVal1 <= distToVal2)\r\n                    return val1;\r\n                return val2;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set each index (of each class) to it's respective value (color array, size or orientation value).\r\n     * E.g. 0 -> [255, 0, 0], 1 -> [0, 128, 0] etc\r\n     * @private\r\n     * @memberof ContinuousVariable\r\n     */\r\n    _setIndexToUsableValueMap() {\r\n        let typeOfVisualVariable = this.getTypeOfVisualVariable();\r\n        switch (typeOfVisualVariable) {\r\n            case GisplayDefaults.COLOR():\r\n            case GisplayDefaults.SIZE():\r\n            case GisplayDefaults.ORIENTATION():\r\n                for (let [index, vvMapping] of this.getVisualVariableMapping().entries())\r\n                    this.indexToUsableValueMap.set(index, vvMapping);\r\n                break;\r\n            case GisplayDefaults.SHAPE():\r\n            case GisplayDefaults.TEXTURE():\r\n                throw new GisplayError(`${typeOfVisualVariable} shouldn't be used with a continuous variable.`);\r\n        }\r\n        // console.log(\"CONT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/ContinuousVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 746,
    "kind": "class",
    "name": "ContinuousVariable",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/ContinuousVariable.js",
    "importStyle": "{ContinuousVariable}",
    "description": "Represents a continuous variable.\nContinous data, is data where the values can change continuously, and you cannot count the number of different values (e.g. weight, price, profits, counts, etc). ",
    "see": [
      "https://eagereyes.org/basics/data-continuous-vs-categorical"
    ],
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ContinuousVariable"
      }
    ],
    "interface": false,
    "extends": [
      "src/Gisplay/VVs/MapVariable.js~MapVariable"
    ]
  },
  {
    "__docId__": 747,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#constructor",
    "access": "public",
    "description": "Creates an instance of ContinuousVariable.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "The external name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "typeOfVisualVariable",
        "description": "The type of visual variable (e.g. color, shape, size, orientation or texture)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariableQualifier",
        "description": "The shader variable qualifier."
      },
      {
        "nullable": null,
        "types": [
          "Array<string|number>"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVariableMapping",
        "description": "The mapping for the given type of visual variable."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "classBreaks",
        "description": "The classes for this map variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfClasses",
        "description": "The number of classes for this continuous variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "classBreakMethod",
        "description": "The class breaks method to be used."
      },
      {
        "nullable": null,
        "types": [
          "Array<number|string>"
        ],
        "spread": false,
        "optional": false,
        "name": "classBreakMethodParams",
        "description": "The parameters for the class break method."
      }
    ]
  },
  {
    "__docId__": 748,
    "kind": "member",
    "name": "classBreaks",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classBreaks",
    "access": "public",
    "description": "The class intervals for the map variable.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 749,
    "kind": "member",
    "name": "numberOfClasses",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#numberOfClasses",
    "access": "public",
    "description": "The number of classes for the map variable.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 750,
    "kind": "member",
    "name": "classBreakMethod",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classBreakMethod",
    "access": "public",
    "description": "The method to use to calculate classes for the map variable.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 751,
    "kind": "member",
    "name": "classBreakMethodParams",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classBreakMethodParams",
    "access": "public",
    "description": "Returns the array of params for the class break method.\n @type{Array<number|string>} ",
    "lineNumber": 47
  },
  {
    "__docId__": 752,
    "kind": "member",
    "name": "numBins",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#numBins",
    "access": "public",
    "description": "Number of bins. This value is hardcoded to 100. But it should work even if changed to another integer value.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 753,
    "kind": "member",
    "name": "min",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#min",
    "access": "public",
    "description": "The minimum value.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 754,
    "kind": "member",
    "name": "max",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#max",
    "access": "public",
    "description": "The maximum value.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 755,
    "kind": "member",
    "name": "newMin",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#newMin",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true
  },
  {
    "__docId__": 756,
    "kind": "member",
    "name": "newMax",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#newMax",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true
  },
  {
    "__docId__": 757,
    "kind": "member",
    "name": "step",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#step",
    "access": "public",
    "description": "Amount between any two bins.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 758,
    "kind": "member",
    "name": "bins",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#bins",
    "access": "public",
    "description": "The bin limits.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 759,
    "kind": "member",
    "name": "histogram",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#histogram",
    "access": "public",
    "description": "Histogram with number of values by bin interval. ",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 764,
    "kind": "member",
    "name": "classIntervals",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classIntervals",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true
  },
  {
    "__docId__": 765,
    "kind": "member",
    "name": "classCalculationRequiredBool",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classCalculationRequiredBool",
    "access": "public",
    "description": " \nBoolean that stores true if class calcutation is required, false, otherwise.",
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 766,
    "kind": "method",
    "name": "getClassBreakMethod",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getClassBreakMethod",
    "access": "public",
    "description": "Returns the method to be used to calculate the classes for this map variable.",
    "lineNumber": 113,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the method to be used to calculate the classes for this variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the method to be used to calculate the classes for this variable."
    }
  },
  {
    "__docId__": 767,
    "kind": "method",
    "name": "getClassBreaks",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getClassBreaks",
    "access": "public",
    "description": "Returns the class intervals for this map variable.",
    "lineNumber": 122,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the class intervals for the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the class intervals for the visual variable."
    }
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "setClassBreaks",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#setClassBreaks",
    "access": "public",
    "description": "Sets the class breaks to the calculated class breaks.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "calculatedClassBreaks",
        "description": "The array of class intervals for the visual variable."
      }
    ]
  },
  {
    "__docId__": 770,
    "kind": "method",
    "name": "classCalculationRequired",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#classCalculationRequired",
    "access": "public",
    "description": "Returns true, if the class breaks weren't given by the programmer for the map variable, false, otherwise. ",
    "lineNumber": 140,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if the class breaks weren't given by the programmer for the visual variable, false, otherwise.  "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if the class breaks weren't given by the programmer for the visual variable, false, otherwise."
    }
  },
  {
    "__docId__": 771,
    "kind": "method",
    "name": "calculateClassIntervals",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#calculateClassIntervals",
    "access": "public",
    "description": "Calculates class intervals for this variable.",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} - the start and end for each class of this variable."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "classBreaks",
        "description": "The class breaks given by the programmer."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "the start and end for each class of this variable."
    }
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "getClassIntervals",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getClassIntervals",
    "access": "public",
    "description": "Returns the class intervals for this class.",
    "lineNumber": 186,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} - the class intervals for this class. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": "the class intervals for this class."
    }
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "findClassIntervalIndex",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#findClassIntervalIndex",
    "access": "public",
    "description": "Find the class index of the given value.\nIt's inside a class if it's value is equal or higher than the starting point and less than the end point.",
    "lineNumber": 197,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The  index of the class."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value of the element."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The  index of the class."
    }
  },
  {
    "__docId__": 774,
    "kind": "method",
    "name": "setMinMax",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#setMinMax",
    "access": "public",
    "description": "Set the min and max values if the given value changes them.",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The given vaue."
      }
    ]
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "getMin",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getMin",
    "access": "public",
    "description": "Returns the minimum value for the visual variable.",
    "lineNumber": 233,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the minimum value for the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minimum value for the visual variable."
    }
  },
  {
    "__docId__": 778,
    "kind": "method",
    "name": "getMax",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getMax",
    "access": "public",
    "description": "Returns the maximum value for the visual variable.",
    "lineNumber": 242,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} -  the maximum value for the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the maximum value for the visual variable."
    }
  },
  {
    "__docId__": 779,
    "kind": "method",
    "name": "setStep",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#setStep",
    "access": "public",
    "description": "Update the step vaue.",
    "lineNumber": 250
  },
  {
    "__docId__": 781,
    "kind": "method",
    "name": "getStep",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getStep",
    "access": "public",
    "description": "Returns the step between each bin value.",
    "lineNumber": 259,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the step between each bin value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the step between each bin value."
    }
  },
  {
    "__docId__": 782,
    "kind": "method",
    "name": "getHistogram",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getHistogram",
    "access": "public",
    "description": "Returns the histogram for this continuous variable.",
    "lineNumber": 268,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the histogram for this continuous variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the histogram for this continuous variable."
    }
  },
  {
    "__docId__": 783,
    "kind": "method",
    "name": "updateHistogram",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#updateHistogram",
    "access": "public",
    "description": "Updates the histogram of this continuous variable with the histogram values",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "histogram",
        "description": "The given histogram"
      }
    ]
  },
  {
    "__docId__": 784,
    "kind": "method",
    "name": "getNumberOfClasses",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#getNumberOfClasses",
    "access": "public",
    "description": "Return the number of classes.",
    "lineNumber": 287,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{numer} - the number of classes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "numer"
      ],
      "spread": false,
      "description": "the number of classes."
    }
  },
  {
    "__docId__": 785,
    "kind": "method",
    "name": "buildBinIntervals",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#buildBinIntervals",
    "access": "public",
    "description": "Create 100 bins with equal intervals between the minimum and maximum value.",
    "lineNumber": 298,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - The bins that will be used to calculate the classes."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": "The minimum for this continuous variable."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": "The maximum for this continuous variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "The bins that will be used to calculate the classes."
    }
  },
  {
    "__docId__": 786,
    "kind": "method",
    "name": "createBins",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#createBins",
    "access": "public",
    "description": "Create the bins array with 101? values that represent the intervals.",
    "lineNumber": 320
  },
  {
    "__docId__": 788,
    "kind": "method",
    "name": "addValueToBins",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#addValueToBins",
    "access": "public",
    "description": "Add the value to the respective bin index.\nThis method works at O(1) instead of O(n), since it only needs to calculate the index and add one to it's bin.\nThe alternative was to loop through all the bins and find where this value would fit.",
    "see": [
      "http://prntscr.com/gdn1wu - Reason for if statement"
    ],
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value to insert into one of the bins."
      }
    ]
  },
  {
    "__docId__": 789,
    "kind": "method",
    "name": "calculateClasses",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#calculateClasses",
    "access": "public",
    "description": "Calculates the classes for the visual variable using the method specified by the programmer.",
    "lineNumber": 346
  },
  {
    "__docId__": 792,
    "kind": "method",
    "name": "quantiles",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#quantiles",
    "access": "public",
    "description": "Calculate the intervals for each class using the quantiles method.",
    "see": [
      "https://en.wikipedia.org/wiki/Quantile"
    ],
    "lineNumber": 374,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} -  The resulting classes using the quantiles method."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "histogram",
        "description": "Histogram with quantity of values by bin interval."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "binValues",
        "description": "The bin values between the minimum and the maximum."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numRows",
        "description": "Number of rows read from the file."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes to calculate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "The resulting classes using the quantiles method."
    }
  },
  {
    "__docId__": 793,
    "kind": "method",
    "name": "equalIntervals",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#equalIntervals",
    "access": "public",
    "description": "Taking the calculated bins, this method will calculate the intervals for each class using the equal intervals method.",
    "see": [
      "http://wiki.gis.com/wiki/index.php/Equal_Interval_classification"
    ],
    "lineNumber": 409,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - The resulting classes using the equal intervals method."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "binValues",
        "description": "The bin values between the minimum and the maximum."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numClasses",
        "description": "Number of classes to calculate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "The resulting classes using the equal intervals method."
    }
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "_findBin",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#_findBin",
    "access": "private",
    "description": "Find the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first.",
    "lineNumber": 433,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first. "
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value used to find the correct bin."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first."
    }
  },
  {
    "__docId__": 795,
    "kind": "method",
    "name": "_setIndexToUsableValueMap",
    "memberof": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable#_setIndexToUsableValueMap",
    "access": "private",
    "description": "Set each index (of each class) to it's respective value (color array, size or orientation value).\nE.g. 0 -> [255, 0, 0], 1 -> [0, 128, 0] etc",
    "lineNumber": 453
  },
  {
    "__docId__": 796,
    "kind": "file",
    "name": "src/Gisplay/VVs/DataVariable.js",
    "content": "/**\r\n * Represents a variable. This variable has an external and an internal Name.\r\n * External name is the name of the variable on the dataset.\r\n * Internal name is the name the programmer gave to this variable.\r\n * @export\r\n * @class DataVariable\r\n */\r\nexport class DataVariable {\r\n\r\n    /**\r\n     * Creates an instance of a Variable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @memberof DataVariable\r\n     */\r\n    constructor(externalName, internalName) {\r\n        /**\r\n         * It's the external name of this variable\r\n         * @type {string}\r\n         */\r\n        this.externalName = externalName;\r\n        /**\r\n         * The internal name for this variable.\r\n         * @type {string}\r\n         */\r\n        this.internalName = internalName;\r\n    }\r\n\r\n    /**\r\n     * Returns the external name for this visual variable.\r\n     * @returns {string} - the external name of the visual variable.\r\n     * @memberof DataVariable\r\n     */\r\n    getExternalName() {\r\n        return this.externalName;\r\n    }\r\n\r\n    /**\r\n     * Returns the internal name for this visual variable.\r\n     * @returns {string} - the internal name of the visual variable.\r\n     * @memberof DataVariable\r\n     */\r\n    getInternalName() {\r\n        return this.internalName;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/DataVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 797,
    "kind": "class",
    "name": "DataVariable",
    "memberof": "src/Gisplay/VVs/DataVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/DataVariable.js",
    "importStyle": "{DataVariable}",
    "description": "Represents a variable. This variable has an external and an internal Name.\nExternal name is the name of the variable on the dataset.\nInternal name is the name the programmer gave to this variable.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DataVariable"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 798,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable#constructor",
    "access": "public",
    "description": "Creates an instance of a Variable.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "The external name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name for this variable."
      }
    ]
  },
  {
    "__docId__": 799,
    "kind": "member",
    "name": "externalName",
    "memberof": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable#externalName",
    "access": "public",
    "description": "It's the external name of this variable",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 800,
    "kind": "member",
    "name": "internalName",
    "memberof": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable#internalName",
    "access": "public",
    "description": "The internal name for this variable.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 801,
    "kind": "method",
    "name": "getExternalName",
    "memberof": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable#getExternalName",
    "access": "public",
    "description": "Returns the external name for this visual variable.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the external name of the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the external name of the visual variable."
    }
  },
  {
    "__docId__": 802,
    "kind": "method",
    "name": "getInternalName",
    "memberof": "src/Gisplay/VVs/DataVariable.js~DataVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/DataVariable.js~DataVariable#getInternalName",
    "access": "public",
    "description": "Returns the internal name for this visual variable.",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the internal name of the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the internal name of the visual variable."
    }
  },
  {
    "__docId__": 803,
    "kind": "file",
    "name": "src/Gisplay/VVs/MapVariable.js",
    "content": "import { DataVariable } from './DataVariable';\r\n\r\n\r\n/**\r\n * Represents a Map Variable.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @see http://leg.ufpr.br/~silvia/CE055/node8.html\r\n * @export\r\n * @class MapVariable\r\n */\r\nexport class MapVariable extends DataVariable {\r\n\r\n    /**\r\n     * Creates an instance of MapVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>|Map<string, string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @memberof MapVariable\r\n     */\r\n    constructor(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping) {\r\n        super(externalName, internalName);\r\n        /**\r\n         * The type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n         * @type {string}\r\n         */\r\n        this.typeOfVisualVariable = typeOfVisualVariable;\r\n        /**\r\n         * The access qualifier for the shader variable.\r\n         * @type {string}\r\n         */\r\n        this.shaderQualifier = shaderVariableQualifier;\r\n        /**\r\n         * The shader qualifier is of type attribute or not.\r\n         * @type {boolean} \r\n         */\r\n        this.qualifierIsAttributeBool = shaderVariableQualifier === 'attribute';\r\n        /**\r\n         * The mapping between the values and the type of visual variable availabe values.\r\n         * E.g. 'THEFT' => 'triangle'\r\n         * @type {Map<string, string>|Array<string|number>}\r\n         */\r\n        this.visualVariableMapping = visualVariableMapping;\r\n        /**\r\n         * The mapping between each class/category index and it's visual variable usable value.\r\n         * Possible keys: 0 .... n-1\r\n         * Possible values: 1) Array of numbers for color\r\n         *                  2) Index number for shapes and textures\r\n         *                  3) Number for size and orientation\r\n         * E.g. 'THEFT' => 'triangle' => 8 (8 is the index of the triangle in the shapes map)\r\n         *      'NO THEFT' => 'square' => 4\r\n         * Then we would have Map( 0 -> 8, 1 -> 4)\r\n         * @type {Map<number,Array<number>|number>}\r\n         */\r\n        this.indexToUsableValueMap = new Map();\r\n    }\r\n\r\n    /**\r\n     * Returns the type of visual variable (e.g. color, shape, size, orientation or texture) that this map variable will be mapped to.\r\n     * @returns {string} - the type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n     * @memberof MapVariable\r\n     */\r\n    getTypeOfVisualVariable() {\r\n        return this.typeOfVisualVariable;\r\n    }\r\n\r\n    /**\r\n     * Returns the mapping for the type of visual variable. \r\n     * It can be a Object<Key, Value> if it's categorical, an array of strings or array of numbers. \r\n     * @returns {Map<string, string>|Array<string|number>} - the mappings for this visual variable.\r\n     * @memberof MapVariable\r\n     */\r\n    getVisualVariableMapping() {\r\n        return this.visualVariableMapping;\r\n        //Array number (Cont no size e orientation)\r\n        //Array string (Cont para color, size e orientation + Cat para color)\r\n        //Object K->V (Cat para shape, texture e orientation)\r\n    }\r\n\r\n    /**\r\n     * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n     * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n     * @memberof MapVariable\r\n     */\r\n    classCalculationRequired() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mapping between each class/category and it's visual variable usable value.\r\n     * @returns {Map<number,Array<number>|number>} - the mapping between each class/category and it's visual variable usable value.\r\n     * @memberof MapVariable\r\n     */\r\n    getIndexToUSableValueMap() {\r\n        return this.indexToUsableValueMap;\r\n    }\r\n\r\n    /**\r\n     * The value associated with the given index.\r\n     * E.g. [255,0,0] for color or 57 for size/orientation or 3 for shape/texture.\r\n     * @param {number} index - The index of the visual variable.\r\n     * @returns {Array<number>|number>}\r\n     * @memberof MapVariable\r\n     */\r\n    findUsableValue(index) {\r\n        return this.indexToUsableValueMap.get(index);\r\n    }\r\n\r\n    /**\r\n     * The access qualifier for the shader variable \r\n     * @returns {string} - the access qualifier for the shader variable \r\n     * @memberOf MapVariable\r\n     */\r\n    getShaderVariableQualifier() {\r\n        return this.shaderQualifier;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the shader qualifier is equal to attribute, false, otherwise.\r\n     * @returns {boolean} - true if the shader qualifier is equal to attribute, false, otherwise.\r\n     * @memberOf MapVariable\r\n     */\r\n    qualifierIsAttribute() {\r\n        return this.qualifierIsAttributeBool;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/MapVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 804,
    "kind": "class",
    "name": "MapVariable",
    "memberof": "src/Gisplay/VVs/MapVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/MapVariable.js",
    "importStyle": "{MapVariable}",
    "description": "Represents a Map Variable.",
    "see": [
      "https://eagereyes.org/basics/data-continuous-vs-categorical",
      "http://leg.ufpr.br/~silvia/CE055/node8.html"
    ],
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MapVariable"
      }
    ],
    "interface": false,
    "extends": [
      "src/Gisplay/VVs/DataVariable.js~DataVariable"
    ]
  },
  {
    "__docId__": 805,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#constructor",
    "access": "public",
    "description": "Creates an instance of MapVariable.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "The external name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name for this variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "typeOfVisualVariable",
        "description": "The type of visual variable (e.g. color, shape, size, orientation or texture)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "shaderVariableQualifier",
        "description": "The shader variable qualifier."
      },
      {
        "nullable": null,
        "types": [
          "Array<string|number>|Map<string, string|number>"
        ],
        "spread": false,
        "optional": false,
        "name": "visualVariableMapping",
        "description": "The mapping for the given type of visual variable."
      }
    ]
  },
  {
    "__docId__": 806,
    "kind": "member",
    "name": "typeOfVisualVariable",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#typeOfVisualVariable",
    "access": "public",
    "description": "The type of visual variable mapping (e.g. color, shape, size, orientation or texture).",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 807,
    "kind": "member",
    "name": "shaderQualifier",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#shaderQualifier",
    "access": "public",
    "description": "The access qualifier for the shader variable.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 808,
    "kind": "member",
    "name": "qualifierIsAttributeBool",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#qualifierIsAttributeBool",
    "access": "public",
    "description": "The shader qualifier is of type attribute or not.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 809,
    "kind": "member",
    "name": "visualVariableMapping",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#visualVariableMapping",
    "access": "public",
    "description": "The mapping between the values and the type of visual variable availabe values.\nE.g. 'THEFT' => 'triangle'",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Map<string, string>|Array<string|number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 810,
    "kind": "member",
    "name": "indexToUsableValueMap",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#indexToUsableValueMap",
    "access": "public",
    "description": "The mapping between each class/category index and it's visual variable usable value.\nPossible keys: 0 .... n-1\nPossible values: 1) Array of numbers for color\n                 2) Index number for shapes and textures\n                 3) Number for size and orientation\nE.g. 'THEFT' => 'triangle' => 8 (8 is the index of the triangle in the shapes map)\n     'NO THEFT' => 'square' => 4\nThen we would have Map( 0 -> 8, 1 -> 4)",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "Map<number,Array<number>|number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 811,
    "kind": "method",
    "name": "getTypeOfVisualVariable",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#getTypeOfVisualVariable",
    "access": "public",
    "description": "Returns the type of visual variable (e.g. color, shape, size, orientation or texture) that this map variable will be mapped to.",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the type of visual variable mapping (e.g. color, shape, size, orientation or texture)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the type of visual variable mapping (e.g. color, shape, size, orientation or texture)."
    }
  },
  {
    "__docId__": 812,
    "kind": "method",
    "name": "getVisualVariableMapping",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#getVisualVariableMapping",
    "access": "public",
    "description": "Returns the mapping for the type of visual variable. \nIt can be a Object<Key, Value> if it's categorical, an array of strings or array of numbers. ",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<string, string>|Array<string|number>} - the mappings for this visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<string, string>|Array<string|number>"
      ],
      "spread": false,
      "description": "the mappings for this visual variable."
    }
  },
  {
    "__docId__": 813,
    "kind": "method",
    "name": "classCalculationRequired",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#classCalculationRequired",
    "access": "public",
    "description": "This map variable requires it's classes to be calculated or not. Categorical variables always return false.",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if we need to calculate the classes, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if we need to calculate the classes, false, otherwise."
    }
  },
  {
    "__docId__": 814,
    "kind": "method",
    "name": "getIndexToUSableValueMap",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#getIndexToUSableValueMap",
    "access": "public",
    "description": "Returns the mapping between each class/category and it's visual variable usable value.",
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<number,Array<number>|number>} - the mapping between each class/category and it's visual variable usable value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<number,Array<number>|number>"
      ],
      "spread": false,
      "description": "the mapping between each class/category and it's visual variable usable value."
    }
  },
  {
    "__docId__": 815,
    "kind": "method",
    "name": "findUsableValue",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#findUsableValue",
    "access": "public",
    "description": "The value associated with the given index.\nE.g. [255,0,0] for color or 57 for size/orientation or 3 for shape/texture.",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>|number>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "The index of the visual variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>|number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 816,
    "kind": "method",
    "name": "getShaderVariableQualifier",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#getShaderVariableQualifier",
    "access": "public",
    "description": "The access qualifier for the shader variable ",
    "lineNumber": 115,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the access qualifier for the shader variable "
      },
      {
        "tagName": "@memberOf",
        "tagValue": "MapVariable"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the access qualifier for the shader variable"
    }
  },
  {
    "__docId__": 817,
    "kind": "method",
    "name": "qualifierIsAttribute",
    "memberof": "src/Gisplay/VVs/MapVariable.js~MapVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariable.js~MapVariable#qualifierIsAttribute",
    "access": "public",
    "description": "Returns true if the shader qualifier is equal to attribute, false, otherwise.",
    "lineNumber": 124,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the shader qualifier is equal to attribute, false, otherwise."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "MapVariable"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the shader qualifier is equal to attribute, false, otherwise."
    }
  },
  {
    "__docId__": 818,
    "kind": "file",
    "name": "src/Gisplay/VVs/MapVariableCombination.js",
    "content": "//Import for intellisense\r\nimport { MapVariable } from './MapVariable';\r\nimport { CategoricalVariable } from './CategoricalVariable';\r\n\r\nimport { TemporalGranule } from './TemporalGranule';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * This class represents a map variable Combination. A map variable combination is created by joining one or multiple map variables.\r\n * This class will hold the string for the combination and the data associated with this combination.\r\n * Inside a combination can very well exist multiple temporal granules. The data can further be split into multiple granules.\r\n * @class MapVariableCombination\r\n */\r\nexport class MapVariableCombination {\r\n\r\n    /**\r\n     * Creates an instance of MapVariableCombination.\r\n     * @param {string} combinationString - String that represents this map variable combination.\r\n     * @param {Array<MapVariable>} mapVariables - The variables themselves.\r\n     * @param {Array<number>} startRGBA - The first RGBA color for this map variable combination.\r\n     * @param {Array<TemporalGranule>} temporalGranules - The temporal granules that are present on this map variable combination.\r\n     * @param {WebGLRenderingContext} webglContext - The WebGL renderind context.\r\n     * @param {boolean} hasPoints - Has points or not.\r\n     * @param {boolean} anyQualifierIsAttribute - If any continuous variable has 'attribute' qualifier in the shader.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    constructor(combinationString, mapVariables, startRGBA, temporalGranules, webglContext, anyQualifierIsAttribute) {\r\n        /**\r\n         * The string that represents this combination.\r\n         * @type {string}\r\n         */\r\n        this.combinationString = combinationString;\r\n        /**\r\n         * The values for each map variable that is part of this combination.\r\n         * This contains: Visual Variable  value (e.g 99-184) + \r\n         * @type {Array<MapVariable>}\r\n         */\r\n        this.mapVariables = mapVariables;\r\n\r\n        /**\r\n         * The current RGBA that will identify each  \r\n         * @type {Array<number>}\r\n         */\r\n        this.currentRGBAPickingColor = startRGBA;\r\n        /**\r\n         * The start RGBA color of this map variable combination.\r\n         * @type {Array<number>}\r\n         */\r\n        this.startRGBA = [...startRGBA];\r\n\r\n        /**\r\n         * If this map variable combination is currently enabled on the map or not. \r\n         * @type {boolean}\r\n         */\r\n        this.isEnabledBool = true;\r\n\r\n        //  ########################  TIME\r\n        /**\r\n         * Holds all temporal granularities that exist.\r\n         * @type {Array<TemporalGranule>}\r\n         */\r\n        this.temporalGranules = [];\r\n        if (temporalGranules === undefined || temporalGranules.length === 0)\r\n            this.temporalGranules.push(new TemporalGranule(0, webglContext, anyQualifierIsAttribute));\r\n        else\r\n            for (const temporalgranule of temporalGranules)\r\n                this.temporalGranules.push(new TemporalGranule(temporalgranule, webglContext, anyQualifierIsAttribute));\r\n\r\n        // [ [VVs], [Geo], [Time?], [Extras?] ]\r\n        //   0      1      2        3\r\n        //Position of elements from Parser\r\n        /**\r\n         * The position of the time granularity information on the data array. \r\n         * If time exists on the data then holds the value 2, otherwise, holds false.\r\n         * @type {number|boolean}\r\n         */\r\n        this.posTime = this.temporalGranules.length > 1; //TODO: DELETE\r\n\r\n        /**\r\n         * This map will contain for each visual variable on this map variable combination it's value.\r\n         * E.g. shape -> 3 (index in the shapes image)\r\n         * E.g. color -> [0, 255, 0]\r\n         * @todo Fix this variable because it does not make much sense. Fix the _findVisualVariablesValues() method too.\r\n         * @type {Map<string, Array<number>|number>}\r\n         */\r\n        this.visualVariableValues = new Map();\r\n        this._findVisualVariablesValues();\r\n    }\r\n\r\n    /**\r\n     * Returns all temporal granularities that exist in this map variable combination.\r\n     * @returns {Array<TemporalGranule>} - all temporal granularities that exist in this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getTemporalGranules() {\r\n        return this.temporalGranules;\r\n    }\r\n\r\n    /**\r\n     * Returns true or false depending on the state of the enabled variable.\r\n     * @returns {boolean} - true if enabled, false, otherwise.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    isEnabled() {\r\n        return this.isEnabledBool;\r\n    }\r\n\r\n    /**\r\n     * Inverse of current state. If enabled then disable, otherwise, enable.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    enableDisable() {\r\n        this.isEnabledBool = !this.isEnabledBool;\r\n    }\r\n\r\n    /**\r\n     * Disables the map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    disable() {\r\n        this.isEnabledBool = false;\r\n    }\r\n\r\n    /**\r\n     * Enables the map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    enable() {\r\n        this.isEnabledBool = true;\r\n    }\r\n\r\n    /**\r\n     * Add one data row  associated with this combination of map variables.\r\n     * @param {Array<string|number>} dataRow - The data row.\r\n     * @param {number} geometryPrimitive - The identifier of the geometry primtive.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    addDataRow(dataRow, geometryPrimitive) {\r\n        //data[2][0] ||0 -> If time is undefined then add to the only existing temporal granularity 0. Otherwise add to the position given by the array.\r\n        this.temporalGranules[dataRow[2][0] || 0].addDataRow([dataRow[0], dataRow[1], dataRow[3]], geometryPrimitive);\r\n        // console.log(dataRow);\r\n    }\r\n\r\n    /**\r\n     * For each Temporal Granularity join the point data in a single WebGLBuffer.\r\n     * @deprecated Parser calls each temporal granularity directly, bypassing this method.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    joinTemporalGranuleData(webglContext, geometryPrimitive) {\r\n        //Se nao existir nenhuma VV que tenha o seu qualifier como \r\n\r\n        let isAttribute = false;\r\n        for (let mapVar of this.mapVariables)\r\n            if (mapVar.qualifierIsAttribute())\r\n                isAttribute = true;\r\n\r\n        // console.log(\"joinTGDATA\", geometryPrimitive, isAttribute);\r\n        switch (geometryPrimitive) {\r\n            case GisplayDefaults.getPrimitive().POINT:\r\n            case GisplayDefaults.getPrimitive().CSVPOINT: {\r\n                for (const tg of this.temporalGranules) {\r\n                    if (isAttribute)\r\n                        tg.joinAttributeData(webglContext);\r\n                    tg.joinPointData(webglContext);\r\n                }\r\n                break;\r\n            }\r\n            case GisplayDefaults.getPrimitive().POLYGON: {\r\n                for (const tg of this.temporalGranules)\r\n                    tg.joinPolygonData(webglContext);\r\n                break;\r\n            }\r\n            case GisplayDefaults.getPrimitive().LINE:\r\n                for (const tg of this.temporalGranules)\r\n                    tg.joinLineData(webglContext);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join the picking RGBA identifiers into one WebGLBuffer when the primitive to draw are points.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    joinPickingColors() {\r\n        for (const tg of this.temporalGranules)\r\n            tg.joinPickingColors();\r\n    }\r\n\r\n    /**\r\n     * Returns the WebGLBuffer (if points) or Polygon associated with the the temporal granule with index equal to timeIndex.\r\n     * @param {number} timeIndex - The index of the temporal granule. \r\n     * @returns {WebGLBuffer|Polygon}\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getTemporalGranuleData(timeIndex) {\r\n        return this.temporalGranules[timeIndex].getGeometryData();\r\n    }\r\n\r\n    /**\r\n     * Generates a sequential color to identify the Feature (point/polygon). The generated colors are sequential.\r\n     * @returns {Uint8Array} - The RGBA generated color.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    generateSequentialColor() {\r\n        let r = 0,\r\n            g = 1,\r\n            b = 2,\r\n            a = 3;\r\n\r\n        //@TODO: Change to \r\n        //Gerar num sequencial int novo\r\n        //  \r\n        if (++this.currentRGBAPickingColor[a] % 256 === 0 && this.currentRGBAPickingColor[a] !== 0) { // !==  0 otherwise when 0 wouldnt move or wouldnt generate alpha equal to 0\r\n            this.currentRGBAPickingColor[a] = 0;\r\n            if (++this.currentRGBAPickingColor[b] % 256 === 0 && this.currentRGBAPickingColor[b] !== 0) {\r\n                this.currentRGBAPickingColor[b] = 0;\r\n                if (++this.currentRGBAPickingColor[g] % 256 === 0 && this.currentRGBAPickingColor[g] !== 0) {\r\n                    this.currentRGBAPickingColor[g] = 0;\r\n                    this.currentRGBAPickingColor[r]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        //TODO: USe this Uint8Array instead of rgbaPickingColor.^^\r\n        let color = new Uint8Array(4);\r\n        color[0] = this.currentRGBAPickingColor[r];\r\n        color[1] = this.currentRGBAPickingColor[g];\r\n        color[2] = this.currentRGBAPickingColor[b];\r\n        color[3] = this.currentRGBAPickingColor[a];\r\n        return color;\r\n    }\r\n\r\n    /**\r\n     * Returns the current RGBA color for this Visual Variable Combination.\r\n     * @returns {Array<number>} - the current RGBA color for this Visual Variable Combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getStartingRGBA() {\r\n        return this.startRGBA;\r\n    }\r\n\r\n    /**\r\n     * Returns the current RGBA picking color.\r\n     * @returns {number} - the current RGBA color. \r\n     * @memberof MapVariableCombination\r\n     */\r\n    getCurrentRGBA() {\r\n        return this.currentRGBAPickingColor;\r\n    }\r\n\r\n    /**\r\n     * Used to update the current RGBA value when all data is correctly stored in the Temporal granules.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    updateCurrentRGBA() {\r\n        // console.error(\"UPDATE CURR RGBA\", this.temporalGranules.length);\r\n        for (let i = this.temporalGranules.length - 1; i >= 0; i--) {\r\n\r\n            let searchColors = this.temporalGranules[i].getPickingData().getSearchColors();\r\n            if (searchColors.length > 0) {\r\n                let lastColor = searchColors[searchColors.length - 1];\r\n                this.currentRGBAPickingColor = GisplayDefaults.numberToRGBA(lastColor);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns this map variable combination string.\r\n     * @returns {string} - this map variable combination string.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getCombinationString() {\r\n        return this.combinationString;\r\n    }\r\n\r\n    /**\r\n     * For each map variable use the its combination value to find the associated class or category\r\n     * depending on the type of map variable. \r\n     * @returns {Array<any>}\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getMapVariablesValues() {\r\n        let mapVarValues = [];\r\n        let combStr = this.combinationString;\r\n        for (let i = 0; i < combStr.length; i++) {\r\n            let combValue = +combStr[i];\r\n            let mapVar = this.mapVariables[i];\r\n            if (mapVar instanceof CategoricalVariable)\r\n                mapVarValues.push(mapVar.getValues()[combValue]);\r\n            else\r\n                mapVarValues.push(mapVar.getClassIntervals()[combValue]);\r\n        }\r\n        return mapVarValues;\r\n    }\r\n\r\n    /**\r\n     * For each combination string index find it's respective visual variable usable value. \r\n     * This means that if the combination string is \"03\". \r\n     * This method will look for each map variable and for the first get the value for the index 0 and for the second the value for the index 3.\r\n     * @deprecated Not used anymore.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    _findVisualVariablesValues() {\r\n        // console.error(\"FIND VV VALS\")\r\n        let indices = [];\r\n        for (const indexStr of this.combinationString) //\"010\" -> [0, 1, 0]\r\n            indices.push(+indexStr);\r\n\r\n        for (let [i, mapVar] of this.mapVariables.entries()) {\r\n            let typeOfVisualVariable = mapVar.getTypeOfVisualVariable();\r\n            // console.log(mapVar.findUsableValue(indices[i]));\r\n            this.visualVariableValues.set(typeOfVisualVariable, mapVar.findUsableValue(indices[i]));\r\n        }\r\n        // console.error(\"findVVs\", this.visualVariableValues);\r\n    }\r\n\r\n    /**\r\n     * Returns the fill Color for this map variable combination.\r\n     * @returns {Array<number>} - the RGB color to fill this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getColor() {\r\n        // console.log(this.visualVariableValues);\r\n        return this.visualVariableValues.get(GisplayDefaults.COLOR()) || GisplayDefaults.getDefaultColor();\r\n    }\r\n\r\n    /**\r\n     * Returns the shape index for this map variable combination.\r\n     * @returns {number} - the shape index for this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getShape() {\r\n        let shapeIndex = this.visualVariableValues.get(GisplayDefaults.SHAPE());\r\n        return shapeIndex >= 0 ? shapeIndex : GisplayDefaults.getDefaultShapeIndex();\r\n    }\r\n\r\n    /**\r\n     * Returns the texture index for this map variable combination.\r\n     * @returns {number} - the texture index for this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getTexture() {\r\n        let textureIndex = this.visualVariableValues.get(GisplayDefaults.TEXTURE());\r\n        return textureIndex >= 0 ? textureIndex : -1;//GisplayDefaults.getDefaultTextureIndex();\r\n    }\r\n\r\n    /**\r\n     * Returns the size for this map variable combination.\r\n     * @returns {number} - the size for this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getSize() {\r\n        return this.visualVariableValues.get(GisplayDefaults.SIZE()) || GisplayDefaults.getDefaultSizeValue();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the this map variable combination has any map variable that has size visual variable.\r\n     * @returns {boolean} - true if the this map variable combination has any variable that has size visual variable, false, otherwise.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    hasSize() {\r\n        return this.visualVariableValues.get(GisplayDefaults.SIZE()) !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the minimum and the maximum for the map variable that has the given type of visual variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (color, shape, etc).\r\n     * @returns {Array<number>} - the minimum and the maximum for the map variable that has the given type of visual variable.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getMapVariableMinMax(typeOfVisualVariable) {\r\n        let mapVar = this.mapVariables.filter((mapVar) => mapVar.getTypeOfVisualVariable() === typeOfVisualVariable)[0];\r\n        return [mapVar.getMin(), mapVar.getMax()];\r\n    }\r\n\r\n    /**\r\n     * Returns the orientation for this map variable combination.\r\n     * @returns {number} - the orientation for this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getOrientation() {\r\n        let orientationValue = this.visualVariableValues.get(GisplayDefaults.ORIENTATION());\r\n        return orientationValue >= 0 ? orientationValue : GisplayDefaults.getDefaultOrientationValue();\r\n    }\r\n\r\n    /**\r\n     * Returns the alpha value for this map variable combination.\r\n     * @returns {number=GisplayDefaults.getDefaultAlphaValue()} - the alpha value for this map variable combination.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getAlpha() {\r\n        return GisplayDefaults.getDefaultAlphaValue();\r\n    }\r\n\r\n    /**\r\n     * Returns the default figure index.\r\n     * @returns {number} - the default figure index.\r\n     * @memberof MapVariableCombination\r\n     */\r\n    getFigure() {\r\n        return GisplayDefaults.getDefaultFigureIndex();\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/MapVariableCombination.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 819,
    "kind": "class",
    "name": "MapVariableCombination",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js",
    "static": true,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/MapVariableCombination.js",
    "importStyle": "{MapVariableCombination}",
    "description": "This class represents a map variable Combination. A map variable combination is created by joining one or multiple map variables.\nThis class will hold the string for the combination and the data associated with this combination.\nInside a combination can very well exist multiple temporal granules. The data can further be split into multiple granules.",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MapVariableCombination"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 820,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#constructor",
    "access": "public",
    "description": "Creates an instance of MapVariableCombination.",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "combinationString",
        "description": "String that represents this map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "Array<MapVariable>"
        ],
        "spread": false,
        "optional": false,
        "name": "mapVariables",
        "description": "The variables themselves."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "startRGBA",
        "description": "The first RGBA color for this map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "Array<TemporalGranule>"
        ],
        "spread": false,
        "optional": false,
        "name": "temporalGranules",
        "description": "The temporal granules that are present on this map variable combination."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "The WebGL renderind context."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasPoints",
        "description": "Has points or not."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "anyQualifierIsAttribute",
        "description": "If any continuous variable has 'attribute' qualifier in the shader."
      }
    ]
  },
  {
    "__docId__": 821,
    "kind": "member",
    "name": "combinationString",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#combinationString",
    "access": "public",
    "description": "The string that represents this combination.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 822,
    "kind": "member",
    "name": "mapVariables",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#mapVariables",
    "access": "public",
    "description": "The values for each map variable that is part of this combination.\nThis contains: Visual Variable  value (e.g 99-184) + ",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Array<MapVariable>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 823,
    "kind": "member",
    "name": "currentRGBAPickingColor",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#currentRGBAPickingColor",
    "access": "public",
    "description": "The current RGBA that will identify each  ",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 824,
    "kind": "member",
    "name": "startRGBA",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#startRGBA",
    "access": "public",
    "description": "The start RGBA color of this map variable combination.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 825,
    "kind": "member",
    "name": "isEnabledBool",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#isEnabledBool",
    "access": "public",
    "description": "If this map variable combination is currently enabled on the map or not. ",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 826,
    "kind": "member",
    "name": "temporalGranules",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#temporalGranules",
    "access": "public",
    "description": "Holds all temporal granularities that exist.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "Array<TemporalGranule>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 827,
    "kind": "member",
    "name": "posTime",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#posTime",
    "access": "public",
    "description": "The position of the time granularity information on the data array. \nIf time exists on the data then holds the value 2, otherwise, holds false.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "number",
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 828,
    "kind": "member",
    "name": "visualVariableValues",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#visualVariableValues",
    "access": "public",
    "description": "This map will contain for each visual variable on this map variable combination it's value.\nE.g. shape -> 3 (index in the shapes image)\nE.g. color -> [0, 255, 0]",
    "lineNumber": 86,
    "todo": [
      "Fix this variable because it does not make much sense. Fix the _findVisualVariablesValues() method too."
    ],
    "type": {
      "nullable": null,
      "types": [
        "Map<string, Array<number>|number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 829,
    "kind": "method",
    "name": "getTemporalGranules",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getTemporalGranules",
    "access": "public",
    "description": "Returns all temporal granularities that exist in this map variable combination.",
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<TemporalGranule>} - all temporal granularities that exist in this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<TemporalGranule>"
      ],
      "spread": false,
      "description": "all temporal granularities that exist in this map variable combination."
    }
  },
  {
    "__docId__": 830,
    "kind": "method",
    "name": "isEnabled",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#isEnabled",
    "access": "public",
    "description": "Returns true or false depending on the state of the enabled variable.",
    "lineNumber": 104,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if enabled, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if enabled, false, otherwise."
    }
  },
  {
    "__docId__": 831,
    "kind": "method",
    "name": "enableDisable",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#enableDisable",
    "access": "public",
    "description": "Inverse of current state. If enabled then disable, otherwise, enable.",
    "lineNumber": 112
  },
  {
    "__docId__": 833,
    "kind": "method",
    "name": "disable",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#disable",
    "access": "public",
    "description": "Disables the map variable combination.",
    "lineNumber": 120
  },
  {
    "__docId__": 835,
    "kind": "method",
    "name": "enable",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#enable",
    "access": "public",
    "description": "Enables the map variable combination.",
    "lineNumber": 128
  },
  {
    "__docId__": 837,
    "kind": "method",
    "name": "addDataRow",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#addDataRow",
    "access": "public",
    "description": "Add one data row  associated with this combination of map variables.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string|number>"
        ],
        "spread": false,
        "optional": false,
        "name": "dataRow",
        "description": "The data row."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryPrimitive",
        "description": "The identifier of the geometry primtive."
      }
    ]
  },
  {
    "__docId__": 838,
    "kind": "method",
    "name": "joinTemporalGranuleData",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#joinTemporalGranuleData",
    "access": "public",
    "description": "For each Temporal Granularity join the point data in a single WebGLBuffer.",
    "lineNumber": 149,
    "deprecated": "Parser calls each temporal granularity directly, bypassing this method."
  },
  {
    "__docId__": 839,
    "kind": "method",
    "name": "joinPickingColors",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#joinPickingColors",
    "access": "public",
    "description": "Join the picking RGBA identifiers into one WebGLBuffer when the primitive to draw are points.",
    "lineNumber": 184
  },
  {
    "__docId__": 840,
    "kind": "method",
    "name": "getTemporalGranuleData",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getTemporalGranuleData",
    "access": "public",
    "description": "Returns the WebGLBuffer (if points) or Polygon associated with the the temporal granule with index equal to timeIndex.",
    "lineNumber": 195,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WebGLBuffer|Polygon}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeIndex",
        "description": "The index of the temporal granule."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WebGLBuffer",
        "Polygon"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 841,
    "kind": "method",
    "name": "generateSequentialColor",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#generateSequentialColor",
    "access": "public",
    "description": "Generates a sequential color to identify the Feature (point/polygon). The generated colors are sequential.",
    "lineNumber": 204,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Uint8Array} - The RGBA generated color."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "The RGBA generated color."
    }
  },
  {
    "__docId__": 842,
    "kind": "method",
    "name": "getStartingRGBA",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getStartingRGBA",
    "access": "public",
    "description": "Returns the current RGBA color for this Visual Variable Combination.",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the current RGBA color for this Visual Variable Combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the current RGBA color for this Visual Variable Combination."
    }
  },
  {
    "__docId__": 843,
    "kind": "method",
    "name": "getCurrentRGBA",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getCurrentRGBA",
    "access": "public",
    "description": "Returns the current RGBA picking color.",
    "lineNumber": 247,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the current RGBA color. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the current RGBA color."
    }
  },
  {
    "__docId__": 844,
    "kind": "method",
    "name": "updateCurrentRGBA",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#updateCurrentRGBA",
    "access": "public",
    "description": "Used to update the current RGBA value when all data is correctly stored in the Temporal granules.",
    "lineNumber": 255
  },
  {
    "__docId__": 846,
    "kind": "method",
    "name": "getCombinationString",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getCombinationString",
    "access": "public",
    "description": "Returns this map variable combination string.",
    "lineNumber": 273,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - this map variable combination string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "this map variable combination string."
    }
  },
  {
    "__docId__": 847,
    "kind": "method",
    "name": "getMapVariablesValues",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getMapVariablesValues",
    "access": "public",
    "description": "For each map variable use the its combination value to find the associated class or category\ndepending on the type of map variable. ",
    "lineNumber": 283,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<any>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<any>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 848,
    "kind": "method",
    "name": "_findVisualVariablesValues",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#_findVisualVariablesValues",
    "access": "private",
    "description": "For each combination string index find it's respective visual variable usable value. \nThis means that if the combination string is \"03\". \nThis method will look for each map variable and for the first get the value for the index 0 and for the second the value for the index 3.",
    "lineNumber": 304,
    "deprecated": "Not used anymore."
  },
  {
    "__docId__": 849,
    "kind": "method",
    "name": "getColor",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getColor",
    "access": "public",
    "description": "Returns the fill Color for this map variable combination.",
    "lineNumber": 323,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the RGB color to fill this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the RGB color to fill this map variable combination."
    }
  },
  {
    "__docId__": 850,
    "kind": "method",
    "name": "getShape",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getShape",
    "access": "public",
    "description": "Returns the shape index for this map variable combination.",
    "lineNumber": 333,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the shape index for this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the shape index for this map variable combination."
    }
  },
  {
    "__docId__": 851,
    "kind": "method",
    "name": "getTexture",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getTexture",
    "access": "public",
    "description": "Returns the texture index for this map variable combination.",
    "lineNumber": 343,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the texture index for this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the texture index for this map variable combination."
    }
  },
  {
    "__docId__": 852,
    "kind": "method",
    "name": "getSize",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getSize",
    "access": "public",
    "description": "Returns the size for this map variable combination.",
    "lineNumber": 353,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size for this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size for this map variable combination."
    }
  },
  {
    "__docId__": 853,
    "kind": "method",
    "name": "hasSize",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#hasSize",
    "access": "public",
    "description": "Returns true if the this map variable combination has any map variable that has size visual variable.",
    "lineNumber": 362,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if the this map variable combination has any variable that has size visual variable, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the this map variable combination has any variable that has size visual variable, false, otherwise."
    }
  },
  {
    "__docId__": 854,
    "kind": "method",
    "name": "getMapVariableMinMax",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getMapVariableMinMax",
    "access": "public",
    "description": "Returns the minimum and the maximum for the map variable that has the given type of visual variable.",
    "lineNumber": 372,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the minimum and the maximum for the map variable that has the given type of visual variable."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "typeOfVisualVariable",
        "description": "The type of visual variable (color, shape, etc)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the minimum and the maximum for the map variable that has the given type of visual variable."
    }
  },
  {
    "__docId__": 855,
    "kind": "method",
    "name": "getOrientation",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getOrientation",
    "access": "public",
    "description": "Returns the orientation for this map variable combination.",
    "lineNumber": 382,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the orientation for this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the orientation for this map variable combination."
    }
  },
  {
    "__docId__": 856,
    "kind": "method",
    "name": "getAlpha",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getAlpha",
    "access": "public",
    "description": "Returns the alpha value for this map variable combination.",
    "lineNumber": 392,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number=GisplayDefaults.getDefaultAlphaValue()} - the alpha value for this map variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number=GisplayDefaults.getDefaultAlphaValue()"
      ],
      "spread": false,
      "description": "the alpha value for this map variable combination."
    }
  },
  {
    "__docId__": 857,
    "kind": "method",
    "name": "getFigure",
    "memberof": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination#getFigure",
    "access": "public",
    "description": "Returns the default figure index.",
    "lineNumber": 401,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the default figure index."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the default figure index."
    }
  },
  {
    "__docId__": 858,
    "kind": "file",
    "name": "src/Gisplay/VVs/Picking.js",
    "content": "import { GisplayDefaults } from '../GisplayDefaults';\r\n\r\nexport class WebGLPicking {\r\n\r\n    /**\r\n     * Creates an instance of WebGLPicking.\r\n     * @param {WebGLRenderingContext} webglContext - The WebGL context.\r\n     * @memberof WebGLPicking\r\n     */\r\n    constructor(webglContext) {\r\n        /**\r\n         * @type {WebGLRenderingContext}\r\n         */\r\n        this.webglContext = webglContext;\r\n\r\n        this.continuousData = [];\r\n        this.optionalInfo = [];\r\n\r\n        this.transitoryPickingColors = [];\r\n        this.finalPickingColors = [];\r\n        this.searchColors = [];\r\n    }\r\n\r\n    /**\r\n     * Add the picking information.\r\n     * @param {Array<Object>} dataRow - The row of data that was given by the Parser.\r\n     * @param {number} geometryPrimitive - The identifier of the geometry primitive.\r\n     * @memberof TemporalGranule\r\n     */\r\n    addRow(row, hasPoints) { //GEOJSON\r\n        // console.log(row);\r\n        if (hasPoints)\r\n            this.transitoryPickingColors.push(...row[1].RGBA);\r\n        this.searchColors.push(GisplayDefaults.RGBAToNumber(...row[1].RGBA));\r\n\r\n        // this.continuousData.push(row[0]); //@TODO: If it does not exist no need to do this \r\n        // this.optionalInfo.push(row[2]); //@TODO: If it does not exist no need to do this \r\n        for (let i = 0; i < row[0].length; i++) {\r\n            if (!Array.isArray(this.continuousData[i]))\r\n                this.continuousData[i] = [];\r\n            this.continuousData[i].push(row[0][i]);\r\n        }\r\n        for (let i = 0; i < row[2].length; i++) {\r\n            if (!Array.isArray(this.optionalInfo[i]))\r\n                this.optionalInfo[i] = [];\r\n            this.optionalInfo[i].push(row[2][i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a set of rows to this temporal granule.     \r\n     * @param {{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}} dataRows - \r\n     * @memberof WebGLPicking\r\n     */\r\n    addSetOfRows(dataRows) {//CSV\r\n        if (this.searchColors.length > 0 && dataRows.numberRGBA.length > 0) { //@TODO: DELETE IF\r\n            if (!(this.searchColors[this.searchColors.length - 1] < dataRows.numberRGBA[0])) {\r\n                let currRGBA = [];\r\n                for (let i = this.transitoryPickingColors.length - 4; i < this.transitoryPickingColors.length; i++)\r\n                    currRGBA.push(this.transitoryPickingColors[i]);\r\n                let givenRGBA = [];\r\n                for (let i = 0; i < 4; i++)\r\n                    givenRGBA.push(dataRows.RGBA[i]);\r\n                console.error(currRGBA, givenRGBA);\r\n            }\r\n            console.assert(this.searchColors[this.searchColors.length - 1] < dataRows.numberRGBA[0])\r\n        }\r\n\r\n        for (const rgba of dataRows.RGBA)\r\n            this.transitoryPickingColors.push(rgba);\r\n\r\n        for (const NumRGBA of dataRows.numberRGBA)\r\n            this.searchColors.push(NumRGBA);\r\n        // this.searchColors.push(...dataRows.numberRGBA);\r\n\r\n        for (let i = 0; i < dataRows.continuousData.length; i++) {\r\n            if (!Array.isArray(this.continuousData[i]))\r\n                this.continuousData[i] = [];\r\n            for (const contData of dataRows.continuousData[i])\r\n                this.continuousData[i].push(contData);\r\n            // this.continuousData[i].push(...dataRows.continuousData[i]);\r\n        }\r\n        for (let i = 0; i < dataRows.optionalData.length; i++) {\r\n            if (!Array.isArray(this.optionalInfo[i]))\r\n                this.optionalInfo[i] = [];\r\n            for (const optData of dataRows.optionalData[i])\r\n                this.optionalInfo[i].push(optData);\r\n            // this.optionalInfo[i].push(...dataRows.optionalData[i]);\r\n        }\r\n    }\r\n\r\n    getPickingColors() {\r\n        return this.finalPickingColors;\r\n    }\r\n\r\n    getSearchColors() {\r\n        return this.searchColors;\r\n    }\r\n\r\n    /**\r\n     * Find the index of the given RGBA number in the list of searchable colors.\r\n     * @param {number} numberRGBA - The RGBA number representation.\r\n     * @param {any} hasIds - Boolean that represents the presence or absence or ids.\r\n     * @returns {number} - -1 if the numberRGBA is not found.\r\n     * @memberof WebGLPicking\r\n     */\r\n    findColorIndex(numberRGBA, hasIds) {\r\n        if (!hasIds) { //If not ids then it can use the binary search\r\n            /* let numPickingColors = this.searchColors.length;\r\n            if (numPickingColors >= 2) {\r\n                let firstColor = this.searchColors[0];\r\n                let lastColor = this.searchColors[numPickingColors - 1];\r\n                if (numberRGBA === firstColor)\r\n                    return 0;\r\n                else if (numberRGBA === lastColor)\r\n                    return numPickingColors - 1;\r\n                else if (numberRGBA > firstColor && numberRGBA < lastColor) {\r\n                    console.warn(\"VAI PARA PESQUISA BINARIA\", \"first=\", firstColor\r\n                        , \"numRGBA=\", numberRGBA,\r\n                        \"lastColor\", lastColor,\r\n                        \"indice=\", numberRGBA - firstColor\r\n                    )\r\n                    // return numberRGBA - firstColor;\r\n                    return this.binarySearchColorIndex(numberRGBA);\r\n                }\r\n                else\r\n                    return -1;\r\n            }\r\n            else if (numPickingColors === 1 && numberRGBA === this.searchColors[0])\r\n                return 0; */\r\n            return this.binarySearchColorIndex(numberRGBA);\r\n        } else { //Since it contains ids then the colors are not in a sequential order\r\n            for (let i = 0; i < this.searchColors.length; i++)\r\n                if (numberRGBA === this.searchColors[i])\r\n                    return i;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    binarySearchColorIndex(numberRGBA) {\r\n        let index = 0,\r\n            min = 0,\r\n            max = this.searchColors.length - 1;\r\n\r\n        while (min <= max) {\r\n            index = Math.floor((min + max) / 2);\r\n            if (this.searchColors[index] === numberRGBA)\r\n                return min;\r\n            else if (this.searchColors[index] < numberRGBA)\r\n                min = index + 1;\r\n            else\r\n                max = index - 1;\r\n        }\r\n    }\r\n\r\n    getOptionalInfo() {\r\n        return this.optionalInfo;\r\n    }\r\n\r\n    getIndexOptionalData(index) {\r\n        let optionalInfo = [];\r\n\r\n        for (const [i, optVar] of this.optionalInfo.entries())\r\n            optionalInfo[i] = this.optionalInfo[i][index];\r\n        return optionalInfo;\r\n    }\r\n\r\n    getIndexContinuousData(index) {\r\n        let contInfo = [];\r\n        let numContVars = this.continuousData.length;\r\n        // for (let i = 0; i < numContVars - 1; i++)\r\n        //     contInfo[i] = this.continuousData[i][index];\r\n        for (const [i, contVar] of this.continuousData.entries())\r\n            contInfo[i] = this.continuousData[i][index];\r\n        return contInfo;\r\n    }\r\n\r\n    joinPickingColorsPoints() {\r\n        console.error(\"JOIN PICKING COLORS\", this.transitoryPickingColors, this.transitoryPickingColors.length);\r\n        let gl = this.webglContext;\r\n        this.finalPickingColors = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.finalPickingColors);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(this.transitoryPickingColors), gl.STATIC_DRAW);\r\n        this.transitoryPickingColors = undefined;\r\n    }\r\n\r\n    /**\r\n     * Replaces the RGBA with the RGBA from the GeoJSONIdsParser.\r\n     * @param {number} rowIndex - The index where to replace.\r\n     * @param {Array<number>} RGBA - The RGBA identifier.\r\n     * @param {Array<number>} hasPoints - Boolean that represents the presence or absence of points.\r\n     * @memberof WebGLPicking\r\n     */\r\n    replaceRowRGBAValue(rowIndex, RGBA, hasPoints) {\r\n        this.searchColors[rowIndex] = GisplayDefaults.RGBAToNumber(...RGBA);\r\n\r\n        if (hasPoints) // Only if its point that it matters\r\n            for (let i = 0; i < 4; i++) // Replace color RGBA itself?\r\n                this.transitoryPickingColors[rowIndex * 4 + i] = RGBA[i];\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////DELETEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\r\n    //@TODO DELETE\r\n    joinPickingColorsPointsCSV() {\r\n        console.error(\"JOIN PICKING COLORS\", this.transitoryPickingColors, this.transitoryPickingColors.length);\r\n        let allColors = [];\r\n        // if(Array.isArray(this.pickingColors[0]))\r\n        for (let RGBA of this.transitoryPickingColors)\r\n            allColors.push(...RGBA);\r\n\r\n        let gl = this.webglContext;\r\n        this.finalPickingColors = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.finalPickingColors);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(allColors), gl.STATIC_DRAW);\r\n        // this.finalPickingColors = pickingBuffer;\r\n    }\r\n\r\n    //@TODO DELETE\r\n    //http://prntscr.com/i3ucmf\r\n    //https://stackoverflow.com/a/15753839/\r\n    joinPickingColorsPolygonsOLD(polygons) { //generate color for each vertex (each indice generated)\r\n        console.warn(\"JOIN PICKING COLORS POLYGONS\");\r\n        let finalColors = [];\r\n        let numTotalVertices = 0;\r\n        for (const [i, polygon] of polygons.entries()) {\r\n            let numVertices = polygon.polygonIndices.length; //Numero vertices do poligono ()\r\n            numTotalVertices += numVertices; //just count\r\n            let RGBA = this.transitoryPickingColors[i]; //[ [RGBA], [RGBA]]\r\n            // console.log(polygon.polygonIndices, RGBA);\r\n            let [r, g, b, a] = [...RGBA];\r\n\r\n            //GENERATE COLORS FOR POLYGONS \"RANDOM\"\r\n            /*   if (!window.i)\r\n                  window.i = 200;\r\n              [r, g, b, a] = [200, 200, 200, window.i++]; */\r\n\r\n            for (let j = 0; j < numVertices; j++)\r\n                finalColors.push(r, g, b, a);\r\n        }\r\n        console.assert(numTotalVertices === finalColors.length / 4);\r\n        console.log(finalColors);\r\n        console.log(\"NumTotalIndices = \", numTotalVertices, \"Num Colors = \", finalColors.length);\r\n\r\n        this.transitoryPickingColors = undefined;\r\n\r\n        let gl = this.webglContext;\r\n        this.finalPickingColors = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.finalPickingColors);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(finalColors), gl.STATIC_DRAW);\r\n\r\n        // console.log(gl.isBuffer(this.finalPickingColors));\r\n\r\n        // this.finalPickingColors = pickingBuffer;\r\n        // throw new Error(\"WUT\");\r\n    }\r\n\r\n    //@TODO DELETE\r\n    joinPickingColorsPolygons(polygons) { //generate color for each vertex (each indice generated)\r\n\r\n    }\r\n\r\n    //@TODO DELETE\r\n    joinPickingColorsLines(lines) { //generate color for each vertex (each indice generated)\r\n        console.log(\"JOIN PICKING COLORS LINES\", this.transitoryPickingColors, lines);\r\n        let finalColors = [];\r\n        let numTotalIndices = 0;\r\n        for (const [i, line] of lines.entries()) {\r\n            let numVertices = line.length;\r\n            numTotalIndices += numVertices;\r\n            let RGBA = this.transitoryPickingColors[i];\r\n            let [r, g, b, a] = [...RGBA];\r\n            for (let j = 0; j < numVertices; j++)\r\n                finalColors.push(r, g, b, a);\r\n        }\r\n        console.log(finalColors);\r\n        console.assert(numTotalIndices === finalColors.length / 4);\r\n        console.log(\"NumTotalIndices = \", numTotalIndices, \"Num Colors = \", finalColors.length / 4);\r\n\r\n\r\n        this.transitoryPickingColors = undefined;\r\n\r\n        let gl = this.webglContext;\r\n        this.finalPickingColors = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.finalPickingColors);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(finalColors), gl.STATIC_DRAW);\r\n        // this.finalPickingColors = pickingBuffer;\r\n        // throw new Error(\"WUT\");\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/Picking.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 859,
    "kind": "class",
    "name": "WebGLPicking",
    "memberof": "src/Gisplay/VVs/Picking.js",
    "static": true,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/Picking.js",
    "importStyle": "{WebGLPicking}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 860,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#constructor",
    "access": "public",
    "description": "Creates an instance of WebGLPicking.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "The WebGL context."
      }
    ]
  },
  {
    "__docId__": 861,
    "kind": "member",
    "name": "webglContext",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#webglContext",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "type": {
      "nullable": null,
      "types": [
        "WebGLRenderingContext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 862,
    "kind": "member",
    "name": "continuousData",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#continuousData",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true
  },
  {
    "__docId__": 863,
    "kind": "member",
    "name": "optionalInfo",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#optionalInfo",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true
  },
  {
    "__docId__": 864,
    "kind": "member",
    "name": "transitoryPickingColors",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#transitoryPickingColors",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true
  },
  {
    "__docId__": 865,
    "kind": "member",
    "name": "finalPickingColors",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#finalPickingColors",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true
  },
  {
    "__docId__": 866,
    "kind": "member",
    "name": "searchColors",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#searchColors",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true
  },
  {
    "__docId__": 867,
    "kind": "method",
    "name": "addRow",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#addRow",
    "access": "public",
    "description": "Add the picking information.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "dataRow",
        "description": "The row of data that was given by the Parser."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryPrimitive",
        "description": "The identifier of the geometry primitive."
      }
    ]
  },
  {
    "__docId__": 868,
    "kind": "method",
    "name": "addSetOfRows",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#addSetOfRows",
    "access": "public",
    "description": "Add a set of rows to this temporal granule.     ",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}"
        ],
        "spread": false,
        "optional": false,
        "name": "dataRows",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 869,
    "kind": "method",
    "name": "getPickingColors",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#getPickingColors",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true
  },
  {
    "__docId__": 870,
    "kind": "method",
    "name": "getSearchColors",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#getSearchColors",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true
  },
  {
    "__docId__": 871,
    "kind": "method",
    "name": "findColorIndex",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#findColorIndex",
    "access": "public",
    "description": "Find the index of the given RGBA number in the list of searchable colors.",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - -1 if the numberRGBA is not found."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberRGBA",
        "description": "The RGBA number representation."
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "hasIds",
        "description": "Boolean that represents the presence or absence or ids."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "-1 if the numberRGBA is not found."
    }
  },
  {
    "__docId__": 872,
    "kind": "method",
    "name": "binarySearchColorIndex",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#binarySearchColorIndex",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true
  },
  {
    "__docId__": 873,
    "kind": "method",
    "name": "getOptionalInfo",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#getOptionalInfo",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true
  },
  {
    "__docId__": 874,
    "kind": "method",
    "name": "getIndexOptionalData",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#getIndexOptionalData",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "undocument": true
  },
  {
    "__docId__": 875,
    "kind": "method",
    "name": "getIndexContinuousData",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#getIndexContinuousData",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true
  },
  {
    "__docId__": 876,
    "kind": "method",
    "name": "joinPickingColorsPoints",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#joinPickingColorsPoints",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true
  },
  {
    "__docId__": 879,
    "kind": "method",
    "name": "replaceRowRGBAValue",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#replaceRowRGBAValue",
    "access": "public",
    "description": "Replaces the RGBA with the RGBA from the GeoJSONIdsParser.",
    "lineNumber": 194,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rowIndex",
        "description": "The index where to replace."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "RGBA",
        "description": "The RGBA identifier."
      },
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "hasPoints",
        "description": "Boolean that represents the presence or absence of points."
      }
    ]
  },
  {
    "__docId__": 880,
    "kind": "method",
    "name": "joinPickingColorsPointsCSV",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#joinPickingColorsPointsCSV",
    "access": "public",
    "description": null,
    "lineNumber": 204,
    "undocument": true
  },
  {
    "__docId__": 882,
    "kind": "method",
    "name": "joinPickingColorsPolygonsOLD",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#joinPickingColorsPolygonsOLD",
    "access": "public",
    "description": null,
    "lineNumber": 221,
    "undocument": true
  },
  {
    "__docId__": 885,
    "kind": "method",
    "name": "joinPickingColorsPolygons",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#joinPickingColorsPolygons",
    "access": "public",
    "description": null,
    "lineNumber": 258,
    "undocument": true
  },
  {
    "__docId__": 886,
    "kind": "method",
    "name": "joinPickingColorsLines",
    "memberof": "src/Gisplay/VVs/Picking.js~WebGLPicking",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/Picking.js~WebGLPicking#joinPickingColorsLines",
    "access": "public",
    "description": null,
    "lineNumber": 263,
    "undocument": true
  },
  {
    "__docId__": 889,
    "kind": "file",
    "name": "src/Gisplay/VVs/TemporalGranule.js",
    "content": "import { WebGLPicking } from './Picking';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\nimport { GisplayError } from '../GisplayError';\r\n\r\n/**\r\n * Represents a temporal granule.\r\n * @export\r\n * @class TemporalGranule\r\n */\r\nexport class TemporalGranule {\r\n\r\n    /**\r\n     * Creates an instance of TemporalGranule.\r\n     * @param {number} granuleIndex - The index of this temporal granule. NOT USED ATM.\r\n     * @param {WebGLRenderingContext} webglContext - The WebGL renderind context.\r\n     * @param {boolean} anyQualifierIsAttribute - If any continuous variable has 'attribute' qualifier in the shader.\r\n     * @memberof TemporalGranule\r\n     */\r\n    constructor(granuleIndex, webglContext, anyQualifierIsAttribute) {\r\n        /**\r\n         * Information about the temporal granule. Example: January or 0. December or 11.\r\n         * @type {string|number} \r\n         */\r\n        this.granuleIndex = granuleIndex;\r\n        /**\r\n         * This holds the geometry data for this temporal granule until we have all the data and can create the Buffer with it.\r\n         * @type {Array<number>|Array<{polygonIndices:Array<number>, bordersIndices:Array<number>}>}\r\n         */\r\n        this.transitoryGeometryData = [];\r\n        /**\r\n         * This is the data that will be drawn for each time data is draw on the canvas.\r\n         * @type {WebGLBuffer|{polygonsIndices: WebGLBuffer, bordersIndices:WebGLBuffer}}\r\n         */\r\n        this.geometryDataBuffer;\r\n        /**\r\n         * The geometry primitive.\r\n         * @type {string}\r\n         */\r\n        this.geometryPrimitive;\r\n        if (anyQualifierIsAttribute) {\r\n            /**\r\n             * An array that saves the data for the continuous variables when there's at least  one that has qualifier equal to 'attribute'. \r\n             * @type {Array<Array<number>>}\r\n             */\r\n            this.attributeData = [];\r\n        }\r\n\r\n        /**\r\n         * Number of points/polygons/lines that this temporal granule contains.\r\n         * Used for points.\r\n         * @type {number}\r\n         */\r\n        this.numElements = 0;\r\n        /**\r\n         * Boolean that's true if there's at least one element in this temporal granule to be drawn.\r\n         * @type {boolean}\r\n         */\r\n        this.hasElementsBool = false;\r\n        /**\r\n         * Human readable name for this granule;\r\n         * @type {string}\r\n         */\r\n        this.label = granuleIndex;\r\n\r\n        /**\r\n         * Holds the picking data.\r\n         * @type {WebGLPicking}\r\n         */\r\n        this.webGLPicking = new WebGLPicking(webglContext);\r\n\r\n        /**\r\n         * The identifier of this temporal granule.\r\n         * @type {Array<number>}\r\n         */\r\n        this.RGBAIdentifier;\r\n\r\n        this.hasPoints = false; //Used to only add the RGBA to the pickingColors if has points from the GeoJSON file\r\n        this.alreadyExecutedOnce = false; //So it isnt always calling the hasPoints method\r\n    }\r\n\r\n    /**\r\n     * Add the row of data to this temporal granule. Adds the picking information to the WebGLPicking object.\r\n     * @param {Array<Object>} dataRow - The row of data that was given by the Parser.\r\n     * @param {number} geometryPrimitive - The identifier of the geometry primitive.\r\n     * @memberof TemporalGranule\r\n     */\r\n    addDataRow(dataRow, geometryPrimitive) { //GEOJSON\r\n        // console.log(dataRow);\r\n        if (!this.alreadyExecutedOnce) {\r\n            this.alreadyExecutedOnce = true;\r\n            this.hasPoints = GisplayDefaults.hasPoints(geometryPrimitive);\r\n        }\r\n        if (this.hasPoints)\r\n            this.transitoryGeometryData.push(...dataRow[1].spatial); //Push geometry\r\n        else\r\n            this.transitoryGeometryData.push(dataRow[1].spatial); //Push geometry\r\n\r\n        if (this.attributeData)\r\n            this.attributeData.push(dataRow[0]);\r\n        this.webGLPicking.addRow(dataRow, this.hasPoints);\r\n    }\r\n\r\n    /**\r\n     * Add a set of rows to this temporal granule. Used for the CSV parser.\r\n     * @param {{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}} dataRows - \r\n     * @memberof TemporalGranule\r\n     */\r\n    addSetOfRows(dataRows) { //CSV\r\n        // console.log(dataRows);\r\n        if (dataRows.spatialData.length > 0) {\r\n            for (const lnglat of dataRows.spatialData)\r\n                this.transitoryGeometryData.push(lnglat);\r\n            this.webGLPicking.addSetOfRows(dataRows);\r\n            if (this.attributeData) {\r\n                let attrData = dataRows.continuousData[0]; //@TODO: If the first is not the attributeData we want? E.g. 2 continuous variables\r\n                for (let attr of attrData) { \r\n                    this.attributeData.push(attr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the array of data. This data can be a WebGLBuffer is it holds points, an Array of Polygons if it holds Polygons or an Array of Lines if it holds lines.\r\n     * @returns {WebGLBuffer|{polygonsIndices: WebGLBuffer, bordersIndices:WebGLBuffer}}\r\n     * @memberof TemporalGranule\r\n     */\r\n    getGeometryData() {\r\n        return this.geometryDataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Returns the data relative to the continuous variable that has 'attribute' qualifier.\r\n     * @returns {Array<Array<number>>} \r\n     * @memberof TemporalGranule\r\n     */\r\n    getAttributeData() {\r\n        return this.attributeData;\r\n    }\r\n\r\n    /**\r\n     * The number of elements in the data array.\r\n     * @returns {number} - number of elements in the data array.\r\n     * @memberof TemporalGranule\r\n     */\r\n    getNumElements() {\r\n        return this.numElements;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there's at least one element to be drawn, false otherwise.\r\n     * @returns {boolean} - true if there's at least one element to be drawn, false otherwise.s\r\n     * @memberof TemporalGranule\r\n     */\r\n    hasElements() {\r\n        return this.hasElementsBool;\r\n    }\r\n\r\n    /**\r\n     * Update the geometry primitive.\r\n     * @param {string} geometryPrimitive \r\n     * @memberof TemporalGranule\r\n     */\r\n    setGeometryPrimitive(geometryPrimitive) {\r\n        this.geometryPrimitive = geometryPrimitive;\r\n    }\r\n\r\n    /**\r\n     * Set the number of elements. This way updates the number of elements for this temporal granule.\r\n     * @memberof TemporalGranule\r\n     */\r\n    setNumElements() {\r\n        // console.log(this.transitoryGeometryData, this.geometryPrimitive);\r\n        if (GisplayDefaults.hasPolygons(this.geometryPrimitive)) {//Array.isArray(this.transitoryGeometryData[0]) && Array.isArray(this.transitoryGeometryData[0].polygonIndices)) { //Change to this.primitive === POLYGON\r\n            this.numElements = {\r\n                polygonsIndices: 0,\r\n                bordersIndices: 0\r\n            };\r\n            for (let geo of this.transitoryGeometryData) {\r\n                this.numElements.polygonsIndices += geo.polygonIndices.length;\r\n                this.numElements.bordersIndices += geo.bordersIndices.length;\r\n            }\r\n        }\r\n        else if (GisplayDefaults.hasLines(this.geometryPrimitive)) {\r\n            for (let geo of this.transitoryGeometryData)\r\n                this.numElements += geo.lineIndices.length;\r\n        }\r\n        else if (GisplayDefaults.hasPoints(this.geometryPrimitive) || GisplayDefaults.hasCSVPoints(this.geometryPrimitive)) { //POINTS\r\n            this.numElements = this.transitoryGeometryData.length / 2; //Since each point is inside an array of [lng, lat] then no need to divide by 2\r\n        }\r\n\r\n        if (+this.numElements === +this.numElements && this.numElements > 0)\r\n            this.hasElementsBool = true;\r\n        else if (this.numElements.polygonsIndices > 0)\r\n            this.hasElementsBool = true;\r\n        // console.log(this.numElements, this.hasPoints, this.hasElements(), this.geometryPrimitive);\r\n    }\r\n\r\n    /**\r\n     * Defines the RGBA identifier for this \r\n     * @param {number} r - Used to identify the the MVC\r\n     * @param {number} g - Used to identify the the MVC\r\n     * @param {number} b - Used to identify the the TG\r\n     * @param {number} a - Used to identify the the TG\r\n     * @memberof TemporalGranule\r\n     */\r\n    setRTGRGBAIdentifier(r, g, b, a) {\r\n        // console.error(r, g, b, a);\r\n        this.RGBAIdentifier = [r, g, b, a];\r\n    }\r\n\r\n    /**\r\n     * Returns the RGBA identifier that is being used for this MVC/TG combination.\r\n     * @returns {Array<number>} - the RGBA identifier that is being used for this MVC/TG combination.\r\n     * @memberof TemporalGranule\r\n     */\r\n    getRGBAIdentifier() {\r\n        return this.RGBAIdentifier;\r\n    }\r\n\r\n    /**\r\n     * Joins all points into one single WebGLBuffer. This allows for a nicer and faster way to draw all of them at once.\r\n     * @param {WebGLRenderingContext} webglContext - the context to use to join all points in one WebGLBuffer.\r\n     * @memberof TemporalGranule\r\n     */\r\n    joinPointData(webglContext) {\r\n        const vertArray = new Float32Array(this.transitoryGeometryData);\r\n        this.geometryDataBuffer = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, this.geometryDataBuffer);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);\r\n        this._clearTransitoryGeometryData();\r\n    }\r\n\r\n    /**\r\n     * Join all indices for all polygons that make this temporal granule. This way all polygons can be drawn in one call.\r\n     * @param {WebGLRenderingContext} webglContext - The contex to use to join the attribute data. \r\n     * @memberof TemporalGranule\r\n     */\r\n    joinPolygonData(webglContext) {\r\n        this.geometryDataBuffer = {};\r\n\r\n        let tempPolygonIndices = [];\r\n        for (let geoIndices of this.transitoryGeometryData)\r\n            for (let geoIndex of geoIndices.polygonIndices)\r\n                tempPolygonIndices.push(geoIndex);\r\n        // console.log(\"POLYGON DATA JOIN POLis\", tempPolygonIndices);\r\n        const vertArray = new Uint32Array(tempPolygonIndices);\r\n        this.geometryDataBuffer.polygonsIndices = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ELEMENT_ARRAY_BUFFER, this.geometryDataBuffer.polygonsIndices);\r\n        webglContext.bufferData(webglContext.ELEMENT_ARRAY_BUFFER, vertArray, webglContext.DYNAMIC_DRAW);\r\n\r\n        // console.log(\"TG polygonIndices = \", tempPolygonIndices.length);\r\n\r\n        let tempBordersIndices = [];\r\n        for (let geoIndices of this.transitoryGeometryData)\r\n            for (let geoIndex of geoIndices.bordersIndices)\r\n                tempBordersIndices.push(geoIndex);\r\n        // console.log(\"POLYGON DATA JOIN BORDERS\", tempBordersIndices);\r\n        const vertArray2 = new Uint32Array(tempBordersIndices);\r\n        this.geometryDataBuffer.bordersIndices = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ELEMENT_ARRAY_BUFFER, this.geometryDataBuffer.bordersIndices);\r\n        webglContext.bufferData(webglContext.ELEMENT_ARRAY_BUFFER, vertArray2, webglContext.DYNAMIC_DRAW);\r\n\r\n        this._clearTransitoryGeometryData();\r\n    }\r\n\r\n    /**\r\n     * Join the lines into one single WebGLBuffer.\r\n     * @memberof TemporalGranule\r\n     */\r\n    joinLineData(webglContext) {\r\n        let tempLineIndices = [];\r\n        console.log(this.transitoryGeometryData);\r\n        for (let geoIndices of this.transitoryGeometryData)\r\n            for (let geoIndex of geoIndices.lineIndices)\r\n                tempLineIndices.push(geoIndex);\r\n        console.warn(\"LINEDATA\", tempLineIndices);\r\n        const vertArray = new Uint32Array(tempLineIndices);\r\n        this.geometryDataBuffer = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ELEMENT_ARRAY_BUFFER, this.geometryDataBuffer);\r\n        webglContext.bufferData(webglContext.ELEMENT_ARRAY_BUFFER, vertArray, webglContext.DYNAMIC_DRAW);\r\n        this._clearTransitoryGeometryData();\r\n    }\r\n\r\n    /**\r\n     * Clear (allow garbage collection) the transitory geometry data array.\r\n     * @memberof TemporalGranule\r\n     */\r\n    _clearTransitoryGeometryData() {\r\n        this.transitoryGeometryData = undefined;\r\n    }\r\n\r\n    /**\r\n     * Join attribute data into one WebGLBuffer.\r\n     * @param {WebGLRenderingContext} webglContext - The contex to use to join the attribute data. \r\n     * @memberof TemporalGranule\r\n     */\r\n    joinAttributeData(webglContext) {\r\n        console.log(this.attributeData);\r\n        const attrDataVertex = new Float32Array(this.attributeData);\r\n        const bufferAttrData = webglContext.createBuffer();\r\n        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferAttrData);\r\n        webglContext.bufferData(webglContext.ARRAY_BUFFER, attrDataVertex, webglContext.STATIC_DRAW);\r\n        this.attributeData = bufferAttrData;\r\n    }\r\n\r\n    /**\r\n     * Join all picking colors into one WebGLBuffer.\r\n     * @memberof TemporalGranule\r\n     */\r\n    joinPickingColors() {\r\n        if (GisplayDefaults.hasPoints(this.geometryPrimitive) || GisplayDefaults.hasCSVPoints(this.geometryPrimitive))\r\n            this.webGLPicking.joinPickingColorsPoints();\r\n    }\r\n\r\n    /**\r\n     * Returns the picking data associated with this visual variable combination.\r\n     * @returns {WebGLPicking} - the picking data associated with this visual variable combination.\r\n     * @memberof TemporalGranule\r\n     */\r\n    getPickingData() {\r\n        return this.webGLPicking;\r\n    }\r\n\r\n    /**\r\n     * Replace the ids on the transitory geometry data with the real geometry.\r\n     * @param {Map<string, {spatial:{any}, RGBA: Array<number>} >} geometryIdsMap - The geometry to ids map processed by the GeoJSONIdsParser.\r\n     * @memberof TemporalGranule\r\n     */\r\n    replaceIdsWithGeometry(geometryIdsMap) {\r\n        for (let i = 0; i < this.transitoryGeometryData.length; i++) {\r\n            let id = this.transitoryGeometryData[i];\r\n            let geoRGBA = geometryIdsMap.get(id); //Geometry (spatial) + RGBA identifier\r\n            // console.log(geoRGBA);\r\n            if (!geoRGBA)\r\n                throw new GisplayError(`The id:${id} was not found in the geometry read from the GeoJSON file. Check the geometry file...`);\r\n            this.transitoryGeometryData[i] = geoRGBA.spatial;\r\n            this.webGLPicking.replaceRowRGBAValue(i, geoRGBA.RGBA, this.hasPoints);\r\n        }\r\n        if (!this.hasPoints)\r\n            this.webGLPicking.transitoryPickingColors = null;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/TemporalGranule.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 890,
    "kind": "class",
    "name": "TemporalGranule",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js",
    "static": true,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/TemporalGranule.js",
    "importStyle": "{TemporalGranule}",
    "description": "Represents a temporal granule.",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TemporalGranule"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 891,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#constructor",
    "access": "public",
    "description": "Creates an instance of TemporalGranule.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "granuleIndex",
        "description": "The index of this temporal granule. NOT USED ATM."
      },
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "The WebGL renderind context."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "anyQualifierIsAttribute",
        "description": "If any continuous variable has 'attribute' qualifier in the shader."
      }
    ]
  },
  {
    "__docId__": 892,
    "kind": "member",
    "name": "granuleIndex",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#granuleIndex",
    "access": "public",
    "description": "Information about the temporal granule. Example: January or 0. December or 11.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 893,
    "kind": "member",
    "name": "transitoryGeometryData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#transitoryGeometryData",
    "access": "public",
    "description": "This holds the geometry data for this temporal granule until we have all the data and can create the Buffer with it.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Array<number>|Array<{polygonIndices:Array<number>, bordersIndices:Array<number>}>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 894,
    "kind": "member",
    "name": "attributeData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#attributeData",
    "access": "public",
    "description": "An array that saves the data for the continuous variables when there's at least  one that has qualifier equal to 'attribute'. ",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 895,
    "kind": "member",
    "name": "numElements",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#numElements",
    "access": "public",
    "description": "Number of points/polygons/lines that this temporal granule contains.\nUsed for points.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 896,
    "kind": "member",
    "name": "hasElementsBool",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#hasElementsBool",
    "access": "public",
    "description": "Boolean that's true if there's at least one element in this temporal granule to be drawn.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 897,
    "kind": "member",
    "name": "label",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#label",
    "access": "public",
    "description": "Human readable name for this granule;",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 898,
    "kind": "member",
    "name": "webGLPicking",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#webGLPicking",
    "access": "public",
    "description": "Holds the picking data.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "WebGLPicking"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 899,
    "kind": "member",
    "name": "hasPoints",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#hasPoints",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true
  },
  {
    "__docId__": 900,
    "kind": "member",
    "name": "alreadyExecutedOnce",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#alreadyExecutedOnce",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true
  },
  {
    "__docId__": 901,
    "kind": "method",
    "name": "addDataRow",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#addDataRow",
    "access": "public",
    "description": "Add the row of data to this temporal granule. Adds the picking information to the WebGLPicking object.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "dataRow",
        "description": "The row of data that was given by the Parser."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryPrimitive",
        "description": "The identifier of the geometry primitive."
      }
    ]
  },
  {
    "__docId__": 904,
    "kind": "method",
    "name": "addSetOfRows",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#addSetOfRows",
    "access": "public",
    "description": "Add a set of rows to this temporal granule. Used for the CSV parser.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}"
        ],
        "spread": false,
        "optional": false,
        "name": "dataRows",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 905,
    "kind": "method",
    "name": "getGeometryData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#getGeometryData",
    "access": "public",
    "description": "Returns the array of data. This data can be a WebGLBuffer is it holds points, an Array of Polygons if it holds Polygons or an Array of Lines if it holds lines.",
    "lineNumber": 128,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WebGLBuffer|{polygonsIndices: WebGLBuffer, bordersIndices:WebGLBuffer}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WebGLBuffer",
        "{polygonsIndices: WebGLBuffer, bordersIndices:WebGLBuffer}"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 906,
    "kind": "method",
    "name": "getAttributeData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#getAttributeData",
    "access": "public",
    "description": "Returns the data relative to the continuous variable that has 'attribute' qualifier.",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Array<number>>} "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Array<number>>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 907,
    "kind": "method",
    "name": "getNumElements",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#getNumElements",
    "access": "public",
    "description": "The number of elements in the data array.",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - number of elements in the data array."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "number of elements in the data array."
    }
  },
  {
    "__docId__": 908,
    "kind": "method",
    "name": "hasElements",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#hasElements",
    "access": "public",
    "description": "Returns true if there's at least one element to be drawn, false otherwise.",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true if there's at least one element to be drawn, false otherwise.s"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if there's at least one element to be drawn, false otherwise.s"
    }
  },
  {
    "__docId__": 909,
    "kind": "method",
    "name": "setGeometryPrimitive",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#setGeometryPrimitive",
    "access": "public",
    "description": "Update the geometry primitive.",
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "geometryPrimitive",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 910,
    "kind": "member",
    "name": "geometryPrimitive",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#geometryPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 165,
    "undocument": true
  },
  {
    "__docId__": 911,
    "kind": "method",
    "name": "setNumElements",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#setNumElements",
    "access": "public",
    "description": "Set the number of elements. This way updates the number of elements for this temporal granule.",
    "lineNumber": 172
  },
  {
    "__docId__": 917,
    "kind": "method",
    "name": "setRTGRGBAIdentifier",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#setRTGRGBAIdentifier",
    "access": "public",
    "description": "Defines the RGBA identifier for this ",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "Used to identify the the MVC"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "g",
        "description": "Used to identify the the MVC"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "Used to identify the the TG"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Used to identify the the TG"
      }
    ]
  },
  {
    "__docId__": 918,
    "kind": "member",
    "name": "RGBAIdentifier",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#RGBAIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 209,
    "undocument": true
  },
  {
    "__docId__": 919,
    "kind": "method",
    "name": "getRGBAIdentifier",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#getRGBAIdentifier",
    "access": "public",
    "description": "Returns the RGBA identifier that is being used for this MVC/TG combination.",
    "lineNumber": 217,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the RGBA identifier that is being used for this MVC/TG combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the RGBA identifier that is being used for this MVC/TG combination."
    }
  },
  {
    "__docId__": 920,
    "kind": "method",
    "name": "joinPointData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#joinPointData",
    "access": "public",
    "description": "Joins all points into one single WebGLBuffer. This allows for a nicer and faster way to draw all of them at once.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "the context to use to join all points in one WebGLBuffer."
      }
    ]
  },
  {
    "__docId__": 921,
    "kind": "member",
    "name": "geometryDataBuffer",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#geometryDataBuffer",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true
  },
  {
    "__docId__": 922,
    "kind": "method",
    "name": "joinPolygonData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#joinPolygonData",
    "access": "public",
    "description": "Join all indices for all polygons that make this temporal granule. This way all polygons can be drawn in one call.",
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "The contex to use to join the attribute data."
      }
    ]
  },
  {
    "__docId__": 924,
    "kind": "method",
    "name": "joinLineData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#joinLineData",
    "access": "public",
    "description": "Join the lines into one single WebGLBuffer.",
    "lineNumber": 271
  },
  {
    "__docId__": 926,
    "kind": "method",
    "name": "_clearTransitoryGeometryData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#_clearTransitoryGeometryData",
    "access": "private",
    "description": "Clear (allow garbage collection) the transitory geometry data array.",
    "lineNumber": 289
  },
  {
    "__docId__": 928,
    "kind": "method",
    "name": "joinAttributeData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#joinAttributeData",
    "access": "public",
    "description": "Join attribute data into one WebGLBuffer.",
    "lineNumber": 298,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGLRenderingContext"
        ],
        "spread": false,
        "optional": false,
        "name": "webglContext",
        "description": "The contex to use to join the attribute data."
      }
    ]
  },
  {
    "__docId__": 930,
    "kind": "method",
    "name": "joinPickingColors",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#joinPickingColors",
    "access": "public",
    "description": "Join all picking colors into one WebGLBuffer.",
    "lineNumber": 311
  },
  {
    "__docId__": 931,
    "kind": "method",
    "name": "getPickingData",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#getPickingData",
    "access": "public",
    "description": "Returns the picking data associated with this visual variable combination.",
    "lineNumber": 321,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WebGLPicking} - the picking data associated with this visual variable combination."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WebGLPicking"
      ],
      "spread": false,
      "description": "the picking data associated with this visual variable combination."
    }
  },
  {
    "__docId__": 932,
    "kind": "method",
    "name": "replaceIdsWithGeometry",
    "memberof": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TemporalGranule.js~TemporalGranule#replaceIdsWithGeometry",
    "access": "public",
    "description": "Replace the ids on the transitory geometry data with the real geometry.",
    "lineNumber": 330,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map<string, {spatial:{any}, RGBA: Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": ">}",
        "description": "geometryIdsMap - The geometry to ids map processed by the GeoJSONIdsParser."
      }
    ]
  },
  {
    "__docId__": 933,
    "kind": "file",
    "name": "src/Gisplay/VVs/TimeVariable.js",
    "content": "import { DataVariable } from './DataVariable';\r\nimport { GisplayDefaults } from '../GisplayDefaults';\r\n\r\n/**\r\n * Represents the time information.\r\n * @export\r\n * @class TimeVariable\r\n */\r\nexport class TimeVariable extends DataVariable {\r\n\r\n    /**\r\n     * Creates an instance of TimeVariable.\r\n     * @param {string} externalName - The external name of the time variable.\r\n     * @param {string} internalName - The internal name of the time variable.\r\n     * @param {string} granularity - The granularity of the time variable.\r\n     * @param {string} timeControl - The time control for the time variable.\r\n     * @memberof TimeVariable\r\n     */\r\n    constructor(externalName, internalName, granularity, timeControl) {\r\n        super(externalName, internalName);\r\n        /**\r\n         * The time granularity.\r\n         * @type {string}\r\n         */\r\n        this.granularity = granularity;\r\n        /**\r\n         * The granules for this time variable that were processed from the file.\r\n         * @type {Set<string|number>}\r\n         */\r\n        this.granules = new Set();\r\n        /**\r\n         * A map with each temporal granule and it's index.\r\n         * @type {Map<number|string, number>}\r\n         */\r\n        this.temporalGranulesMap = new Map();\r\n        /**\r\n         * The current granule index. This is used to give each granule it's specific index.\r\n         * @type {number}\r\n         */\r\n        this.granuleIndex = 0;\r\n        /**\r\n         * The temporal granules sorted by Date. If its a number (year or day or value etc) then sorted by number.\r\n         * @type {Array<number|string>}\r\n         */\r\n        this.sortedTemporalGranulesArr = [];\r\n        /** \r\n         * The map that contains the string that represents the date and the respective date (e.g. 2016_1_1 => 1 January 2016 OR 2016 => 2016)\r\n         * If the date is a number (e.g. year, monthOfYear, value etc) then the key and the value are equal (2016 => 2016).\r\n         * A value here will be a key in the temporalGranulesMap.\r\n         * @type {Map<string|number, string|number>}\r\n         */\r\n        this.strToTemporalGranuleMap = new Map();\r\n        /** \r\n         * The map with the string temporal granules and their respective index inm the sorted temporal granules array.\r\n         * E.g. Map (3)  {\"1 January 2016\" => 0, \"2 January 2016\" => 1, \"3 January 2016\" => 2, \"4 January 2016\" => 3 }.\r\n         * Used to quickly search for the index of the start and end point of the time control.\r\n         * A value here is an index in the sortedTemporalGranulesArr.\r\n         * @type {Map<string|number, number>}\r\n         */\r\n        this.sortedTGsToIndexMap = new Map();\r\n        /**\r\n         * The time control to use.\r\n         * @type {string}\r\n         */\r\n        this.timeControl = timeControl;\r\n    }\r\n\r\n    /**\r\n     * The granularity\r\n     * @returns {string} - The granularity. \r\n     * @memberof TimeVariable\r\n     */\r\n    getGranularity() {\r\n        return this.granularity;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of time control that should be used.\r\n     * @returns \r\n     * @memberof TimeVariable\r\n     */\r\n    getTypeOfTimeControl() {\r\n        return this.timeControl ? this.timeControl : GisplayDefaults.INSTANT();\r\n    }\r\n\r\n    /**\r\n     * Available granularities for the time value.\r\n     * @returns {Array<string>} - the set of available granularities.  \r\n     * @memberof TimeVariable\r\n     */\r\n    _getAvailableGranularities() {\r\n        return ['year', 'month', 'day', 'value', //Continuous\r\n            'monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour' // Cyclic\r\n        ];\r\n    }\r\n\r\n    //GRANULES ETC\r\n    /**\r\n     * Add all values to the temporal granules map.\r\n     * @param {Array<number>} values - The array of values to add to the granules map.\r\n     * @memberof TimeVariable\r\n     */\r\n    createTemporalGranulesMap(values) {\r\n        for (let val of values)\r\n            this.temporalGranulesMap.set(val, this.granuleIndex++);\r\n    }\r\n\r\n    /**\r\n     * Add temporal granule to the temporal granules set and return it's index if it does not exist.\r\n     * @param {number} temporalGranule - The temporal granule to be added. \r\n     * @returns {number} - the index of the given temporal granule.\r\n     * @memberof TimeVariable\r\n     */\r\n    addTemporalGranule(temporalGranule) {\r\n        if (this.temporalGranulesMap.has(temporalGranule))\r\n            return this.temporalGranulesMap.get(temporalGranule);\r\n        else {\r\n            this.temporalGranulesMap.set(temporalGranule, this.granuleIndex);\r\n            return this.granuleIndex++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the given temporal granule to the set of existing temporal granules.\r\n     * @param {string|number} temporalGranule - The temporal granule to add to the set of temporal granules.\r\n     */\r\n    addTemporalGranuleToSet(temporalGranule) {\r\n        this.granules.add(temporalGranule);\r\n    }\r\n\r\n    /**\r\n     * Add temporal granules to the set of temporal granules.\r\n     * @param {Set<string>} temporalGranules - The temporal granules. \r\n     * @memberof TimeVariable\r\n     */\r\n    addTemporalGranulesToSet(temporalGranules) {\r\n        for (const temporalGranule of temporalGranules.keys())\r\n            this.addTemporalGranuleToSet(temporalGranule);\r\n    }\r\n\r\n    /**\r\n     * Returns the Set of temporal granules.\r\n     * @returns {Set<string>} - the Set of temporal granules. \r\n     * @memberof TimeVariable\r\n     */\r\n    getTemporalGranulesSet() {\r\n        return this.granules;\r\n    }\r\n\r\n    /**\r\n     * Returns the temporal granules that exist on the dataset. E.g. 2016, 2017 etc\r\n     * @returns {Map<number, number>} - the temporal granules that exist on the dataset.\r\n     * @memberof TimeVariable\r\n     */\r\n    getTemporalGranules() {\r\n        return this.temporalGranulesMap;//Array.from(this.temporalGranulesMap.keys());\r\n    }\r\n\r\n    /**\r\n     * Returns true if the temporal granule values were given, false, otherwise.\r\n     * @returns {booelan} - true if the temporal granule values were given, false, otherwise.\r\n     * @memberof TimeVariable\r\n     */\r\n    classCalculationRequired() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sort the temporal granules creating an array with those sorted elements.\r\n     * If the elements are dates then order by date, if they are numbers order by number.\r\n     * @returns {Array<string|number>} - the sorted temporal granules, sorted by date/number.\r\n     * @memberof TimeVariable\r\n     */\r\n    sortTemporalGranules() {\r\n        let availableGranularites = this._getAvailableGranularities();\r\n        let tgs = this.getTemporalGranules().keys();\r\n        let granularitiesArray = []; // \r\n        let strToTGMap = new Map(); // 26_1_0 => 1 January 2016\r\n        for (const tg of tgs) {\r\n            let strGranularity;\r\n            switch (this.granularity) {\r\n                case availableGranularites[1]: //Month\r\n                    strGranularity = this._getMonth(tg);\r\n                    break;\r\n                case availableGranularites[2]: //Day\r\n                    strGranularity = this._getDay(tg);\r\n                    break;\r\n                default:\r\n                    strGranularity = tg;\r\n                    break;\r\n            }\r\n            granularitiesArray.push(strGranularity);\r\n            strToTGMap.set(strGranularity, tg);\r\n        }\r\n        this.strToTemporalGranuleMap = strToTGMap;\r\n        this.sortedTemporalGranulesArr = granularitiesArray.sort((a, b) => { return new Date(a) - new Date(b); });\r\n        for (let [i, sortedTG] of this.sortedTemporalGranulesArr.entries())\r\n            this.sortedTGsToIndexMap.set(sortedTG, i);\r\n        /*   console.warn(this.sortedTemporalGranulesArr);\r\n          console.warn(this.strToTemporalGranuleMap);\r\n          console.warn(this.sortedTGsToIndexMap); */\r\n        this._sortTemporalGranulesMap();\r\n        return this.sortedTemporalGranulesArr;\r\n    }\r\n\r\n    /**\r\n     * Sort the temporal granules strings (read from file) to the indices of the sorted\r\n     * temporal granules.\r\n     * @private\r\n     * @memberof TimeVariable\r\n     */\r\n    _sortTemporalGranulesMap() {\r\n        let sortedIndexMap = new Map();\r\n        let sortedTGsToIndexMap = this.sortedTGsToIndexMap; //January 2017 -> 0, February 2017 -> 1\r\n        let strToTGMap = this.strToTemporalGranuleMap; //January 2017 -> 2017_1, February 2017 -> 2017_2\r\n        for (let key of sortedTGsToIndexMap.keys())\r\n            sortedIndexMap.set(strToTGMap.get(key), sortedTGsToIndexMap.get(key)); //2017_1 -> 0\r\n        this.temporalGranulesMap = sortedIndexMap;\r\n    }\r\n\r\n    /**\r\n     * Returns the locale month string. \r\n     * In portugal will return 'janeiro', 'fevereiro' etc... \r\n     * @param {string} dateString - The date string read from the file.\r\n     * @returns {string} - the locale month string.\r\n     * @private\r\n     * @see https://stackoverflow.com/a/18648314/\r\n     * @memberof TimeVariable\r\n     */\r\n    _getLocaleMonth(dateString) {\r\n        let date = new Date(dateString.replace(/_/g, '-'));\r\n        return date.toLocaleString(\"en-us\", { month: \"long\" });\r\n    }\r\n\r\n    /**\r\n     * Returns the month name plus the year.\r\n     * @param {string} dateString \r\n     * @returns {string} - the month name plus the year.\r\n     * @memberof TimeVariable\r\n     */\r\n    _getMonth(dateString) {\r\n        let date = new Date(dateString.replace(/_/g, '-'));\r\n        let monthName = this._getLocaleMonth(dateString);\r\n        let year = date.getFullYear();\r\n        return monthName + \" \" + year;\r\n    }\r\n\r\n    /**\r\n     * Get the date including the day (day month year).\r\n     * @param {string} dateString - The date string read from the file.\r\n     * @returns {string} - the date including the day.\r\n     * @see https://stackoverflow.com/a/18648314/\r\n     * @private\r\n     * @memberof TimeVariable\r\n     */\r\n    _getDay(dateString) {\r\n        let date = new Date(dateString.replace(/_/g, '-'));\r\n        let monthName = this._getLocaleMonth(dateString);\r\n        let day = date.getDate();\r\n        let year = date.getFullYear();\r\n        return day + \" \" + monthName + \" \" + year;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the temporal granule given by the string. \r\n     * @param {string|number} temporalgranuleStr - The temporal granule string representation.\r\n     * @returns {number} - the index of the temporal granule given by the string.\r\n     * @memberof TimeVariable\r\n     */\r\n    getGranuleIndexFromStr(temporalgranuleStr) {\r\n        let key = this.strToTemporalGranuleMap.get(temporalgranuleStr);\r\n        return this.temporalGranulesMap.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the temporal granule read from the file.\r\n     * @param {string} str - The given string \r\n     * @returns {number} - the index of the temporal granule read from the file.\r\n     * @memberof TimeVariable\r\n     */\r\n    getTGMapIndex(str) {\r\n        return this.temporalGranulesMap.get(str);\r\n    }\r\n\r\n    /**\r\n     * Returns the sorted temporal granules. \r\n     * @returns {Array<string|number>} - the sorted temporal granules.  \r\n     * @memberof TimeVariable\r\n     */\r\n    getSortedTemporalGranules() {\r\n        return this.sortedTemporalGranulesArr;\r\n    }\r\n\r\n    /**\r\n     * Returns the indices of the temporal granules between the start and end temporal granules string representations.\r\n     * @param {any} startTGStr - The string representation of the range start temporal granule. \r\n     * @param {any} endTGStr - The string representation of the range end temporal granule. \r\n     * @returns {Array<number>} - the indices of the temporal granules between the given start and end temporal granules.\r\n     * @memberof TimeVariable\r\n     */\r\n    getRangeIndices(startTGStr, endTGStr) {\r\n        let [sortedStartIndex, sortedEndIndex] = [this.sortedTGsToIndexMap.get(startTGStr), this.sortedTGsToIndexMap.get(endTGStr)];\r\n        let sortedTGsArrSliced = this.sortedTemporalGranulesArr.slice(sortedStartIndex, sortedEndIndex + 1);\r\n        let rangeIndices = [];\r\n        for (let sortedTG of sortedTGsArrSliced)\r\n            rangeIndices.push(this.getGranuleIndexFromStr(sortedTG));\r\n        return rangeIndices;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given temporal granule string/number. \r\n     * The index is the value associated with  the given key.\r\n     * @param {string|number} sortedTemporalGranule - The temporal granule string/number.\r\n     * @returns {number} - the index of the given temporal granule string/number. \r\n     * @memberof TimeVariable\r\n     */\r\n    getSortedIndexFromStr(sortedTemporalGranule) {\r\n        return this.sortedTGsToIndexMap.get(sortedTemporalGranule);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the next temporal granule on the \"timeline\".\r\n     * @param {string|number} currentTG - The current temporal granule.\r\n     * @returns {number} - the index of the next temporal granule on the \"timeline\".\r\n     * @memberof TimeVariable\r\n     */\r\n    findNextTGIndex(currentTG) {\r\n        let indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\r\n        let nextSortedTG = this.sortedTemporalGranulesArr[indexSortedTG + 1];\r\n        return this.getSortedIndexFromStr(nextSortedTG);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the previous temporal granule on the \"timeline\".\r\n     * @param {string|number} currentTG - The current temporal granule.\r\n     * @returns {number} - the index of the previous temporal granule on the \"timeline\".\r\n     * @memberof TimeVariable\r\n     */\r\n    findPreviousTGIndex(currentTG) {\r\n        let indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\r\n        let previousTG = this.sortedTemporalGranulesArr[indexSortedTG - 1];\r\n        return this.getSortedIndexFromStr(previousTG);\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/TimeVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 934,
    "kind": "class",
    "name": "TimeVariable",
    "memberof": "src/Gisplay/VVs/TimeVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/TimeVariable.js",
    "importStyle": "{TimeVariable}",
    "description": "Represents the time information.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TimeVariable"
      }
    ],
    "interface": false,
    "extends": [
      "src/Gisplay/VVs/DataVariable.js~DataVariable"
    ]
  },
  {
    "__docId__": 935,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#constructor",
    "access": "public",
    "description": "Creates an instance of TimeVariable.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "externalName",
        "description": "The external name of the time variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalName",
        "description": "The internal name of the time variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "granularity",
        "description": "The granularity of the time variable."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "timeControl",
        "description": "The time control for the time variable."
      }
    ]
  },
  {
    "__docId__": 936,
    "kind": "member",
    "name": "granularity",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#granularity",
    "access": "public",
    "description": "The time granularity.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 937,
    "kind": "member",
    "name": "granules",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#granules",
    "access": "public",
    "description": "The granules for this time variable that were processed from the file.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "Set<string|number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 938,
    "kind": "member",
    "name": "temporalGranulesMap",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#temporalGranulesMap",
    "access": "public",
    "description": "A map with each temporal granule and it's index.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "Map<number|string, number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 939,
    "kind": "member",
    "name": "granuleIndex",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#granuleIndex",
    "access": "public",
    "description": "The current granule index. This is used to give each granule it's specific index.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 940,
    "kind": "member",
    "name": "sortedTemporalGranulesArr",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#sortedTemporalGranulesArr",
    "access": "public",
    "description": "The temporal granules sorted by Date. If its a number (year or day or value etc) then sorted by number.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Array<number|string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 941,
    "kind": "member",
    "name": "strToTemporalGranuleMap",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#strToTemporalGranuleMap",
    "access": "public",
    "description": "The map that contains the string that represents the date and the respective date (e.g. 2016_1_1 => 1 January 2016 OR 2016 => 2016)\nIf the date is a number (e.g. year, monthOfYear, value etc) then the key and the value are equal (2016 => 2016).\nA value here will be a key in the temporalGranulesMap.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Map<string|number, string|number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 942,
    "kind": "member",
    "name": "sortedTGsToIndexMap",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#sortedTGsToIndexMap",
    "access": "public",
    "description": "The map with the string temporal granules and their respective index inm the sorted temporal granules array.\nE.g. Map (3)  {\"1 January 2016\" => 0, \"2 January 2016\" => 1, \"3 January 2016\" => 2, \"4 January 2016\" => 3 }.\nUsed to quickly search for the index of the start and end point of the time control.\nA value here is an index in the sortedTemporalGranulesArr.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "Map<string|number, number>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 943,
    "kind": "member",
    "name": "timeControl",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#timeControl",
    "access": "public",
    "description": "The time control to use.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 944,
    "kind": "method",
    "name": "getGranularity",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getGranularity",
    "access": "public",
    "description": "The granularity",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The granularity. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The granularity."
    }
  },
  {
    "__docId__": 945,
    "kind": "method",
    "name": "getTypeOfTimeControl",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getTypeOfTimeControl",
    "access": "public",
    "description": "Returns the type of time control that should be used.",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 946,
    "kind": "method",
    "name": "_getAvailableGranularities",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#_getAvailableGranularities",
    "access": "private",
    "description": "Available granularities for the time value.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string>} - the set of available granularities.  "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the set of available granularities."
    }
  },
  {
    "__docId__": 947,
    "kind": "method",
    "name": "createTemporalGranulesMap",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#createTemporalGranulesMap",
    "access": "public",
    "description": "Add all values to the temporal granules map.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "The array of values to add to the granules map."
      }
    ]
  },
  {
    "__docId__": 948,
    "kind": "method",
    "name": "addTemporalGranule",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#addTemporalGranule",
    "access": "public",
    "description": "Add temporal granule to the temporal granules set and return it's index if it does not exist.",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given temporal granule."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "temporalGranule",
        "description": "The temporal granule to be added."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given temporal granule."
    }
  },
  {
    "__docId__": 949,
    "kind": "method",
    "name": "addTemporalGranuleToSet",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#addTemporalGranuleToSet",
    "access": "public",
    "description": "Add the given temporal granule to the set of existing temporal granules.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "temporalGranule",
        "description": "The temporal granule to add to the set of temporal granules."
      }
    ]
  },
  {
    "__docId__": 950,
    "kind": "method",
    "name": "addTemporalGranulesToSet",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#addTemporalGranulesToSet",
    "access": "public",
    "description": "Add temporal granules to the set of temporal granules.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "temporalGranules",
        "description": "The temporal granules."
      }
    ]
  },
  {
    "__docId__": 951,
    "kind": "method",
    "name": "getTemporalGranulesSet",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getTemporalGranulesSet",
    "access": "public",
    "description": "Returns the Set of temporal granules.",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Set<string>} - the Set of temporal granules. "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<string>"
      ],
      "spread": false,
      "description": "the Set of temporal granules."
    }
  },
  {
    "__docId__": 952,
    "kind": "method",
    "name": "getTemporalGranules",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getTemporalGranules",
    "access": "public",
    "description": "Returns the temporal granules that exist on the dataset. E.g. 2016, 2017 etc",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map<number, number>} - the temporal granules that exist on the dataset."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map<number, number>"
      ],
      "spread": false,
      "description": "the temporal granules that exist on the dataset."
    }
  },
  {
    "__docId__": 953,
    "kind": "method",
    "name": "classCalculationRequired",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#classCalculationRequired",
    "access": "public",
    "description": "Returns true if the temporal granule values were given, false, otherwise.",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{booelan} - true if the temporal granule values were given, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "booelan"
      ],
      "spread": false,
      "description": "true if the temporal granule values were given, false, otherwise."
    }
  },
  {
    "__docId__": 954,
    "kind": "method",
    "name": "sortTemporalGranules",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#sortTemporalGranules",
    "access": "public",
    "description": "Sort the temporal granules creating an array with those sorted elements.\nIf the elements are dates then order by date, if they are numbers order by number.",
    "lineNumber": 174,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string|number>} - the sorted temporal granules, sorted by date/number."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string|number>"
      ],
      "spread": false,
      "description": "the sorted temporal granules, sorted by date/number."
    }
  },
  {
    "__docId__": 957,
    "kind": "method",
    "name": "_sortTemporalGranulesMap",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#_sortTemporalGranulesMap",
    "access": "private",
    "description": "Sort the temporal granules strings (read from file) to the indices of the sorted\ntemporal granules.",
    "lineNumber": 212
  },
  {
    "__docId__": 959,
    "kind": "method",
    "name": "_getLocaleMonth",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#_getLocaleMonth",
    "access": "private",
    "description": "Returns the locale month string. \nIn portugal will return 'janeiro', 'fevereiro' etc... ",
    "see": [
      "https://stackoverflow.com/a/18648314/"
    ],
    "lineNumber": 230,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the locale month string."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dateString",
        "description": "The date string read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the locale month string."
    }
  },
  {
    "__docId__": 960,
    "kind": "method",
    "name": "_getMonth",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#_getMonth",
    "access": "private",
    "description": "Returns the month name plus the year.",
    "lineNumber": 241,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the month name plus the year."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dateString",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the month name plus the year."
    }
  },
  {
    "__docId__": 961,
    "kind": "method",
    "name": "_getDay",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#_getDay",
    "access": "private",
    "description": "Get the date including the day (day month year).",
    "see": [
      "https://stackoverflow.com/a/18648314/"
    ],
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the date including the day."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dateString",
        "description": "The date string read from the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the date including the day."
    }
  },
  {
    "__docId__": 962,
    "kind": "method",
    "name": "getGranuleIndexFromStr",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getGranuleIndexFromStr",
    "access": "public",
    "description": "Returns the index of the temporal granule given by the string. ",
    "lineNumber": 270,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the temporal granule given by the string."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "temporalgranuleStr",
        "description": "The temporal granule string representation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the temporal granule given by the string."
    }
  },
  {
    "__docId__": 963,
    "kind": "method",
    "name": "getTGMapIndex",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getTGMapIndex",
    "access": "public",
    "description": "Returns the index of the temporal granule read from the file.",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the temporal granule read from the file."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": "The given string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the temporal granule read from the file."
    }
  },
  {
    "__docId__": 964,
    "kind": "method",
    "name": "getSortedTemporalGranules",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getSortedTemporalGranules",
    "access": "public",
    "description": "Returns the sorted temporal granules. ",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<string|number>} - the sorted temporal granules.  "
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string|number>"
      ],
      "spread": false,
      "description": "the sorted temporal granules."
    }
  },
  {
    "__docId__": 965,
    "kind": "method",
    "name": "getRangeIndices",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getRangeIndices",
    "access": "public",
    "description": "Returns the indices of the temporal granules between the start and end temporal granules string representations.",
    "lineNumber": 301,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<number>} - the indices of the temporal granules between the given start and end temporal granules."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "startTGStr",
        "description": "The string representation of the range start temporal granule."
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "endTGStr",
        "description": "The string representation of the range end temporal granule."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>"
      ],
      "spread": false,
      "description": "the indices of the temporal granules between the given start and end temporal granules."
    }
  },
  {
    "__docId__": 966,
    "kind": "method",
    "name": "getSortedIndexFromStr",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#getSortedIndexFromStr",
    "access": "public",
    "description": "Returns the index of the given temporal granule string/number. \nThe index is the value associated with  the given key.",
    "lineNumber": 317,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the given temporal granule string/number. "
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sortedTemporalGranule",
        "description": "The temporal granule string/number."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the given temporal granule string/number."
    }
  },
  {
    "__docId__": 967,
    "kind": "method",
    "name": "findNextTGIndex",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#findNextTGIndex",
    "access": "public",
    "description": "Returns the index of the next temporal granule on the \"timeline\".",
    "lineNumber": 327,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the next temporal granule on the \"timeline\"."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "currentTG",
        "description": "The current temporal granule."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the next temporal granule on the \"timeline\"."
    }
  },
  {
    "__docId__": 968,
    "kind": "method",
    "name": "findPreviousTGIndex",
    "memberof": "src/Gisplay/VVs/TimeVariable.js~TimeVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/TimeVariable.js~TimeVariable#findPreviousTGIndex",
    "access": "public",
    "description": "Returns the index of the previous temporal granule on the \"timeline\".",
    "lineNumber": 339,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the index of the previous temporal granule on the \"timeline\"."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "currentTG",
        "description": "The current temporal granule."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the index of the previous temporal granule on the \"timeline\"."
    }
  },
  {
    "__docId__": 969,
    "kind": "file",
    "name": "src/Gisplay/VVs/URLVariable.js",
    "content": "\r\n/**\r\n * Represents the url variable that is given by the programmer in the parsing options.\r\n * @export\r\n * @class URLVariable\r\n */\r\nexport class URLVariable {\r\n    /**\r\n     * Creates an instance of URLVariable.\r\n     * @param {File|string} dataURL - URL of the data to read.  \r\n     * @param {File|string} geoSpatialURL - URL of the geometry and identifiers to read.\r\n     * @param {string} idOnDataURL - The id of the geometry in the data URL.\r\n     * @param {string} idOnGeoSpatialURL - The id of the geometry in the geospatial URL.\r\n     * @memberof URLVariable\r\n     */\r\n    constructor(dataURL, geoSpatialURL, idOnDataURL, idOnGeoSpatialURL) {\r\n        /**\r\n         * The data url file handler.\r\n         * @type {File}\r\n         */\r\n        this.dataURL = dataURL;\r\n        /**\r\n         * The geospatial url file handler.\r\n         * @type {File}\r\n         */\r\n        this.geoSpatialURL = geoSpatialURL;\r\n        /**\r\n         * The id of the geometry on the data url.\r\n         * @type {string}\r\n         */\r\n        this.idOnDataURL = idOnDataURL;\r\n        /**\r\n         * The id of the geometry on the geospatial url. \r\n         * @type {string}\r\n         */\r\n        this.idOnGeoSpatialURL = idOnGeoSpatialURL;\r\n    }\r\n\r\n    /**\r\n     * Returns the data URL.\r\n     * @returns {File} - The data file (URL) or a URL from the web.\r\n     * @memberof URLVariable\r\n     */\r\n    getDataFile() {\r\n        return this.dataURL;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the data file.\r\n     * @returns {string} - the name of the data file.\r\n     * @memberof URLVariable\r\n     */\r\n    getDataFileName() {\r\n        return this.dataURL.name;\r\n    }\r\n\r\n    /**\r\n     * Returns the size in bytes of the data file.\r\n     * @returns {number} - the size in bytes of the data file.\r\n     * @memberof URLVariable\r\n     */\r\n    getDataFileSize() {\r\n        return this.dataURL.size;\r\n    }\r\n\r\n    /**\r\n     * Returns the geoSpatial URL.\r\n     * @returns {File|string} - The geospatial file (URL) or a URL from the web.\r\n     * @memberof URLVariable\r\n     */\r\n    getGeoSpatialURL() {\r\n        return this.geoSpatialURL;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the geospatial file.\r\n     * @returns {string} - the name of the geospatial file.\r\n     * @memberof URLVariable\r\n     */\r\n    getGeospatialName() {\r\n        return this.geoSpatialURL.name;\r\n    }\r\n\r\n    /**\r\n     * Returns the size in bytes of the geospatial file.\r\n     * @returns {number} - the size in bytes of the geospatial file.\r\n     * @memberof URLVariable\r\n     */\r\n    getGeospatialSize() {\r\n        return this.geoSpatialURL.size;\r\n    }\r\n\r\n    /**\r\n     * Returns the id of the geometry in the data URL.\r\n     * @returns {string} - the id of the geometry in the data URL.\r\n     * @memberof URLVariable\r\n     */\r\n    getIdOnDataURL() {\r\n        return this.idOnDataURL;\r\n    }\r\n\r\n    /**\r\n     * Returns the id of the geometry in the geospatial URL.\r\n     * @returns {string} - the id of the geometry in the geospatial URL.\r\n     * @memberof URLVariable\r\n     */\r\n    getIdOnGeoSpatialURL() {\r\n        return this.idOnGeoSpatialURL;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the data file is a geojson file. \r\n     * @returns {boolean} - true, if the data file is a geojson file, false, otherwise.\r\n     * @memberof URLVariable\r\n     */\r\n    dataFileIsGeoJSON() {\r\n        return this._isGeoJSON(this.getDataFileName());\r\n    }\r\n\r\n    /**\r\n     * Verifies if the given name is a GeoJSON file.\r\n     * @param {string} name - The name of the file. \r\n     * @returns {boolean} - true, if it's a geojson file, false, otherwise.\r\n     * @private\r\n     * @memberof URLVariable\r\n     */\r\n    _isGeoJSON(name) {\r\n        return name.endsWith('.json') || name.endsWith('.geojson');\r\n    }\r\n\r\n    /**\r\n     * Returns true, if both ids exist, false otherwise.\r\n     * @returns {boolean} - true, if both ids exist, false, otherwise.\r\n     * @memberof URLVariable\r\n     */\r\n    hasIds() {\r\n        return this.idOnDataURL !== undefined && this.idOnGeoSpatialURL !== undefined;\r\n    }\r\n}",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/Gisplay/VVs/URLVariable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 970,
    "kind": "class",
    "name": "URLVariable",
    "memberof": "src/Gisplay/VVs/URLVariable.js",
    "static": true,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "access": "public",
    "export": true,
    "importPath": "gisplay-es6-webpack/src/Gisplay/VVs/URLVariable.js",
    "importStyle": "{URLVariable}",
    "description": "Represents the url variable that is given by the programmer in the parsing options.",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "URLVariable"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 971,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#constructor",
    "access": "public",
    "description": "Creates an instance of URLVariable.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "File",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dataURL",
        "description": "URL of the data to read."
      },
      {
        "nullable": null,
        "types": [
          "File",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "geoSpatialURL",
        "description": "URL of the geometry and identifiers to read."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "idOnDataURL",
        "description": "The id of the geometry in the data URL."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "idOnGeoSpatialURL",
        "description": "The id of the geometry in the geospatial URL."
      }
    ]
  },
  {
    "__docId__": 972,
    "kind": "member",
    "name": "dataURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#dataURL",
    "access": "public",
    "description": "The data url file handler.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "File"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 973,
    "kind": "member",
    "name": "geoSpatialURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#geoSpatialURL",
    "access": "public",
    "description": "The geospatial url file handler.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "File"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 974,
    "kind": "member",
    "name": "idOnDataURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#idOnDataURL",
    "access": "public",
    "description": "The id of the geometry on the data url.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 975,
    "kind": "member",
    "name": "idOnGeoSpatialURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#idOnGeoSpatialURL",
    "access": "public",
    "description": "The id of the geometry on the geospatial url. ",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 976,
    "kind": "method",
    "name": "getDataFile",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getDataFile",
    "access": "public",
    "description": "Returns the data URL.",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{File} - The data file (URL) or a URL from the web."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "File"
      ],
      "spread": false,
      "description": "The data file (URL) or a URL from the web."
    }
  },
  {
    "__docId__": 977,
    "kind": "method",
    "name": "getDataFileName",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getDataFileName",
    "access": "public",
    "description": "Returns the name of the data file.",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the data file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the data file."
    }
  },
  {
    "__docId__": 978,
    "kind": "method",
    "name": "getDataFileSize",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getDataFileSize",
    "access": "public",
    "description": "Returns the size in bytes of the data file.",
    "lineNumber": 62,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size in bytes of the data file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size in bytes of the data file."
    }
  },
  {
    "__docId__": 979,
    "kind": "method",
    "name": "getGeoSpatialURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getGeoSpatialURL",
    "access": "public",
    "description": "Returns the geoSpatial URL.",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{File|string} - The geospatial file (URL) or a URL from the web."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "File",
        "string"
      ],
      "spread": false,
      "description": "The geospatial file (URL) or a URL from the web."
    }
  },
  {
    "__docId__": 980,
    "kind": "method",
    "name": "getGeospatialName",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getGeospatialName",
    "access": "public",
    "description": "Returns the name of the geospatial file.",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the name of the geospatial file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the name of the geospatial file."
    }
  },
  {
    "__docId__": 981,
    "kind": "method",
    "name": "getGeospatialSize",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getGeospatialSize",
    "access": "public",
    "description": "Returns the size in bytes of the geospatial file.",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - the size in bytes of the geospatial file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the size in bytes of the geospatial file."
    }
  },
  {
    "__docId__": 982,
    "kind": "method",
    "name": "getIdOnDataURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getIdOnDataURL",
    "access": "public",
    "description": "Returns the id of the geometry in the data URL.",
    "lineNumber": 98,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the id of the geometry in the data URL."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the id of the geometry in the data URL."
    }
  },
  {
    "__docId__": 983,
    "kind": "method",
    "name": "getIdOnGeoSpatialURL",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#getIdOnGeoSpatialURL",
    "access": "public",
    "description": "Returns the id of the geometry in the geospatial URL.",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - the id of the geometry in the geospatial URL."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the id of the geometry in the geospatial URL."
    }
  },
  {
    "__docId__": 984,
    "kind": "method",
    "name": "dataFileIsGeoJSON",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#dataFileIsGeoJSON",
    "access": "public",
    "description": "Returns true if the data file is a geojson file. ",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if the data file is a geojson file, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if the data file is a geojson file, false, otherwise."
    }
  },
  {
    "__docId__": 985,
    "kind": "method",
    "name": "_isGeoJSON",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#_isGeoJSON",
    "access": "private",
    "description": "Verifies if the given name is a GeoJSON file.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if it's a geojson file, false, otherwise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if it's a geojson file, false, otherwise."
    }
  },
  {
    "__docId__": 986,
    "kind": "method",
    "name": "hasIds",
    "memberof": "src/Gisplay/VVs/URLVariable.js~URLVariable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Gisplay/VVs/URLVariable.js~URLVariable#hasIds",
    "access": "public",
    "description": "Returns true, if both ids exist, false otherwise.",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - true, if both ids exist, false, otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, if both ids exist, false, otherwise."
    }
  },
  {
    "__docId__": 987,
    "kind": "file",
    "name": "src/lib/earcut.js",
    "content": "'use strict';\r\n\r\nmodule.exports = earcut;\r\n\r\nfunction earcut(data, holeIndices, dim) {\r\n\r\n    dim = dim || 2;\r\n\r\n    var hasHoles = holeIndices && holeIndices.length,\r\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\r\n        outerNode = linkedList(data, 0, outerLen, dim, true),\r\n        triangles = [];\r\n\r\n    if (!outerNode) return triangles;\r\n\r\n    var minX, minY, maxX, maxY, x, y, size;\r\n\r\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\r\n\r\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n    if (data.length > 80 * dim) {\r\n        minX = maxX = data[0];\r\n        minY = maxY = data[1];\r\n\r\n        for (var i = dim; i < outerLen; i += dim) {\r\n            x = data[i];\r\n            y = data[i + 1];\r\n            if (x < minX) minX = x;\r\n            if (y < minY) minY = y;\r\n            if (x > maxX) maxX = x;\r\n            if (y > maxY) maxY = y;\r\n        }\r\n\r\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\r\n        size = Math.max(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\r\n\r\n    return triangles;\r\n}\r\n\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\nfunction linkedList(data, start, end, dim, clockwise) {\r\n    var i, last;\r\n\r\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\r\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\r\n    } else {\r\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\r\n    }\r\n\r\n    if (last && equals(last, last.next)) {\r\n        removeNode(last);\r\n        last = last.next;\r\n    }\r\n\r\n    return last;\r\n}\r\n\r\n// eliminate colinear or duplicate points\r\nfunction filterPoints(start, end) {\r\n    if (!start) return start;\r\n    if (!end) end = start;\r\n\r\n    var p = start,\r\n        again;\r\n    do {\r\n        again = false;\r\n\r\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\r\n            removeNode(p);\r\n            p = end = p.prev;\r\n            if (p === p.next) return null;\r\n            again = true;\r\n\r\n        } else {\r\n            p = p.next;\r\n        }\r\n    } while (again || p !== end);\r\n\r\n    return end;\r\n}\r\n\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\r\n    if (!ear) return;\r\n\r\n    // interlink polygon nodes in z-order\r\n    if (!pass && size) indexCurve(ear, minX, minY, size);\r\n\r\n    var stop = ear,\r\n        prev, next;\r\n\r\n    // iterate through ears, slicing them one by one\r\n    while (ear.prev !== ear.next) {\r\n        prev = ear.prev;\r\n        next = ear.next;\r\n\r\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\r\n            // cut off the triangle\r\n            triangles.push(prev.i / dim);\r\n            triangles.push(ear.i / dim);\r\n            triangles.push(next.i / dim);\r\n\r\n            removeNode(ear);\r\n\r\n            // skipping the next vertice leads to less sliver triangles\r\n            ear = next.next;\r\n            stop = next.next;\r\n\r\n            continue;\r\n        }\r\n\r\n        ear = next;\r\n\r\n        // if we looped through the whole remaining polygon and can't find any more ears\r\n        if (ear === stop) {\r\n            // try filtering points and slicing again\r\n            if (!pass) {\r\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\r\n\r\n            // if this didn't work, try curing all small self-intersections locally\r\n            } else if (pass === 1) {\r\n                ear = cureLocalIntersections(ear, triangles, dim);\r\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\r\n\r\n            // as a last resort, try splitting the remaining polygon into two\r\n            } else if (pass === 2) {\r\n                splitEarcut(ear, triangles, dim, minX, minY, size);\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\nfunction isEar(ear) {\r\n    var a = ear.prev,\r\n        b = ear,\r\n        c = ear.next;\r\n\r\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\r\n\r\n    // now make sure we don't have other points inside the potential ear\r\n    var p = ear.next.next;\r\n\r\n    while (p !== ear.prev) {\r\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0) return false;\r\n        p = p.next;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isEarHashed(ear, minX, minY, size) {\r\n    var a = ear.prev,\r\n        b = ear,\r\n        c = ear.next;\r\n\r\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\r\n\r\n    // triangle bbox; min & max are calculated like this for speed\r\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\r\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\r\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\r\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\r\n\r\n    // z-order range for the current triangle bbox;\r\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\r\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\r\n\r\n    // first look for points inside the triangle in increasing z-order\r\n    var p = ear.nextZ;\r\n\r\n    while (p && p.z <= maxZ) {\r\n        if (p !== ear.prev && p !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0) return false;\r\n        p = p.nextZ;\r\n    }\r\n\r\n    // then look for points in decreasing z-order\r\n    p = ear.prevZ;\r\n\r\n    while (p && p.z >= minZ) {\r\n        if (p !== ear.prev && p !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0) return false;\r\n        p = p.prevZ;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// go through all polygon nodes and cure small local self-intersections\r\nfunction cureLocalIntersections(start, triangles, dim) {\r\n    var p = start;\r\n    do {\r\n        var a = p.prev,\r\n            b = p.next.next;\r\n\r\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\r\n\r\n            triangles.push(a.i / dim);\r\n            triangles.push(p.i / dim);\r\n            triangles.push(b.i / dim);\r\n\r\n            // remove two nodes involved\r\n            removeNode(p);\r\n            removeNode(p.next);\r\n\r\n            p = start = b;\r\n        }\r\n        p = p.next;\r\n    } while (p !== start);\r\n\r\n    return p;\r\n}\r\n\r\n// try splitting polygon into two and triangulate them independently\r\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\r\n    // look for a valid diagonal that divides the polygon into two\r\n    var a = start;\r\n    do {\r\n        var b = a.next.next;\r\n        while (b !== a.prev) {\r\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\r\n                // split the polygon in two by the diagonal\r\n                var c = splitPolygon(a, b);\r\n\r\n                // filter colinear points around the cuts\r\n                a = filterPoints(a, a.next);\r\n                c = filterPoints(c, c.next);\r\n\r\n                // run earcut on each half\r\n                earcutLinked(a, triangles, dim, minX, minY, size);\r\n                earcutLinked(c, triangles, dim, minX, minY, size);\r\n                return;\r\n            }\r\n            b = b.next;\r\n        }\r\n        a = a.next;\r\n    } while (a !== start);\r\n}\r\n\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\r\n    var queue = [],\r\n        i, len, start, end, list;\r\n\r\n    for (i = 0, len = holeIndices.length; i < len; i++) {\r\n        start = holeIndices[i] * dim;\r\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\r\n        list = linkedList(data, start, end, dim, false);\r\n        if (list === list.next) list.steiner = true;\r\n        queue.push(getLeftmost(list));\r\n    }\r\n\r\n    queue.sort(compareX);\r\n\r\n    // process holes from left to right\r\n    for (i = 0; i < queue.length; i++) {\r\n        eliminateHole(queue[i], outerNode);\r\n        outerNode = filterPoints(outerNode, outerNode.next);\r\n    }\r\n\r\n    return outerNode;\r\n}\r\n\r\nfunction compareX(a, b) {\r\n    return a.x - b.x;\r\n}\r\n\r\n// find a bridge between vertices that connects hole with an outer ring and and link it\r\nfunction eliminateHole(hole, outerNode) {\r\n    outerNode = findHoleBridge(hole, outerNode);\r\n    if (outerNode) {\r\n        var b = splitPolygon(outerNode, hole);\r\n        filterPoints(b, b.next);\r\n    }\r\n}\r\n\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\nfunction findHoleBridge(hole, outerNode) {\r\n    var p = outerNode,\r\n        hx = hole.x,\r\n        hy = hole.y,\r\n        qx = -Infinity,\r\n        m;\r\n\r\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\r\n    // segment's endpoint with lesser x will be potential connection point\r\n    do {\r\n        if (hy <= p.y && hy >= p.next.y) {\r\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\r\n            if (x <= hx && x > qx) {\r\n                qx = x;\r\n                if (x === hx) {\r\n                    if (hy === p.y) return p;\r\n                    if (hy === p.next.y) return p.next;\r\n                }\r\n                m = p.x < p.next.x ? p : p.next;\r\n            }\r\n        }\r\n        p = p.next;\r\n    } while (p !== outerNode);\r\n\r\n    if (!m) return null;\r\n\r\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\r\n\r\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\r\n    // if there are no points found, we have a valid connection;\r\n    // otherwise choose the point of the minimum angle with the ray as connection point\r\n\r\n    var stop = m,\r\n        mx = m.x,\r\n        my = m.y,\r\n        tanMin = Infinity,\r\n        tan;\r\n\r\n    p = m.next;\r\n\r\n    while (p !== stop) {\r\n        if (hx >= p.x && p.x >= mx &&\r\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\r\n\r\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\r\n\r\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\r\n                m = p;\r\n                tanMin = tan;\r\n            }\r\n        }\r\n\r\n        p = p.next;\r\n    }\r\n\r\n    return m;\r\n}\r\n\r\n// interlink polygon nodes in z-order\r\nfunction indexCurve(start, minX, minY, size) {\r\n    var p = start;\r\n    do {\r\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\r\n        p.prevZ = p.prev;\r\n        p.nextZ = p.next;\r\n        p = p.next;\r\n    } while (p !== start);\r\n\r\n    p.prevZ.nextZ = null;\r\n    p.prevZ = null;\r\n\r\n    sortLinked(p);\r\n}\r\n\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\nfunction sortLinked(list) {\r\n    var i, p, q, e, tail, numMerges, pSize, qSize,\r\n        inSize = 1;\r\n\r\n    do {\r\n        p = list;\r\n        list = null;\r\n        tail = null;\r\n        numMerges = 0;\r\n\r\n        while (p) {\r\n            numMerges++;\r\n            q = p;\r\n            pSize = 0;\r\n            for (i = 0; i < inSize; i++) {\r\n                pSize++;\r\n                q = q.nextZ;\r\n                if (!q) break;\r\n            }\r\n\r\n            qSize = inSize;\r\n\r\n            while (pSize > 0 || (qSize > 0 && q)) {\r\n\r\n                if (pSize === 0) {\r\n                    e = q;\r\n                    q = q.nextZ;\r\n                    qSize--;\r\n                } else if (qSize === 0 || !q) {\r\n                    e = p;\r\n                    p = p.nextZ;\r\n                    pSize--;\r\n                } else if (p.z <= q.z) {\r\n                    e = p;\r\n                    p = p.nextZ;\r\n                    pSize--;\r\n                } else {\r\n                    e = q;\r\n                    q = q.nextZ;\r\n                    qSize--;\r\n                }\r\n\r\n                if (tail) tail.nextZ = e;\r\n                else list = e;\r\n\r\n                e.prevZ = tail;\r\n                tail = e;\r\n            }\r\n\r\n            p = q;\r\n        }\r\n\r\n        tail.nextZ = null;\r\n        inSize *= 2;\r\n\r\n    } while (numMerges > 1);\r\n\r\n    return list;\r\n}\r\n\r\n// z-order of a point given coords and size of the data bounding box\r\nfunction zOrder(x, y, minX, minY, size) {\r\n    // coords are transformed into non-negative 15-bit integer range\r\n    x = 32767 * (x - minX) / size;\r\n    y = 32767 * (y - minY) / size;\r\n\r\n    x = (x | (x << 8)) & 0x00FF00FF;\r\n    x = (x | (x << 4)) & 0x0F0F0F0F;\r\n    x = (x | (x << 2)) & 0x33333333;\r\n    x = (x | (x << 1)) & 0x55555555;\r\n\r\n    y = (y | (y << 8)) & 0x00FF00FF;\r\n    y = (y | (y << 4)) & 0x0F0F0F0F;\r\n    y = (y | (y << 2)) & 0x33333333;\r\n    y = (y | (y << 1)) & 0x55555555;\r\n\r\n    return x | (y << 1);\r\n}\r\n\r\n// find the leftmost node of a polygon ring\r\nfunction getLeftmost(start) {\r\n    var p = start,\r\n        leftmost = start;\r\n    do {\r\n        if (p.x < leftmost.x) leftmost = p;\r\n        p = p.next;\r\n    } while (p !== start);\r\n\r\n    return leftmost;\r\n}\r\n\r\n// check if a point lies within a convex triangle\r\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\r\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\r\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\r\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\r\n}\r\n\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\nfunction isValidDiagonal(a, b) {\r\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\r\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\r\n}\r\n\r\n// signed area of a triangle\r\nfunction area(p, q, r) {\r\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\r\n}\r\n\r\n// check if two points are equal\r\nfunction equals(p1, p2) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n\r\n// check if two segments intersect\r\nfunction intersects(p1, q1, p2, q2) {\r\n    if ((equals(p1, q1) && equals(p2, q2)) ||\r\n        (equals(p1, q2) && equals(p2, q1))) return true;\r\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\r\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\r\n}\r\n\r\n// check if a polygon diagonal intersects any polygon segments\r\nfunction intersectsPolygon(a, b) {\r\n    var p = a;\r\n    do {\r\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n                intersects(p, p.next, a, b)) return true;\r\n        p = p.next;\r\n    } while (p !== a);\r\n\r\n    return false;\r\n}\r\n\r\n// check if a polygon diagonal is locally inside the polygon\r\nfunction locallyInside(a, b) {\r\n    return area(a.prev, a, a.next) < 0 ?\r\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\r\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\r\n}\r\n\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\nfunction middleInside(a, b) {\r\n    var p = a,\r\n        inside = false,\r\n        px = (a.x + b.x) / 2,\r\n        py = (a.y + b.y) / 2;\r\n    do {\r\n        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\r\n            inside = !inside;\r\n        p = p.next;\r\n    } while (p !== a);\r\n\r\n    return inside;\r\n}\r\n\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\nfunction splitPolygon(a, b) {\r\n    var a2 = new Node(a.i, a.x, a.y),\r\n        b2 = new Node(b.i, b.x, b.y),\r\n        an = a.next,\r\n        bp = b.prev;\r\n\r\n    a.next = b;\r\n    b.prev = a;\r\n\r\n    a2.next = an;\r\n    an.prev = a2;\r\n\r\n    b2.next = a2;\r\n    a2.prev = b2;\r\n\r\n    bp.next = b2;\r\n    b2.prev = bp;\r\n\r\n    return b2;\r\n}\r\n\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\nfunction insertNode(i, x, y, last) {\r\n    var p = new Node(i, x, y);\r\n\r\n    if (!last) {\r\n        p.prev = p;\r\n        p.next = p;\r\n\r\n    } else {\r\n        p.next = last.next;\r\n        p.prev = last;\r\n        last.next.prev = p;\r\n        last.next = p;\r\n    }\r\n    return p;\r\n}\r\n\r\nfunction removeNode(p) {\r\n    p.next.prev = p.prev;\r\n    p.prev.next = p.next;\r\n\r\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\r\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\r\n}\r\n\r\nfunction Node(i, x, y) {\r\n    // vertice index in coordinates array\r\n    this.i = i;\r\n\r\n    // vertex coordinates\r\n    this.x = x;\r\n    this.y = y;\r\n\r\n    // previous and next vertice nodes in a polygon ring\r\n    this.prev = null;\r\n    this.next = null;\r\n\r\n    // z-order curve value\r\n    this.z = null;\r\n\r\n    // previous and next nodes in z-order\r\n    this.prevZ = null;\r\n    this.nextZ = null;\r\n\r\n    // indicates whether this is a steiner point\r\n    this.steiner = false;\r\n}\r\n\r\n// return a percentage difference between the polygon area and its triangulation area;\r\n// used to verify correctness of triangulation\r\nearcut.deviation = function (data, holeIndices, dim, triangles) {\r\n    var hasHoles = holeIndices && holeIndices.length;\r\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\r\n\r\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\r\n    if (hasHoles) {\r\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\r\n            var start = holeIndices[i] * dim;\r\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\r\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\r\n        }\r\n    }\r\n\r\n    var trianglesArea = 0;\r\n    for (i = 0; i < triangles.length; i += 3) {\r\n        var a = triangles[i] * dim;\r\n        var b = triangles[i + 1] * dim;\r\n        var c = triangles[i + 2] * dim;\r\n        trianglesArea += Math.abs(\r\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\r\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\r\n    }\r\n\r\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\r\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\r\n};\r\n\r\nfunction signedArea(data, start, end, dim) {\r\n    var sum = 0;\r\n    for (var i = start, j = end - dim; i < end; i += dim) {\r\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\r\n        j = i;\r\n    }\r\n    return sum;\r\n}\r\n\r\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\r\nearcut.flatten = function (data) {\r\n    var dim = data[0][0].length,\r\n        result = {vertices: [], holes: [], dimensions: dim},\r\n        holeIndex = 0;\r\n\r\n    for (var i = 0; i < data.length; i++) {\r\n        for (var j = 0; j < data[i].length; j++) {\r\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\r\n        }\r\n        if (i > 0) {\r\n            holeIndex += data[i - 1].length;\r\n            result.holes.push(holeIndex);\r\n        }\r\n    }\r\n    return result;\r\n};",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/lib/earcut.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 988,
    "kind": "function",
    "name": "earcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcut",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 989,
    "kind": "function",
    "name": "linkedList",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~linkedList",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 990,
    "kind": "function",
    "name": "filterPoints",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~filterPoints",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 991,
    "kind": "function",
    "name": "earcutLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcutLinked",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 992,
    "kind": "function",
    "name": "isEar",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEar",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 993,
    "kind": "function",
    "name": "isEarHashed",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEarHashed",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 994,
    "kind": "function",
    "name": "cureLocalIntersections",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~cureLocalIntersections",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 995,
    "kind": "function",
    "name": "splitEarcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitEarcut",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 996,
    "kind": "function",
    "name": "eliminateHoles",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHoles",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 997,
    "kind": "function",
    "name": "compareX",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~compareX",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 273,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 998,
    "kind": "function",
    "name": "eliminateHole",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHole",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 999,
    "kind": "function",
    "name": "findHoleBridge",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~findHoleBridge",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 287,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1000,
    "kind": "function",
    "name": "indexCurve",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~indexCurve",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1001,
    "kind": "function",
    "name": "sortLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sortLinked",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 363,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1002,
    "kind": "function",
    "name": "zOrder",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~zOrder",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 424,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1003,
    "kind": "function",
    "name": "getLeftmost",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~getLeftmost",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1004,
    "kind": "function",
    "name": "pointInTriangle",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~pointInTriangle",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1005,
    "kind": "function",
    "name": "isValidDiagonal",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isValidDiagonal",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 462,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1006,
    "kind": "function",
    "name": "area",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~area",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 468,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1007,
    "kind": "function",
    "name": "equals",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~equals",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 473,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1008,
    "kind": "function",
    "name": "intersects",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersects",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 478,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1009,
    "kind": "function",
    "name": "intersectsPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersectsPolygon",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 486,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1010,
    "kind": "function",
    "name": "locallyInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~locallyInside",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 498,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1011,
    "kind": "function",
    "name": "middleInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~middleInside",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 505,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1012,
    "kind": "function",
    "name": "splitPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitPolygon",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 521,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1013,
    "kind": "function",
    "name": "insertNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~insertNode",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1014,
    "kind": "function",
    "name": "removeNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~removeNode",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 559,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1015,
    "kind": "function",
    "name": "Node",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~Node",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 567,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1016,
    "kind": "function",
    "name": "deviation",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~deviation",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 592,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1017,
    "kind": "function",
    "name": "signedArea",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~signedArea",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 619,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1018,
    "kind": "function",
    "name": "flatten",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~flatten",
    "access": "public",
    "export": false,
    "importPath": "gisplay-es6-webpack/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 629,
    "undocument": true,
    "ignore": true
  },
  {
    "__docId__": 1019,
    "kind": "file",
    "name": "src/lib/noUiSlider/nouislider.js",
    "content": "/*! nouislider - 10.1.0 - 2017-07-28 13:09:54 */\r\n\r\n(function (factory) {\r\n    \r\n        if ( typeof define === 'function' && define.amd ) {\r\n    \r\n            // AMD. Register as an anonymous module.\r\n            define([], factory);\r\n    \r\n        } else if ( typeof exports === 'object' ) {\r\n    \r\n            // Node/CommonJS\r\n            module.exports = factory();\r\n    \r\n        } else {\r\n    \r\n            // Browser globals\r\n            window.noUiSlider = factory();\r\n        }\r\n    \r\n    }(function( ){\r\n    \r\n        'use strict';\r\n    \r\n        var VERSION = '10.1.0';\r\n    \r\n    \r\n        function isValidFormatter ( entry ) {\r\n            return typeof entry === 'object' && typeof entry.to === 'function' && typeof entry.from === 'function';\r\n        }\r\n    \r\n        function removeElement ( el ) {\r\n            el.parentElement.removeChild(el);\r\n        }\r\n    \r\n        // Bindable version\r\n        function preventDefault ( e ) {\r\n            e.preventDefault();\r\n        }\r\n    \r\n        // Removes duplicates from an array.\r\n        function unique ( array ) {\r\n            return array.filter(function(a){\r\n                return !this[a] ? this[a] = true : false;\r\n            }, {});\r\n        }\r\n    \r\n        // Round a value to the closest 'to'.\r\n        function closest ( value, to ) {\r\n            return Math.round(value / to) * to;\r\n        }\r\n    \r\n        // Current position of an element relative to the document.\r\n        function offset ( elem, orientation ) {\r\n    \r\n            var rect = elem.getBoundingClientRect();\r\n            var doc = elem.ownerDocument;\r\n            var docElem = doc.documentElement;\r\n            var pageOffset = getPageOffset(doc);\r\n    \r\n            // getBoundingClientRect contains left scroll in Chrome on Android.\r\n            // I haven't found a feature detection that proves this. Worst case\r\n            // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\r\n            if ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\r\n                pageOffset.x = 0;\r\n            }\r\n    \r\n            return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);\r\n        }\r\n    \r\n        // Checks whether a value is numerical.\r\n        function isNumeric ( a ) {\r\n            return typeof a === 'number' && !isNaN( a ) && isFinite( a );\r\n        }\r\n    \r\n        // Sets a class and removes it after [duration] ms.\r\n        function addClassFor ( element, className, duration ) {\r\n            if (duration > 0) {\r\n            addClass(element, className);\r\n                setTimeout(function(){\r\n                    removeClass(element, className);\r\n                }, duration);\r\n            }\r\n        }\r\n    \r\n        // Limits a value to 0 - 100\r\n        function limit ( a ) {\r\n            return Math.max(Math.min(a, 100), 0);\r\n        }\r\n    \r\n        // Wraps a variable as an array, if it isn't one yet.\r\n        // Note that an input array is returned by reference!\r\n        function asArray ( a ) {\r\n            return Array.isArray(a) ? a : [a];\r\n        }\r\n    \r\n        // Counts decimals\r\n        function countDecimals ( numStr ) {\r\n            numStr = String(numStr);\r\n            var pieces = numStr.split(\".\");\r\n            return pieces.length > 1 ? pieces[1].length : 0;\r\n        }\r\n    \r\n        // http://youmightnotneedjquery.com/#add_class\r\n        function addClass ( el, className ) {\r\n            if ( el.classList ) {\r\n                el.classList.add(className);\r\n            } else {\r\n                el.className += ' ' + className;\r\n            }\r\n        }\r\n    \r\n        // http://youmightnotneedjquery.com/#remove_class\r\n        function removeClass ( el, className ) {\r\n            if ( el.classList ) {\r\n                el.classList.remove(className);\r\n            } else {\r\n                el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n            }\r\n        }\r\n    \r\n        // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\r\n        function hasClass ( el, className ) {\r\n            return el.classList ? el.classList.contains(className) : new RegExp('\\\\b' + className + '\\\\b').test(el.className);\r\n        }\r\n    \r\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n        function getPageOffset ( doc ) {\r\n    \r\n            var supportPageOffset = window.pageXOffset !== undefined;\r\n            var isCSS1Compat = ((doc.compatMode || \"\") === \"CSS1Compat\");\r\n            var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;\r\n            var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;\r\n    \r\n            return {\r\n                x: x,\r\n                y: y\r\n            };\r\n        }\r\n    \r\n        // we provide a function to compute constants instead\r\n        // of accessing window.* as soon as the module needs it\r\n        // so that we do not compute anything if not needed\r\n        function getActions ( ) {\r\n    \r\n            // Determine the events to bind. IE11 implements pointerEvents without\r\n            // a prefix, which breaks compatibility with the IE10 implementation.\r\n            return window.navigator.pointerEnabled ? {\r\n                start: 'pointerdown',\r\n                move: 'pointermove',\r\n                end: 'pointerup'\r\n            } : window.navigator.msPointerEnabled ? {\r\n                start: 'MSPointerDown',\r\n                move: 'MSPointerMove',\r\n                end: 'MSPointerUp'\r\n            } : {\r\n                start: 'mousedown touchstart',\r\n                move: 'mousemove touchmove',\r\n                end: 'mouseup touchend'\r\n            };\r\n        }\r\n    \r\n        // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n        // Issue #785\r\n        function getSupportsPassive ( ) {\r\n    \r\n            var supportsPassive = false;\r\n    \r\n            try {\r\n    \r\n                var opts = Object.defineProperty({}, 'passive', {\r\n                    get: function() {\r\n                        supportsPassive = true;\r\n                    }\r\n                });\r\n    \r\n                window.addEventListener('test', null, opts);\r\n    \r\n            } catch (e) {}\r\n    \r\n            return supportsPassive;\r\n        }\r\n    \r\n        function getSupportsTouchActionNone ( ) {\r\n            return window.CSS && CSS.supports && CSS.supports('touch-action', 'none');\r\n        }\r\n    \r\n    \r\n    // Value calculation\r\n    \r\n        // Determine the size of a sub-range in relation to a full range.\r\n        function subRangeRatio ( pa, pb ) {\r\n            return (100 / (pb - pa));\r\n        }\r\n    \r\n        // (percentage) How many percent is this value of this range?\r\n        function fromPercentage ( range, value ) {\r\n            return (value * 100) / ( range[1] - range[0] );\r\n        }\r\n    \r\n        // (percentage) Where is this value on this range?\r\n        function toPercentage ( range, value ) {\r\n            return fromPercentage( range, range[0] < 0 ?\r\n                value + Math.abs(range[0]) :\r\n                    value - range[0] );\r\n        }\r\n    \r\n        // (value) How much is this percentage on this range?\r\n        function isPercentage ( range, value ) {\r\n            return ((value * ( range[1] - range[0] )) / 100) + range[0];\r\n        }\r\n    \r\n    \r\n    // Range conversion\r\n    \r\n        function getJ ( value, arr ) {\r\n    \r\n            var j = 1;\r\n    \r\n            while ( value >= arr[j] ){\r\n                j += 1;\r\n            }\r\n    \r\n            return j;\r\n        }\r\n    \r\n        // (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n        function toStepping ( xVal, xPct, value ) {\r\n    \r\n            if ( value >= xVal.slice(-1)[0] ){\r\n                return 100;\r\n            }\r\n    \r\n            var j = getJ( value, xVal ), va, vb, pa, pb;\r\n    \r\n            va = xVal[j-1];\r\n            vb = xVal[j];\r\n            pa = xPct[j-1];\r\n            pb = xPct[j];\r\n    \r\n            return pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));\r\n        }\r\n    \r\n        // (value) Input a percentage, find where it is on the specified range.\r\n        function fromStepping ( xVal, xPct, value ) {\r\n    \r\n            // There is no range group that fits 100\r\n            if ( value >= 100 ){\r\n                return xVal.slice(-1)[0];\r\n            }\r\n    \r\n            var j = getJ( value, xPct ), va, vb, pa, pb;\r\n    \r\n            va = xVal[j-1];\r\n            vb = xVal[j];\r\n            pa = xPct[j-1];\r\n            pb = xPct[j];\r\n    \r\n            return isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));\r\n        }\r\n    \r\n        // (percentage) Get the step that applies at a certain value.\r\n        function getStep ( xPct, xSteps, snap, value ) {\r\n    \r\n            if ( value === 100 ) {\r\n                return value;\r\n            }\r\n    \r\n            var j = getJ( value, xPct ), a, b;\r\n    \r\n            // If 'snap' is set, steps are used as fixed points on the slider.\r\n            if ( snap ) {\r\n    \r\n                a = xPct[j-1];\r\n                b = xPct[j];\r\n    \r\n                // Find the closest position, a or b.\r\n                if ((value - a) > ((b-a)/2)){\r\n                    return b;\r\n                }\r\n    \r\n                return a;\r\n            }\r\n    \r\n            if ( !xSteps[j-1] ){\r\n                return value;\r\n            }\r\n    \r\n            return xPct[j-1] + closest(\r\n                value - xPct[j-1],\r\n                xSteps[j-1]\r\n            );\r\n        }\r\n    \r\n    \r\n    // Entry parsing\r\n    \r\n        function handleEntryPoint ( index, value, that ) {\r\n    \r\n            var percentage;\r\n    \r\n            // Wrap numerical input in an array.\r\n            if ( typeof value === \"number\" ) {\r\n                value = [value];\r\n            }\r\n    \r\n            // Reject any invalid input, by testing whether value is an array.\r\n            if ( Object.prototype.toString.call( value ) !== '[object Array]' ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' contains invalid value.\");\r\n            }\r\n    \r\n            // Covert min/max syntax to 0 and 100.\r\n            if ( index === 'min' ) {\r\n                percentage = 0;\r\n            } else if ( index === 'max' ) {\r\n                percentage = 100;\r\n            } else {\r\n                percentage = parseFloat( index );\r\n            }\r\n    \r\n            // Check for correct input.\r\n            if ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' value isn't numeric.\");\r\n            }\r\n    \r\n            // Store values.\r\n            that.xPct.push( percentage );\r\n            that.xVal.push( value[0] );\r\n    \r\n            // NaN will evaluate to false too, but to keep\r\n            // logging clear, set step explicitly. Make sure\r\n            // not to override the 'step' setting with false.\r\n            if ( !percentage ) {\r\n                if ( !isNaN( value[1] ) ) {\r\n                    that.xSteps[0] = value[1];\r\n                }\r\n            } else {\r\n                that.xSteps.push( isNaN(value[1]) ? false : value[1] );\r\n            }\r\n    \r\n            that.xHighestCompleteStep.push(0);\r\n        }\r\n    \r\n        function handleStepPoint ( i, n, that ) {\r\n    \r\n            // Ignore 'false' stepping.\r\n            if ( !n ) {\r\n                return true;\r\n            }\r\n    \r\n            // Factor to range ratio\r\n            that.xSteps[i] = fromPercentage([\r\n                 that.xVal[i]\r\n                ,that.xVal[i+1]\r\n            ], n) / subRangeRatio (\r\n                that.xPct[i],\r\n                that.xPct[i+1] );\r\n    \r\n            var totalSteps = (that.xVal[i+1] - that.xVal[i]) / that.xNumSteps[i];\r\n            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\r\n            var step = that.xVal[i] + (that.xNumSteps[i] * highestStep);\r\n    \r\n            that.xHighestCompleteStep[i] = step;\r\n        }\r\n    \r\n    \r\n    // Interface\r\n    \r\n        function Spectrum ( entry, snap, singleStep ) {\r\n    \r\n            this.xPct = [];\r\n            this.xVal = [];\r\n            this.xSteps = [ singleStep || false ];\r\n            this.xNumSteps = [ false ];\r\n            this.xHighestCompleteStep = [];\r\n    \r\n            this.snap = snap;\r\n    \r\n            var index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */ ];\r\n    \r\n            // Map the object keys to an array.\r\n            for ( index in entry ) {\r\n                if ( entry.hasOwnProperty(index) ) {\r\n                    ordered.push([entry[index], index]);\r\n                }\r\n            }\r\n    \r\n            // Sort all entries by value (numeric sort).\r\n            if ( ordered.length && typeof ordered[0][0] === \"object\" ) {\r\n                ordered.sort(function(a, b) { return a[0][0] - b[0][0]; });\r\n            } else {\r\n                ordered.sort(function(a, b) { return a[0] - b[0]; });\r\n            }\r\n    \r\n    \r\n            // Convert all entries to subranges.\r\n            for ( index = 0; index < ordered.length; index++ ) {\r\n                handleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n            }\r\n    \r\n            // Store the actual step values.\r\n            // xSteps is sorted in the same order as xPct and xVal.\r\n            this.xNumSteps = this.xSteps.slice(0);\r\n    \r\n            // Convert all numeric steps to the percentage of the subrange they represent.\r\n            for ( index = 0; index < this.xNumSteps.length; index++ ) {\r\n                handleStepPoint(index, this.xNumSteps[index], this);\r\n            }\r\n        }\r\n    \r\n        Spectrum.prototype.getMargin = function ( value ) {\r\n    \r\n            var step = this.xNumSteps[0];\r\n    \r\n            if ( step && ((value / step) % 1) !== 0 ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'limit', 'margin' and 'padding' must be divisible by step.\");\r\n            }\r\n    \r\n            return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n        };\r\n    \r\n        Spectrum.prototype.toStepping = function ( value ) {\r\n    \r\n            value = toStepping( this.xVal, this.xPct, value );\r\n    \r\n            return value;\r\n        };\r\n    \r\n        Spectrum.prototype.fromStepping = function ( value ) {\r\n    \r\n            return fromStepping( this.xVal, this.xPct, value );\r\n        };\r\n    \r\n        Spectrum.prototype.getStep = function ( value ) {\r\n    \r\n            value = getStep(this.xPct, this.xSteps, this.snap, value );\r\n    \r\n            return value;\r\n        };\r\n    \r\n        Spectrum.prototype.getNearbySteps = function ( value ) {\r\n    \r\n            var j = getJ(value, this.xPct);\r\n    \r\n            return {\r\n                stepBefore: { startValue: this.xVal[j-2], step: this.xNumSteps[j-2], highestStep: this.xHighestCompleteStep[j-2] },\r\n                thisStep: { startValue: this.xVal[j-1], step: this.xNumSteps[j-1], highestStep: this.xHighestCompleteStep[j-1] },\r\n                stepAfter: { startValue: this.xVal[j-0], step: this.xNumSteps[j-0], highestStep: this.xHighestCompleteStep[j-0] }\r\n            };\r\n        };\r\n    \r\n        Spectrum.prototype.countStepDecimals = function () {\r\n            var stepDecimals = this.xNumSteps.map(countDecimals);\r\n            return Math.max.apply(null, stepDecimals);\r\n         };\r\n    \r\n        // Outside testing\r\n        Spectrum.prototype.convert = function ( value ) {\r\n            return this.getStep(this.toStepping(value));\r\n        };\r\n    \r\n    /*\tEvery input option is tested and parsed. This'll prevent\r\n        endless validation in internal methods. These tests are\r\n        structured with an item for every option available. An\r\n        option can be marked as required by setting the 'r' flag.\r\n        The testing function is provided with three arguments:\r\n            - The provided value for the option;\r\n            - A reference to the options object;\r\n            - The name for the option;\r\n    \r\n        The testing function returns false when an error is detected,\r\n        or true when everything is OK. It can also modify the option\r\n        object, to make sure all values can be correctly looped elsewhere. */\r\n    \r\n        var defaultFormatter = { 'to': function( value ){\r\n            return value !== undefined && value.toFixed(2);\r\n        }, 'from': Number };\r\n    \r\n        function validateFormat ( entry ) {\r\n    \r\n            // Any object with a to and from method is supported.\r\n            if ( isValidFormatter(entry) ) {\r\n                return true;\r\n            }\r\n    \r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'format' requires 'to' and 'from' methods.\");\r\n        }\r\n    \r\n        function testStep ( parsed, entry ) {\r\n    \r\n            if ( !isNumeric( entry ) ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'step' is not numeric.\");\r\n            }\r\n    \r\n            // The step option can still be used to set stepping\r\n            // for linear sliders. Overwritten if set in 'range'.\r\n            parsed.singleStep = entry;\r\n        }\r\n    \r\n        function testRange ( parsed, entry ) {\r\n    \r\n            // Filter incorrect input.\r\n            if ( typeof entry !== 'object' || Array.isArray(entry) ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' is not an object.\");\r\n            }\r\n    \r\n            // Catch missing start or end.\r\n            if ( entry.min === undefined || entry.max === undefined ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): Missing 'min' or 'max' in 'range'.\");\r\n            }\r\n    \r\n            // Catch equal start or end.\r\n            if ( entry.min === entry.max ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' 'min' and 'max' cannot be equal.\");\r\n            }\r\n    \r\n            parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\r\n        }\r\n    \r\n        function testStart ( parsed, entry ) {\r\n    \r\n            entry = asArray(entry);\r\n    \r\n            // Validate input. Values aren't tested, as the public .val method\r\n            // will always provide a valid location.\r\n            if ( !Array.isArray( entry ) || !entry.length ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'start' option is incorrect.\");\r\n            }\r\n    \r\n            // Store the number of handles.\r\n            parsed.handles = entry.length;\r\n    \r\n            // When the slider is initialized, the .val method will\r\n            // be called with the start options.\r\n            parsed.start = entry;\r\n        }\r\n    \r\n        function testSnap ( parsed, entry ) {\r\n    \r\n            // Enforce 100% stepping within subranges.\r\n            parsed.snap = entry;\r\n    \r\n            if ( typeof entry !== 'boolean' ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'snap' option must be a boolean.\");\r\n            }\r\n        }\r\n    \r\n        function testAnimate ( parsed, entry ) {\r\n    \r\n            // Enforce 100% stepping within subranges.\r\n            parsed.animate = entry;\r\n    \r\n            if ( typeof entry !== 'boolean' ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'animate' option must be a boolean.\");\r\n            }\r\n        }\r\n    \r\n        function testAnimationDuration ( parsed, entry ) {\r\n    \r\n            parsed.animationDuration = entry;\r\n    \r\n            if ( typeof entry !== 'number' ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'animationDuration' option must be a number.\");\r\n            }\r\n        }\r\n    \r\n        function testConnect ( parsed, entry ) {\r\n    \r\n            var connect = [false];\r\n            var i;\r\n    \r\n            // Map legacy options\r\n            if ( entry === 'lower' ) {\r\n                entry = [true, false];\r\n            }\r\n    \r\n            else if ( entry === 'upper' ) {\r\n                entry = [false, true];\r\n            }\r\n    \r\n            // Handle boolean options\r\n            if ( entry === true || entry === false ) {\r\n    \r\n                for ( i = 1; i < parsed.handles; i++ ) {\r\n                    connect.push(entry);\r\n                }\r\n    \r\n                connect.push(false);\r\n            }\r\n    \r\n            // Reject invalid input\r\n            else if ( !Array.isArray( entry ) || !entry.length || entry.length !== parsed.handles + 1 ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'connect' option doesn't match handle count.\");\r\n            }\r\n    \r\n            else {\r\n                connect = entry;\r\n            }\r\n    \r\n            parsed.connect = connect;\r\n        }\r\n    \r\n        function testOrientation ( parsed, entry ) {\r\n    \r\n            // Set orientation to an a numerical value for easy\r\n            // array selection.\r\n            switch ( entry ){\r\n              case 'horizontal':\r\n                parsed.ort = 0;\r\n                break;\r\n              case 'vertical':\r\n                parsed.ort = 1;\r\n                break;\r\n              default:\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'orientation' option is invalid.\");\r\n            }\r\n        }\r\n    \r\n        function testMargin ( parsed, entry ) {\r\n    \r\n            if ( !isNumeric(entry) ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option must be numeric.\");\r\n            }\r\n    \r\n            // Issue #582\r\n            if ( entry === 0 ) {\r\n                return;\r\n            }\r\n    \r\n            parsed.margin = parsed.spectrum.getMargin(entry);\r\n    \r\n            if ( !parsed.margin ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option is only supported on linear sliders.\");\r\n            }\r\n        }\r\n    \r\n        function testLimit ( parsed, entry ) {\r\n    \r\n            if ( !isNumeric(entry) ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option must be numeric.\");\r\n            }\r\n    \r\n            parsed.limit = parsed.spectrum.getMargin(entry);\r\n    \r\n            if ( !parsed.limit || parsed.handles < 2 ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option is only supported on linear sliders with 2 or more handles.\");\r\n            }\r\n        }\r\n    \r\n        function testPadding ( parsed, entry ) {\r\n    \r\n            if ( !isNumeric(entry) ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric.\");\r\n            }\r\n    \r\n            if ( entry === 0 ) {\r\n                return;\r\n            }\r\n    \r\n            parsed.padding = parsed.spectrum.getMargin(entry);\r\n    \r\n            if ( !parsed.padding ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option is only supported on linear sliders.\");\r\n            }\r\n    \r\n            if ( parsed.padding < 0 ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be a positive number.\");\r\n            }\r\n    \r\n            if ( parsed.padding >= 50 ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be less than half the range.\");\r\n            }\r\n        }\r\n    \r\n        function testDirection ( parsed, entry ) {\r\n    \r\n            // Set direction as a numerical value for easy parsing.\r\n            // Invert connection for RTL sliders, so that the proper\r\n            // handles get the connect/background classes.\r\n            switch ( entry ) {\r\n              case 'ltr':\r\n                parsed.dir = 0;\r\n                break;\r\n              case 'rtl':\r\n                parsed.dir = 1;\r\n                break;\r\n              default:\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'direction' option was not recognized.\");\r\n            }\r\n        }\r\n    \r\n        function testBehaviour ( parsed, entry ) {\r\n    \r\n            // Make sure the input is a string.\r\n            if ( typeof entry !== 'string' ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'behaviour' must be a string containing options.\");\r\n            }\r\n    \r\n            // Check if the string contains any keywords.\r\n            // None are required.\r\n            var tap = entry.indexOf('tap') >= 0;\r\n            var drag = entry.indexOf('drag') >= 0;\r\n            var fixed = entry.indexOf('fixed') >= 0;\r\n            var snap = entry.indexOf('snap') >= 0;\r\n            var hover = entry.indexOf('hover') >= 0;\r\n    \r\n            if ( fixed ) {\r\n    \r\n                if ( parsed.handles !== 2 ) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): 'fixed' behaviour must be used with 2 handles\");\r\n                }\r\n    \r\n                // Use margin to enforce fixed state\r\n                testMargin(parsed, parsed.start[1] - parsed.start[0]);\r\n            }\r\n    \r\n            parsed.events = {\r\n                tap: tap || snap,\r\n                drag: drag,\r\n                fixed: fixed,\r\n                snap: snap,\r\n                hover: hover\r\n            };\r\n        }\r\n    \r\n        function testMultitouch ( parsed, entry ) {\r\n            parsed.multitouch = entry;\r\n    \r\n            if ( typeof entry !== 'boolean' ){\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'multitouch' option must be a boolean.\");\r\n            }\r\n        }\r\n    \r\n        function testTooltips ( parsed, entry ) {\r\n    \r\n            if ( entry === false ) {\r\n                return;\r\n            }\r\n    \r\n            else if ( entry === true ) {\r\n    \r\n                parsed.tooltips = [];\r\n    \r\n                for ( var i = 0; i < parsed.handles; i++ ) {\r\n                    parsed.tooltips.push(true);\r\n                }\r\n            }\r\n    \r\n            else {\r\n    \r\n                parsed.tooltips = asArray(entry);\r\n    \r\n                if ( parsed.tooltips.length !== parsed.handles ) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): must pass a formatter for all handles.\");\r\n                }\r\n    \r\n                parsed.tooltips.forEach(function(formatter){\r\n                    if ( typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function') ) {\r\n                        throw new Error(\"noUiSlider (\" + VERSION + \"): 'tooltips' must be passed a formatter or 'false'.\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    \r\n        function testAriaFormat ( parsed, entry ) {\r\n            parsed.ariaFormat = entry;\r\n            validateFormat(entry);\r\n        }\r\n    \r\n        function testFormat ( parsed, entry ) {\r\n            parsed.format = entry;\r\n            validateFormat(entry);\r\n        }\r\n    \r\n        function testCssPrefix ( parsed, entry ) {\r\n    \r\n            if ( entry !== undefined && typeof entry !== 'string' && entry !== false ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'cssPrefix' must be a string or `false`.\");\r\n            }\r\n    \r\n            parsed.cssPrefix = entry;\r\n        }\r\n    \r\n        function testCssClasses ( parsed, entry ) {\r\n    \r\n            if ( entry !== undefined && typeof entry !== 'object' ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'cssClasses' must be an object.\");\r\n            }\r\n    \r\n            if ( typeof parsed.cssPrefix === 'string' ) {\r\n                parsed.cssClasses = {};\r\n    \r\n                for ( var key in entry ) {\r\n                    if ( !entry.hasOwnProperty(key) ) { continue; }\r\n    \r\n                    parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\r\n                }\r\n            } else {\r\n                parsed.cssClasses = entry;\r\n            }\r\n        }\r\n    \r\n        function testUseRaf ( parsed, entry ) {\r\n            if ( entry === true || entry === false ) {\r\n                parsed.useRequestAnimationFrame = entry;\r\n            } else {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'useRequestAnimationFrame' option should be true (default) or false.\");\r\n            }\r\n        }\r\n    \r\n        // Test all developer settings and parse to assumption-safe values.\r\n        function testOptions ( options ) {\r\n    \r\n            // To prove a fix for #537, freeze options here.\r\n            // If the object is modified, an error will be thrown.\r\n            // Object.freeze(options);\r\n    \r\n            var parsed = {\r\n                margin: 0,\r\n                limit: 0,\r\n                padding: 0,\r\n                animate: true,\r\n                animationDuration: 300,\r\n                ariaFormat: defaultFormatter,\r\n                format: defaultFormatter\r\n            };\r\n    \r\n            // Tests are executed in the order they are presented here.\r\n            var tests = {\r\n                'step': { r: false, t: testStep },\r\n                'start': { r: true, t: testStart },\r\n                'connect': { r: true, t: testConnect },\r\n                'direction': { r: true, t: testDirection },\r\n                'snap': { r: false, t: testSnap },\r\n                'animate': { r: false, t: testAnimate },\r\n                'animationDuration': { r: false, t: testAnimationDuration },\r\n                'range': { r: true, t: testRange },\r\n                'orientation': { r: false, t: testOrientation },\r\n                'margin': { r: false, t: testMargin },\r\n                'limit': { r: false, t: testLimit },\r\n                'padding': { r: false, t: testPadding },\r\n                'behaviour': { r: true, t: testBehaviour },\r\n                'multitouch': { r: true, t: testMultitouch },\r\n                'ariaFormat': { r: false, t: testAriaFormat },\r\n                'format': { r: false, t: testFormat },\r\n                'tooltips': { r: false, t: testTooltips },\r\n                'cssPrefix': { r: false, t: testCssPrefix },\r\n                'cssClasses': { r: false, t: testCssClasses },\r\n                'useRequestAnimationFrame': { r: false, t: testUseRaf }\r\n            };\r\n    \r\n            var defaults = {\r\n                'connect': false,\r\n                'direction': 'ltr',\r\n                'behaviour': 'tap',\r\n                'multitouch': false,\r\n                'orientation': 'horizontal',\r\n                'cssPrefix' : 'noUi-',\r\n                'cssClasses': {\r\n                    target: 'target',\r\n                    base: 'base',\r\n                    origin: 'origin',\r\n                    handle: 'handle',\r\n                    handleLower: 'handle-lower',\r\n                    handleUpper: 'handle-upper',\r\n                    horizontal: 'horizontal',\r\n                    vertical: 'vertical',\r\n                    background: 'background',\r\n                    connect: 'connect',\r\n                    ltr: 'ltr',\r\n                    rtl: 'rtl',\r\n                    draggable: 'draggable',\r\n                    drag: 'state-drag',\r\n                    tap: 'state-tap',\r\n                    active: 'active',\r\n                    tooltip: 'tooltip',\r\n                    pips: 'pips',\r\n                    pipsHorizontal: 'pips-horizontal',\r\n                    pipsVertical: 'pips-vertical',\r\n                    marker: 'marker',\r\n                    markerHorizontal: 'marker-horizontal',\r\n                    markerVertical: 'marker-vertical',\r\n                    markerNormal: 'marker-normal',\r\n                    markerLarge: 'marker-large',\r\n                    markerSub: 'marker-sub',\r\n                    value: 'value',\r\n                    valueHorizontal: 'value-horizontal',\r\n                    valueVertical: 'value-vertical',\r\n                    valueNormal: 'value-normal',\r\n                    valueLarge: 'value-large',\r\n                    valueSub: 'value-sub'\r\n                },\r\n                'useRequestAnimationFrame': true\r\n            };\r\n    \r\n            // AriaFormat defaults to regular format, if any.\r\n            if ( options.format && !options.ariaFormat ) {\r\n                options.ariaFormat = options.format;\r\n            }\r\n    \r\n            // Run all options through a testing mechanism to ensure correct\r\n            // input. It should be noted that options might get modified to\r\n            // be handled properly. E.g. wrapping integers in arrays.\r\n            Object.keys(tests).forEach(function( name ){\r\n    \r\n                // If the option isn't set, but it is required, throw an error.\r\n                if ( options[name] === undefined && defaults[name] === undefined ) {\r\n    \r\n                    if ( tests[name].r ) {\r\n                        throw new Error(\"noUiSlider (\" + VERSION + \"): '\" + name + \"' is required.\");\r\n                    }\r\n    \r\n                    return true;\r\n                }\r\n    \r\n                tests[name].t( parsed, options[name] === undefined ? defaults[name] : options[name] );\r\n            });\r\n    \r\n            // Forward pips options\r\n            parsed.pips = options.pips;\r\n    \r\n            var styles = [['left', 'top'], ['right', 'bottom']];\r\n    \r\n            // Pre-define the styles.\r\n            parsed.style = styles[parsed.dir][parsed.ort];\r\n            parsed.styleOposite = styles[parsed.dir?0:1][parsed.ort];\r\n    \r\n            return parsed;\r\n        }\r\n    \r\n    \r\n    function closure ( target, options, originalOptions ){\r\n    \r\n        var actions = getActions();\r\n        var supportsTouchActionNone = getSupportsTouchActionNone();\r\n        var supportsPassive = supportsTouchActionNone && getSupportsPassive();\r\n    \r\n        // All variables local to 'closure' are prefixed with 'scope_'\r\n        var scope_Target = target;\r\n        var scope_Locations = [];\r\n        var scope_Base;\r\n        var scope_Handles;\r\n        var scope_HandleNumbers = [];\r\n        var scope_ActiveHandlesCount = 0;\r\n        var scope_Connects;\r\n        var scope_Spectrum = options.spectrum;\r\n        var scope_Values = [];\r\n        var scope_Events = {};\r\n        var scope_Self;\r\n        var scope_Pips;\r\n        var scope_Document = target.ownerDocument;\r\n        var scope_DocumentElement = scope_Document.documentElement;\r\n        var scope_Body = scope_Document.body;\r\n    \r\n    \r\n        // Creates a node, adds it to target, returns the new node.\r\n        function addNodeTo ( target, className ) {\r\n    \r\n            var div = scope_Document.createElement('div');\r\n    \r\n            if ( className ) {\r\n                addClass(div, className);\r\n            }\r\n    \r\n            target.appendChild(div);\r\n    \r\n            return div;\r\n        }\r\n    \r\n        // Append a origin to the base\r\n        function addOrigin ( base, handleNumber ) {\r\n    \r\n            var origin = addNodeTo(base, options.cssClasses.origin);\r\n            var handle = addNodeTo(origin, options.cssClasses.handle);\r\n    \r\n            handle.setAttribute('data-handle', handleNumber);\r\n    \r\n            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n            // 0 = focusable and reachable\r\n            handle.setAttribute('tabindex', '0');\r\n            handle.setAttribute('role', 'slider');\r\n            handle.setAttribute('aria-orientation', options.ort ? 'vertical' : 'horizontal');\r\n    \r\n            if ( handleNumber === 0 ) {\r\n                addClass(handle, options.cssClasses.handleLower);\r\n            }\r\n    \r\n            else if ( handleNumber === options.handles - 1 ) {\r\n                addClass(handle, options.cssClasses.handleUpper);\r\n            }\r\n    \r\n            return origin;\r\n        }\r\n    \r\n        // Insert nodes for connect elements\r\n        function addConnect ( base, add ) {\r\n    \r\n            if ( !add ) {\r\n                return false;\r\n            }\r\n    \r\n            return addNodeTo(base, options.cssClasses.connect);\r\n        }\r\n    \r\n        // Add handles to the slider base.\r\n        function addElements ( connectOptions, base ) {\r\n    \r\n            scope_Handles = [];\r\n            scope_Connects = [];\r\n    \r\n            scope_Connects.push(addConnect(base, connectOptions[0]));\r\n    \r\n            // [::::O====O====O====]\r\n            // connectOptions = [0, 1, 1, 1]\r\n    \r\n            for ( var i = 0; i < options.handles; i++ ) {\r\n                // Keep a list of all added handles.\r\n                scope_Handles.push(addOrigin(base, i));\r\n                scope_HandleNumbers[i] = i;\r\n                scope_Connects.push(addConnect(base, connectOptions[i + 1]));\r\n            }\r\n        }\r\n    \r\n        // Initialize a single slider.\r\n        function addSlider ( target ) {\r\n    \r\n            // Apply classes and data to the target.\r\n            addClass(target, options.cssClasses.target);\r\n    \r\n            if ( options.dir === 0 ) {\r\n                addClass(target, options.cssClasses.ltr);\r\n            } else {\r\n                addClass(target, options.cssClasses.rtl);\r\n            }\r\n    \r\n            if ( options.ort === 0 ) {\r\n                addClass(target, options.cssClasses.horizontal);\r\n            } else {\r\n                addClass(target, options.cssClasses.vertical);\r\n            }\r\n    \r\n            scope_Base = addNodeTo(target, options.cssClasses.base);\r\n        }\r\n    \r\n    \r\n        function addTooltip ( handle, handleNumber ) {\r\n    \r\n            if ( !options.tooltips[handleNumber] ) {\r\n                return false;\r\n            }\r\n    \r\n            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\r\n        }\r\n    \r\n        // The tooltips option is a shorthand for using the 'update' event.\r\n        function tooltips ( ) {\r\n    \r\n            // Tooltips are added with options.tooltips in original order.\r\n            var tips = scope_Handles.map(addTooltip);\r\n    \r\n            bindEvent('update', function(values, handleNumber, unencoded) {\r\n    \r\n                if ( !tips[handleNumber] ) {\r\n                    return;\r\n                }\r\n    \r\n                var formattedValue = values[handleNumber];\r\n    \r\n                if ( options.tooltips[handleNumber] !== true ) {\r\n                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\r\n                }\r\n    \r\n                tips[handleNumber].innerHTML = formattedValue;\r\n            });\r\n        }\r\n    \r\n    \r\n        function aria ( ) {\r\n    \r\n            bindEvent('update', function ( values, handleNumber, unencoded, tap, positions ) {\r\n    \r\n                // Update Aria Values for all handles, as a change in one changes min and max values for the next.\r\n                scope_HandleNumbers.forEach(function( handleNumber ){\r\n    \r\n                    var handle = scope_Handles[handleNumber];\r\n    \r\n                    var min = checkHandlePosition(scope_Locations, handleNumber, 0, true, true, true);\r\n                    var max = checkHandlePosition(scope_Locations, handleNumber, 100, true, true, true);\r\n    \r\n                    var now = positions[handleNumber];\r\n                    var text = options.ariaFormat.to(unencoded[handleNumber]);\r\n    \r\n                    handle.children[0].setAttribute('aria-valuemin', min.toFixed(1));\r\n                    handle.children[0].setAttribute('aria-valuemax', max.toFixed(1));\r\n                    handle.children[0].setAttribute('aria-valuenow', now.toFixed(1));\r\n                    handle.children[0].setAttribute('aria-valuetext', text);\r\n                });\r\n            });\r\n        }\r\n    \r\n    \r\n        function getGroup ( mode, values, stepped ) {\r\n    \r\n            // Use the range.\r\n            if ( mode === 'range' || mode === 'steps' ) {\r\n                return scope_Spectrum.xVal;\r\n            }\r\n    \r\n            if ( mode === 'count' ) {\r\n    \r\n                if ( !values ) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): 'values' required for mode 'count'.\");\r\n                }\r\n    \r\n                // Divide 0 - 100 in 'count' parts.\r\n                var spread = ( 100 / (values - 1) );\r\n                var v;\r\n                var i = 0;\r\n    \r\n                values = [];\r\n    \r\n                // List these parts and have them handled as 'positions'.\r\n                while ( (v = i++ * spread) <= 100 ) {\r\n                    values.push(v);\r\n                }\r\n    \r\n                mode = 'positions';\r\n            }\r\n    \r\n            if ( mode === 'positions' ) {\r\n    \r\n                // Map all percentages to on-range values.\r\n                return values.map(function( value ){\r\n                    return scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );\r\n                });\r\n            }\r\n    \r\n            if ( mode === 'values' ) {\r\n    \r\n                // If the value must be stepped, it needs to be converted to a percentage first.\r\n                if ( stepped ) {\r\n    \r\n                    return values.map(function( value ){\r\n    \r\n                        // Convert to percentage, apply step, return to value.\r\n                        return scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );\r\n                    });\r\n    \r\n                }\r\n    \r\n                // Otherwise, we can simply use the values.\r\n                return values;\r\n            }\r\n        }\r\n    \r\n        function generateSpread ( density, mode, group ) {\r\n    \r\n            function safeIncrement(value, increment) {\r\n                // Avoid floating point variance by dropping the smallest decimal places.\r\n                return (value + increment).toFixed(7) / 1;\r\n            }\r\n    \r\n            var indexes = {};\r\n            var firstInRange = scope_Spectrum.xVal[0];\r\n            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1];\r\n            var ignoreFirst = false;\r\n            var ignoreLast = false;\r\n            var prevPct = 0;\r\n    \r\n            // Create a copy of the group, sort it and filter away all duplicates.\r\n            group = unique(group.slice().sort(function(a, b){ return a - b; }));\r\n    \r\n            // Make sure the range starts with the first element.\r\n            if ( group[0] !== firstInRange ) {\r\n                group.unshift(firstInRange);\r\n                ignoreFirst = true;\r\n            }\r\n    \r\n            // Likewise for the last one.\r\n            if ( group[group.length - 1] !== lastInRange ) {\r\n                group.push(lastInRange);\r\n                ignoreLast = true;\r\n            }\r\n    \r\n            group.forEach(function ( current, index ) {\r\n    \r\n                // Get the current step and the lower + upper positions.\r\n                var step;\r\n                var i;\r\n                var q;\r\n                var low = current;\r\n                var high = group[index+1];\r\n                var newPct;\r\n                var pctDifference;\r\n                var pctPos;\r\n                var type;\r\n                var steps;\r\n                var realSteps;\r\n                var stepsize;\r\n    \r\n                // When using 'steps' mode, use the provided steps.\r\n                // Otherwise, we'll step on to the next subrange.\r\n                if ( mode === 'steps' ) {\r\n                    step = scope_Spectrum.xNumSteps[ index ];\r\n                }\r\n    \r\n                // Default to a 'full' step.\r\n                if ( !step ) {\r\n                    step = high-low;\r\n                }\r\n    \r\n                // Low can be 0, so test for false. If high is undefined,\r\n                // we are at the last subrange. Index 0 is already handled.\r\n                if ( low === false || high === undefined ) {\r\n                    return;\r\n                }\r\n    \r\n                // Make sure step isn't 0, which would cause an infinite loop (#654)\r\n                step = Math.max(step, 0.0000001);\r\n    \r\n                // Find all steps in the subrange.\r\n                for ( i = low; i <= high; i = safeIncrement(i, step) ) {\r\n    \r\n                    // Get the percentage value for the current step,\r\n                    // calculate the size for the subrange.\r\n                    newPct = scope_Spectrum.toStepping( i );\r\n                    pctDifference = newPct - prevPct;\r\n    \r\n                    steps = pctDifference / density;\r\n                    realSteps = Math.round(steps);\r\n    \r\n                    // This ratio represents the ammount of percentage-space a point indicates.\r\n                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.\r\n                    // Round the percentage offset to an even number, then divide by two\r\n                    // to spread the offset on both sides of the range.\r\n                    stepsize = pctDifference/realSteps;\r\n    \r\n                    // Divide all points evenly, adding the correct number to this subrange.\r\n                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n                    for ( q = 1; q <= realSteps; q += 1 ) {\r\n    \r\n                        // The ratio between the rounded value and the actual size might be ~1% off.\r\n                        // Correct the percentage offset by the number of points\r\n                        // per subrange. density = 1 will result in 100 points on the\r\n                        // full range, 2 for 50, 4 for 25, etc.\r\n                        pctPos = prevPct + ( q * stepsize );\r\n                        indexes[pctPos.toFixed(5)] = ['x', 0];\r\n                    }\r\n    \r\n                    // Determine the point type.\r\n                    type = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );\r\n    \r\n                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.\r\n                    if ( !index && ignoreFirst ) {\r\n                        type = 0;\r\n                    }\r\n    \r\n                    if ( !(i === high && ignoreLast)) {\r\n                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n                        indexes[newPct.toFixed(5)] = [i, type];\r\n                    }\r\n    \r\n                    // Update the percentage count.\r\n                    prevPct = newPct;\r\n                }\r\n            });\r\n    \r\n            return indexes;\r\n        }\r\n    \r\n        function addMarking ( spread, filterFunc, formatter ) {\r\n    \r\n            var element = scope_Document.createElement('div');\r\n    \r\n            var valueSizeClasses = [\r\n                options.cssClasses.valueNormal,\r\n                options.cssClasses.valueLarge,\r\n                options.cssClasses.valueSub\r\n            ];\r\n            var markerSizeClasses = [\r\n                options.cssClasses.markerNormal,\r\n                options.cssClasses.markerLarge,\r\n                options.cssClasses.markerSub\r\n            ];\r\n            var valueOrientationClasses = [\r\n                options.cssClasses.valueHorizontal,\r\n                options.cssClasses.valueVertical\r\n            ];\r\n            var markerOrientationClasses = [\r\n                options.cssClasses.markerHorizontal,\r\n                options.cssClasses.markerVertical\r\n            ];\r\n    \r\n            addClass(element, options.cssClasses.pips);\r\n            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\r\n    \r\n            function getClasses( type, source ){\r\n                var a = source === options.cssClasses.value;\r\n                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\r\n                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\r\n    \r\n                return source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];\r\n            }\r\n    \r\n            function addSpread ( offset, values ){\r\n    \r\n                // Apply the filter function, if it is set.\r\n                values[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];\r\n    \r\n                // Add a marker for every point\r\n                var node = addNodeTo(element, false);\r\n                    node.className = getClasses(values[1], options.cssClasses.marker);\r\n                    node.style[options.style] = offset + '%';\r\n    \r\n                // Values are only appended for points marked '1' or '2'.\r\n                if ( values[1] ) {\r\n                    node = addNodeTo(element, false);\r\n                    node.className = getClasses(values[1], options.cssClasses.value);\r\n                    node.style[options.style] = offset + '%';\r\n                    node.innerText = formatter.to(values[0]);\r\n                }\r\n            }\r\n    \r\n            // Append all points.\r\n            Object.keys(spread).forEach(function(a){\r\n                addSpread(a, spread[a]);\r\n            });\r\n    \r\n            return element;\r\n        }\r\n    \r\n        function removePips ( ) {\r\n            if ( scope_Pips ) {\r\n                removeElement(scope_Pips);\r\n                scope_Pips = null;\r\n            }\r\n        }\r\n    \r\n        function pips ( grid ) {\r\n    \r\n            // Fix #669\r\n            removePips();\r\n    \r\n            var mode = grid.mode;\r\n            var density = grid.density || 1;\r\n            var filter = grid.filter || false;\r\n            var values = grid.values || false;\r\n            var stepped = grid.stepped || false;\r\n            var group = getGroup( mode, values, stepped );\r\n            var spread = generateSpread( density, mode, group );\r\n            var format = grid.format || {\r\n                to: Math.round\r\n            };\r\n    \r\n            scope_Pips = scope_Target.appendChild(addMarking(\r\n                spread,\r\n                filter,\r\n                format\r\n            ));\r\n    \r\n            return scope_Pips;\r\n        }\r\n    \r\n    \r\n        // Shorthand for base dimensions.\r\n        function baseSize ( ) {\r\n            var rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort];\r\n            return options.ort === 0 ? (rect.width||scope_Base[alt]) : (rect.height||scope_Base[alt]);\r\n        }\r\n    \r\n        // Handler for attaching events trough a proxy.\r\n        function attachEvent ( events, element, callback, data ) {\r\n    \r\n            // This function can be used to 'filter' events to the slider.\r\n            // element is a node, not a nodeList\r\n    \r\n            var method = function ( e ){\r\n    \r\n                if ( scope_Target.hasAttribute('disabled') ) {\r\n                    return false;\r\n                }\r\n    \r\n                // Stop if an active 'tap' transition is taking place.\r\n                if ( hasClass(scope_Target, options.cssClasses.tap) ) {\r\n                    return false;\r\n                }\r\n    \r\n                e = fixEvent(e, data.pageOffset, data.target || element);\r\n    \r\n                // Handle reject of multitouch\r\n                if ( !e ) {\r\n                    return false;\r\n                }\r\n    \r\n                // Ignore right or middle clicks on start #454\r\n                if ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {\r\n                    return false;\r\n                }\r\n    \r\n                // Ignore right or middle clicks on start #454\r\n                if ( data.hover && e.buttons ) {\r\n                    return false;\r\n                }\r\n    \r\n                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.\r\n                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support\r\n                // touch-action: manipulation, but that allows panning, which breaks\r\n                // sliders after zooming/on non-responsive pages.\r\n                // See: https://bugs.webkit.org/show_bug.cgi?id=133112\r\n                if ( !supportsPassive ) {\r\n                    e.preventDefault();\r\n                }\r\n    \r\n                e.calcPoint = e.points[ options.ort ];\r\n    \r\n                // Call the event handler with the event [ and additional data ].\r\n                callback ( e, data );\r\n            };\r\n    \r\n            var methods = [];\r\n    \r\n            // Bind a closure on the target for every event type.\r\n            events.split(' ').forEach(function( eventName ){\r\n                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\r\n                methods.push([eventName, method]);\r\n            });\r\n    \r\n            return methods;\r\n        }\r\n    \r\n        // Provide a clean event with standardized offset values.\r\n        function fixEvent ( e, pageOffset, target ) {\r\n    \r\n            // Filter the event to register the type, which can be\r\n            // touch, mouse or pointer. Offset changes need to be\r\n            // made on an event specific basis.\r\n            var touch = e.type.indexOf('touch') === 0;\r\n            var mouse = e.type.indexOf('mouse') === 0;\r\n            var pointer = e.type.indexOf('pointer') === 0;\r\n    \r\n            var x;\r\n            var y;\r\n    \r\n            // IE10 implemented pointer events with a prefix;\r\n            if ( e.type.indexOf('MSPointer') === 0 ) {\r\n                pointer = true;\r\n            }\r\n    \r\n    \r\n            // In the event that multitouch is activated, the only thing one handle should be concerned\r\n            // about is the touches that originated on top of it.\r\n            if ( touch && options.multitouch ) {\r\n                // Returns true if a touch originated on the target.\r\n                var isTouchOnTarget = function (touch) {\r\n                    return touch.target === target || target.contains(touch.target);\r\n                };\r\n                // In the case of touchstart events, we need to make sure there is still no more than one\r\n                // touch on the target so we look amongst all touches.\r\n                if (e.type === 'touchstart') {\r\n                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\r\n                    // Do not support more than one touch per handle.\r\n                    if ( targetTouches.length > 1 ) {\r\n                        return false;\r\n                    }\r\n                    x = targetTouches[0].pageX;\r\n                    y = targetTouches[0].pageY;\r\n                } else {\r\n                // In the other cases, find on changedTouches is enough.\r\n                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\r\n                    // Cancel if the target touch has not moved.\r\n                    if ( !targetTouch ) {\r\n                        return false;\r\n                    }\r\n                    x = targetTouch.pageX;\r\n                    y = targetTouch.pageY;\r\n                }\r\n            } else if ( touch ) {\r\n                // Fix bug when user touches with two or more fingers on mobile devices.\r\n                // It's useful when you have two or more sliders on one page,\r\n                // that can be touched simultaneously.\r\n                // #649, #663, #668\r\n                if ( e.touches.length > 1 ) {\r\n                    return false;\r\n                }\r\n    \r\n                // noUiSlider supports one movement at a time,\r\n                // so we can select the first 'changedTouch'.\r\n                x = e.changedTouches[0].pageX;\r\n                y = e.changedTouches[0].pageY;\r\n            }\r\n    \r\n            pageOffset = pageOffset || getPageOffset(scope_Document);\r\n    \r\n            if ( mouse || pointer ) {\r\n                x = e.clientX + pageOffset.x;\r\n                y = e.clientY + pageOffset.y;\r\n            }\r\n    \r\n            e.pageOffset = pageOffset;\r\n            e.points = [x, y];\r\n            e.cursor = mouse || pointer; // Fix #435\r\n    \r\n            return e;\r\n        }\r\n    \r\n        // Translate a coordinate in the document to a percentage on the slider\r\n        function calcPointToPercentage ( calcPoint ) {\r\n            var location = calcPoint - offset(scope_Base, options.ort);\r\n            var proposal = ( location * 100 ) / baseSize();\r\n            return options.dir ? 100 - proposal : proposal;\r\n        }\r\n    \r\n        // Find handle closest to a certain percentage on the slider\r\n        function getClosestHandle ( proposal ) {\r\n    \r\n            var closest = 100;\r\n            var handleNumber = false;\r\n    \r\n            scope_Handles.forEach(function(handle, index){\r\n    \r\n                // Disabled handles are ignored\r\n                if ( handle.hasAttribute('disabled') ) {\r\n                    return;\r\n                }\r\n    \r\n                var pos = Math.abs(scope_Locations[index] - proposal);\r\n    \r\n                if ( pos < closest ) {\r\n                    handleNumber = index;\r\n                    closest = pos;\r\n                }\r\n            });\r\n    \r\n            return handleNumber;\r\n        }\r\n    \r\n        // Moves handle(s) by a percentage\r\n        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\r\n        function moveHandles ( upward, proposal, locations, handleNumbers ) {\r\n    \r\n            var proposals = locations.slice();\r\n    \r\n            var b = [!upward, upward];\r\n            var f = [upward, !upward];\r\n    \r\n            // Copy handleNumbers so we don't change the dataset\r\n            handleNumbers = handleNumbers.slice();\r\n    \r\n            // Check to see which handle is 'leading'.\r\n            // If that one can't move the second can't either.\r\n            if ( upward ) {\r\n                handleNumbers.reverse();\r\n            }\r\n    \r\n            // Step 1: get the maximum percentage that any of the handles can move\r\n            if ( handleNumbers.length > 1 ) {\r\n    \r\n                handleNumbers.forEach(function(handleNumber, o) {\r\n    \r\n                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);\r\n    \r\n                    // Stop if one of the handles can't move.\r\n                    if ( to === false ) {\r\n                        proposal = 0;\r\n                    } else {\r\n                        proposal = to - proposals[handleNumber];\r\n                        proposals[handleNumber] = to;\r\n                    }\r\n                });\r\n            }\r\n    \r\n            // If using one handle, check backward AND forward\r\n            else {\r\n                b = f = [true];\r\n            }\r\n    \r\n            var state = false;\r\n    \r\n            // Step 2: Try to set the handles with the found percentage\r\n            handleNumbers.forEach(function(handleNumber, o) {\r\n                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\r\n            });\r\n    \r\n            // Step 3: If a handle moved, fire events\r\n            if ( state ) {\r\n                handleNumbers.forEach(function(handleNumber){\r\n                    fireEvent('update', handleNumber);\r\n                    fireEvent('slide', handleNumber);\r\n                });\r\n            }\r\n        }\r\n    \r\n        // External event handling\r\n        function fireEvent ( eventName, handleNumber, tap ) {\r\n    \r\n            Object.keys(scope_Events).forEach(function( targetEvent ) {\r\n    \r\n                var eventType = targetEvent.split('.')[0];\r\n    \r\n                if ( eventName === eventType ) {\r\n                    scope_Events[targetEvent].forEach(function( callback ) {\r\n    \r\n                        callback.call(\r\n                            // Use the slider public API as the scope ('this')\r\n                            scope_Self,\r\n                            // Return values as array, so arg_1[arg_2] is always valid.\r\n                            scope_Values.map(options.format.to),\r\n                            // Handle index, 0 or 1\r\n                            handleNumber,\r\n                            // Unformatted slider values\r\n                            scope_Values.slice(),\r\n                            // Event is fired by tap, true or false\r\n                            tap || false,\r\n                            // Left offset of the handle, in relation to the slider\r\n                            scope_Locations.slice()\r\n                        );\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    \r\n    \r\n        // Fire 'end' when a mouse or pen leaves the document.\r\n        function documentLeave ( event, data ) {\r\n            if ( event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null ){\r\n                eventEnd (event, data);\r\n            }\r\n        }\r\n    \r\n        // Handle movement on document for handle and range drag.\r\n        function eventMove ( event, data ) {\r\n    \r\n            // Fix #498\r\n            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n            // IE9 has .buttons and .which zero on mousemove.\r\n            // Firefox breaks the spec MDN defines.\r\n            if ( navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0 ) {\r\n                return eventEnd(event, data);\r\n            }\r\n    \r\n            // Check if we are moving up or down\r\n            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\r\n    \r\n            // Convert the movement into a percentage of the slider width/height\r\n            var proposal = (movement * 100) / data.baseSize;\r\n    \r\n            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\r\n        }\r\n    \r\n        // Unbind move events on document, call callbacks.\r\n        function eventEnd ( event, data ) {\r\n    \r\n            // The handle is no longer active, so remove the class.\r\n            if ( data.handle ) {\r\n                removeClass(data.handle, options.cssClasses.active);\r\n                scope_ActiveHandlesCount -= 1;\r\n            }\r\n    \r\n            // Unbind the move and end events, which are added on 'start'.\r\n            data.listeners.forEach(function( c ) {\r\n                scope_DocumentElement.removeEventListener(c[0], c[1]);\r\n            });\r\n    \r\n            if ( scope_ActiveHandlesCount === 0 ) {\r\n                // Remove dragging class.\r\n                removeClass(scope_Target, options.cssClasses.drag);\r\n                setZindex();\r\n    \r\n                // Remove cursor styles and text-selection events bound to the body.\r\n                if ( event.cursor ) {\r\n                    scope_Body.style.cursor = '';\r\n                    scope_Body.removeEventListener('selectstart', preventDefault);\r\n                }\r\n            }\r\n    \r\n            data.handleNumbers.forEach(function(handleNumber){\r\n                fireEvent('change', handleNumber);\r\n                fireEvent('set', handleNumber);\r\n                fireEvent('end', handleNumber);\r\n            });\r\n        }\r\n    \r\n        // Bind move events on document.\r\n        function eventStart ( event, data ) {\r\n    \r\n            var handle;\r\n            if ( data.handleNumbers.length === 1 ) {\r\n    \r\n                var handleOrigin = scope_Handles[data.handleNumbers[0]];\r\n    \r\n                // Ignore 'disabled' handles\r\n                if ( handleOrigin.hasAttribute('disabled') ) {\r\n                    return false;\r\n                }\r\n    \r\n                handle = handleOrigin.children[0];\r\n                scope_ActiveHandlesCount += 1;\r\n    \r\n                // Mark the handle as 'active' so it can be styled.\r\n                addClass(handle, options.cssClasses.active);\r\n            }\r\n    \r\n            // A drag should never propagate up to the 'tap' event.\r\n            event.stopPropagation();\r\n    \r\n            // Record the event listeners.\r\n            var listeners = [];\r\n    \r\n            // Attach the move and end events.\r\n            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\r\n                // The event target has changed so we need to propagate the original one so that we keep\r\n                // relying on it to extract target touches.\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                startCalcPoint: event.calcPoint,\r\n                baseSize: baseSize(),\r\n                pageOffset: event.pageOffset,\r\n                handleNumbers: data.handleNumbers,\r\n                buttonsProperty: event.buttons,\r\n                locations: scope_Locations.slice()\r\n            });\r\n    \r\n            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n    \r\n            var outEvent = attachEvent(\"mouseout\", scope_DocumentElement, documentLeave, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n    \r\n            // We want to make sure we pushed the listeners in the listener list rather than creating\r\n            // a new one as it has already been passed to the event handlers.\r\n            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\r\n    \r\n            // Text selection isn't an issue on touch devices,\r\n            // so adding cursor styles can be skipped.\r\n            if ( event.cursor ) {\r\n    \r\n                // Prevent the 'I' cursor and extend the range-drag cursor.\r\n                scope_Body.style.cursor = getComputedStyle(event.target).cursor;\r\n    \r\n                // Mark the target with a dragging state.\r\n                if ( scope_Handles.length > 1 ) {\r\n                    addClass(scope_Target, options.cssClasses.drag);\r\n                }\r\n    \r\n                // Prevent text selection when dragging the handles.\r\n                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\r\n                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\r\n                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.\r\n                // The 'cursor' flag is false.\r\n                // See: http://caniuse.com/#search=selectstart\r\n                scope_Body.addEventListener('selectstart', preventDefault, false);\r\n            }\r\n    \r\n            data.handleNumbers.forEach(function(handleNumber){\r\n                fireEvent('start', handleNumber);\r\n            });\r\n        }\r\n    \r\n        // Move closest handle to tapped location.\r\n        function eventTap ( event ) {\r\n    \r\n            // The tap event shouldn't propagate up\r\n            event.stopPropagation();\r\n    \r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n            var handleNumber = getClosestHandle(proposal);\r\n    \r\n            // Tackle the case that all handles are 'disabled'.\r\n            if ( handleNumber === false ) {\r\n                return false;\r\n            }\r\n    \r\n            // Flag the slider as it is now in a transitional state.\r\n            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\r\n            if ( !options.events.snap ) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n    \r\n            setHandle(handleNumber, proposal, true, true);\r\n    \r\n            setZindex();\r\n    \r\n            fireEvent('slide', handleNumber, true);\r\n            fireEvent('update', handleNumber, true);\r\n            fireEvent('change', handleNumber, true);\r\n            fireEvent('set', handleNumber, true);\r\n    \r\n            if ( options.events.snap ) {\r\n                eventStart(event, { handleNumbers: [handleNumber] });\r\n            }\r\n        }\r\n    \r\n        // Fires a 'hover' event for a hovered mouse/pen position.\r\n        function eventHover ( event ) {\r\n    \r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n    \r\n            var to = scope_Spectrum.getStep(proposal);\r\n            var value = scope_Spectrum.fromStepping(to);\r\n    \r\n            Object.keys(scope_Events).forEach(function( targetEvent ) {\r\n                if ( 'hover' === targetEvent.split('.')[0] ) {\r\n                    scope_Events[targetEvent].forEach(function( callback ) {\r\n                        callback.call( scope_Self, value );\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    \r\n        // Attach events to several slider parts.\r\n        function bindSliderEvents ( behaviour ) {\r\n    \r\n            // Attach the standard drag event to the handles.\r\n            if ( !behaviour.fixed ) {\r\n    \r\n                scope_Handles.forEach(function( handle, index ){\r\n    \r\n                    // These events are only bound to the visual handle\r\n                    // element, not the 'real' origin element.\r\n                    attachEvent ( actions.start, handle.children[0], eventStart, {\r\n                        handleNumbers: [index]\r\n                    });\r\n                });\r\n            }\r\n    \r\n            // Attach the tap event to the slider base.\r\n            if ( behaviour.tap ) {\r\n                attachEvent (actions.start, scope_Base, eventTap, {});\r\n            }\r\n    \r\n            // Fire hover events\r\n            if ( behaviour.hover ) {\r\n                attachEvent (actions.move, scope_Base, eventHover, { hover: true });\r\n            }\r\n    \r\n            // Make the range draggable.\r\n            if ( behaviour.drag ){\r\n    \r\n                scope_Connects.forEach(function( connect, index ){\r\n    \r\n                    if ( connect === false || index === 0 || index === scope_Connects.length - 1 ) {\r\n                        return;\r\n                    }\r\n    \r\n                    var handleBefore = scope_Handles[index - 1];\r\n                    var handleAfter = scope_Handles[index];\r\n                    var eventHolders = [connect];\r\n    \r\n                    addClass(connect, options.cssClasses.draggable);\r\n    \r\n                    // When the range is fixed, the entire range can\r\n                    // be dragged by the handles. The handle in the first\r\n                    // origin will propagate the start event upward,\r\n                    // but it needs to be bound manually on the other.\r\n                    if ( behaviour.fixed ) {\r\n                        eventHolders.push(handleBefore.children[0]);\r\n                        eventHolders.push(handleAfter.children[0]);\r\n                    }\r\n    \r\n                    eventHolders.forEach(function( eventHolder ) {\r\n                        attachEvent ( actions.start, eventHolder, eventStart, {\r\n                            handles: [handleBefore, handleAfter],\r\n                            handleNumbers: [index - 1, index]\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    \r\n    \r\n        // Split out the handle positioning logic so the Move event can use it, too\r\n        function checkHandlePosition ( reference, handleNumber, to, lookBackward, lookForward, getValue ) {\r\n    \r\n            // For sliders with multiple handles, limit movement to the other handle.\r\n            // Apply the margin option by adding it to the handle positions.\r\n            if ( scope_Handles.length > 1 ) {\r\n    \r\n                if ( lookBackward && handleNumber > 0 ) {\r\n                    to = Math.max(to, reference[handleNumber - 1] + options.margin);\r\n                }\r\n    \r\n                if ( lookForward && handleNumber < scope_Handles.length - 1 ) {\r\n                    to = Math.min(to, reference[handleNumber + 1] - options.margin);\r\n                }\r\n            }\r\n    \r\n            // The limit option has the opposite effect, limiting handles to a\r\n            // maximum distance from another. Limit must be > 0, as otherwise\r\n            // handles would be unmoveable.\r\n            if ( scope_Handles.length > 1 && options.limit ) {\r\n    \r\n                if ( lookBackward && handleNumber > 0 ) {\r\n                    to = Math.min(to, reference[handleNumber - 1] + options.limit);\r\n                }\r\n    \r\n                if ( lookForward && handleNumber < scope_Handles.length - 1 ) {\r\n                    to = Math.max(to, reference[handleNumber + 1] - options.limit);\r\n                }\r\n            }\r\n    \r\n            // The padding option keeps the handles a certain distance from the\r\n            // edges of the slider. Padding must be > 0.\r\n            if ( options.padding ) {\r\n    \r\n                if ( handleNumber === 0 ) {\r\n                    to = Math.max(to, options.padding);\r\n                }\r\n    \r\n                if ( handleNumber === scope_Handles.length - 1 ) {\r\n                    to = Math.min(to, 100 - options.padding);\r\n                }\r\n            }\r\n    \r\n            to = scope_Spectrum.getStep(to);\r\n    \r\n            // Limit percentage to the 0 - 100 range\r\n            to = limit(to);\r\n    \r\n            // Return false if handle can't move\r\n            if ( to === reference[handleNumber] && !getValue ) {\r\n                return false;\r\n            }\r\n    \r\n            return to;\r\n        }\r\n    \r\n        function toPct ( pct ) {\r\n            return pct + '%';\r\n        }\r\n    \r\n        // Updates scope_Locations and scope_Values, updates visual state\r\n        function updateHandlePosition ( handleNumber, to ) {\r\n    \r\n            // Update locations.\r\n            scope_Locations[handleNumber] = to;\r\n    \r\n            // Convert the value to the slider stepping/range.\r\n            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\r\n    \r\n            // Called synchronously or on the next animationFrame\r\n            var stateUpdate = function() {\r\n                scope_Handles[handleNumber].style[options.style] = toPct(to);\r\n                updateConnect(handleNumber);\r\n                updateConnect(handleNumber + 1);\r\n            };\r\n    \r\n            // Set the handle to the new position.\r\n            // Use requestAnimationFrame for efficient painting.\r\n            // No significant effect in Chrome, Edge sees dramatic performace improvements.\r\n            // Option to disable is useful for unit tests, and single-step debugging.\r\n            if ( window.requestAnimationFrame && options.useRequestAnimationFrame ) {\r\n                window.requestAnimationFrame(stateUpdate);\r\n            } else {\r\n                stateUpdate();\r\n            }\r\n        }\r\n    \r\n        function setZindex ( ) {\r\n    \r\n            scope_HandleNumbers.forEach(function(handleNumber){\r\n                // Handles before the slider middle are stacked later = higher,\r\n                // Handles after the middle later is lower\r\n                // [[7] [8] .......... | .......... [5] [4]\r\n                var dir = (scope_Locations[handleNumber] > 50 ? -1 : 1);\r\n                var zIndex = 3 + (scope_Handles.length + (dir * handleNumber));\r\n                scope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;\r\n            });\r\n        }\r\n    \r\n        // Test suggested values and apply margin, step.\r\n        function setHandle ( handleNumber, to, lookBackward, lookForward ) {\r\n    \r\n            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\r\n    \r\n            if ( to === false ) {\r\n                return false;\r\n            }\r\n    \r\n            updateHandlePosition(handleNumber, to);\r\n    \r\n            return true;\r\n        }\r\n    \r\n        // Updates style attribute for connect nodes\r\n        function updateConnect ( index ) {\r\n    \r\n            // Skip connects set to false\r\n            if ( !scope_Connects[index] ) {\r\n                return;\r\n            }\r\n    \r\n            var l = 0;\r\n            var h = 100;\r\n    \r\n            if ( index !== 0 ) {\r\n                l = scope_Locations[index - 1];\r\n            }\r\n    \r\n            if ( index !== scope_Connects.length - 1 ) {\r\n                h = scope_Locations[index];\r\n            }\r\n    \r\n            scope_Connects[index].style[options.style] = toPct(l);\r\n            scope_Connects[index].style[options.styleOposite] = toPct(100 - h);\r\n        }\r\n    \r\n        // ...\r\n        function setValue ( to, handleNumber ) {\r\n    \r\n            // Setting with null indicates an 'ignore'.\r\n            // Inputting 'false' is invalid.\r\n            if ( to === null || to === false ) {\r\n                return;\r\n            }\r\n    \r\n            // If a formatted number was passed, attemt to decode it.\r\n            if ( typeof to === 'number' ) {\r\n                to = String(to);\r\n            }\r\n    \r\n            to = options.format.from(to);\r\n    \r\n            // Request an update for all links if the value was invalid.\r\n            // Do so too if setting the handle fails.\r\n            if ( to !== false && !isNaN(to) ) {\r\n                setHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);\r\n            }\r\n        }\r\n    \r\n        // Set the slider value.\r\n        function valueSet ( input, fireSetEvent ) {\r\n    \r\n            var values = asArray(input);\r\n            var isInit = scope_Locations[0] === undefined;\r\n    \r\n            // Event fires by default\r\n            fireSetEvent = (fireSetEvent === undefined ? true : !!fireSetEvent);\r\n    \r\n            values.forEach(setValue);\r\n    \r\n            // Animation is optional.\r\n            // Make sure the initial values were set before using animated placement.\r\n            if ( options.animate && !isInit ) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n    \r\n            // Now that all base values are set, apply constraints\r\n            scope_HandleNumbers.forEach(function(handleNumber){\r\n                setHandle(handleNumber, scope_Locations[handleNumber], true, false);\r\n            });\r\n    \r\n            setZindex();\r\n    \r\n            scope_HandleNumbers.forEach(function(handleNumber){\r\n    \r\n                fireEvent('update', handleNumber);\r\n    \r\n                // Fire the event only for handles that received a new value, as per #579\r\n                if ( values[handleNumber] !== null && fireSetEvent ) {\r\n                    fireEvent('set', handleNumber);\r\n                }\r\n            });\r\n        }\r\n    \r\n        // Reset slider to initial values\r\n        function valueReset ( fireSetEvent ) {\r\n            valueSet(options.start, fireSetEvent);\r\n        }\r\n    \r\n        // Get the slider value.\r\n        function valueGet ( ) {\r\n    \r\n            var values = scope_Values.map(options.format.to);\r\n    \r\n            // If only one handle is used, return a single value.\r\n            if ( values.length === 1 ){\r\n                return values[0];\r\n            }\r\n    \r\n            return values;\r\n        }\r\n    \r\n        // Removes classes from the root and empties it.\r\n        function destroy ( ) {\r\n    \r\n            for ( var key in options.cssClasses ) {\r\n                if ( !options.cssClasses.hasOwnProperty(key) ) { continue; }\r\n                removeClass(scope_Target, options.cssClasses[key]);\r\n            }\r\n    \r\n            while (scope_Target.firstChild) {\r\n                scope_Target.removeChild(scope_Target.firstChild);\r\n            }\r\n    \r\n            delete scope_Target.noUiSlider;\r\n        }\r\n    \r\n        // Get the current step size for the slider.\r\n        function getCurrentStep ( ) {\r\n    \r\n            // Check all locations, map them to their stepping point.\r\n            // Get the step point, then find it in the input list.\r\n            return scope_Locations.map(function( location, index ){\r\n    \r\n                var nearbySteps = scope_Spectrum.getNearbySteps( location );\r\n                var value = scope_Values[index];\r\n                var increment = nearbySteps.thisStep.step;\r\n                var decrement = null;\r\n    \r\n                // If the next value in this step moves into the next step,\r\n                // the increment is the start of the next step - the current value\r\n                if ( increment !== false ) {\r\n                    if ( value + increment > nearbySteps.stepAfter.startValue ) {\r\n                        increment = nearbySteps.stepAfter.startValue - value;\r\n                    }\r\n                }\r\n    \r\n    \r\n                // If the value is beyond the starting point\r\n                if ( value > nearbySteps.thisStep.startValue ) {\r\n                    decrement = nearbySteps.thisStep.step;\r\n                }\r\n    \r\n                else if ( nearbySteps.stepBefore.step === false ) {\r\n                    decrement = false;\r\n                }\r\n    \r\n                // If a handle is at the start of a step, it always steps back into the previous step first\r\n                else {\r\n                    decrement = value - nearbySteps.stepBefore.highestStep;\r\n                }\r\n    \r\n    \r\n                // Now, if at the slider edges, there is not in/decrement\r\n                if ( location === 100 ) {\r\n                    increment = null;\r\n                }\r\n    \r\n                else if ( location === 0 ) {\r\n                    decrement = null;\r\n                }\r\n    \r\n                // As per #391, the comparison for the decrement step can have some rounding issues.\r\n                var stepDecimals = scope_Spectrum.countStepDecimals();\r\n    \r\n                // Round per #391\r\n                if ( increment !== null && increment !== false ) {\r\n                    increment = Number(increment.toFixed(stepDecimals));\r\n                }\r\n    \r\n                if ( decrement !== null && decrement !== false ) {\r\n                    decrement = Number(decrement.toFixed(stepDecimals));\r\n                }\r\n    \r\n                return [decrement, increment];\r\n            });\r\n        }\r\n    \r\n        // Attach an event to this slider, possibly including a namespace\r\n        function bindEvent ( namespacedEvent, callback ) {\r\n            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n            scope_Events[namespacedEvent].push(callback);\r\n    \r\n            // If the event bound is 'update,' fire it immediately for all handles.\r\n            if ( namespacedEvent.split('.')[0] === 'update' ) {\r\n                scope_Handles.forEach(function(a, index){\r\n                    fireEvent('update', index);\r\n                });\r\n            }\r\n        }\r\n    \r\n        // Undo attachment of event\r\n        function removeEvent ( namespacedEvent ) {\r\n    \r\n            var event = namespacedEvent && namespacedEvent.split('.')[0];\r\n            var namespace = event && namespacedEvent.substring(event.length);\r\n    \r\n            Object.keys(scope_Events).forEach(function( bind ){\r\n    \r\n                var tEvent = bind.split('.')[0],\r\n                    tNamespace = bind.substring(tEvent.length);\r\n    \r\n                if ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {\r\n                    delete scope_Events[bind];\r\n                }\r\n            });\r\n        }\r\n    \r\n        // Updateable: margin, limit, padding, step, range, animate, snap\r\n        function updateOptions ( optionsToUpdate, fireSetEvent ) {\r\n    \r\n            // Spectrum is created using the range, snap, direction and step options.\r\n            // 'snap' and 'step' can be updated.\r\n            // If 'snap' and 'step' are not passed, they should remain unchanged.\r\n            var v = valueGet();\r\n    \r\n            var updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];\r\n    \r\n            // Only change options that we're actually passed to update.\r\n            updateAble.forEach(function(name){\r\n                if ( optionsToUpdate[name] !== undefined ) {\r\n                    originalOptions[name] = optionsToUpdate[name];\r\n                }\r\n            });\r\n    \r\n            var newOptions = testOptions(originalOptions);\r\n    \r\n            // Load new options into the slider state\r\n            updateAble.forEach(function(name){\r\n                if ( optionsToUpdate[name] !== undefined ) {\r\n                    options[name] = newOptions[name];\r\n                }\r\n            });\r\n    \r\n            scope_Spectrum = newOptions.spectrum;\r\n    \r\n            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\r\n            options.margin = newOptions.margin;\r\n            options.limit = newOptions.limit;\r\n            options.padding = newOptions.padding;\r\n    \r\n            // Update pips, removes existing.\r\n            if ( options.pips ) {\r\n                pips(options.pips);\r\n            }\r\n    \r\n            // Invalidate the current positioning so valueSet forces an update.\r\n            scope_Locations = [];\r\n            valueSet(optionsToUpdate.start || v, fireSetEvent);\r\n        }\r\n    \r\n        // Throw an error if the slider was already initialized.\r\n        if ( scope_Target.noUiSlider ) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): Slider was already initialized.\");\r\n        }\r\n    \r\n        // Create the base element, initialise HTML and set classes.\r\n        // Add handles and connect elements.\r\n        addSlider(scope_Target);\r\n        addElements(options.connect, scope_Base);\r\n    \r\n        scope_Self = {\r\n            destroy: destroy,\r\n            steps: getCurrentStep,\r\n            on: bindEvent,\r\n            off: removeEvent,\r\n            get: valueGet,\r\n            set: valueSet,\r\n            reset: valueReset,\r\n            // Exposed for unit testing, don't use this in your application.\r\n            __moveHandles: function(a, b, c) { moveHandles(a, b, scope_Locations, c); },\r\n            options: originalOptions, // Issue #600, #678\r\n            updateOptions: updateOptions,\r\n            target: scope_Target, // Issue #597\r\n            removePips: removePips,\r\n            pips: pips // Issue #594\r\n        };\r\n    \r\n        // Attach user events.\r\n        bindSliderEvents(options.events);\r\n    \r\n        // Use the public value method to set the start values.\r\n        valueSet(options.start);\r\n    \r\n        if ( options.pips ) {\r\n            pips(options.pips);\r\n        }\r\n    \r\n        if ( options.tooltips ) {\r\n            tooltips();\r\n        }\r\n    \r\n        aria();\r\n    \r\n        return scope_Self;\r\n    \r\n    }\r\n    \r\n    \r\n        // Run the standard initializer\r\n        function initialize ( target, originalOptions ) {\r\n    \r\n            if ( !target || !target.nodeName ) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): create requires a single element, got: \" + target);\r\n            }\r\n    \r\n            // Test the options and create the slider environment;\r\n            var options = testOptions( originalOptions, target );\r\n            var api = closure( target, options, originalOptions );\r\n    \r\n            target.noUiSlider = api;\r\n    \r\n            return api;\r\n        }\r\n    \r\n        // Use an object instead of a function for future expansibility;\r\n        return {\r\n            version: VERSION,\r\n            create: initialize\r\n        };\r\n    \r\n    }));",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/lib/noUiSlider/nouislider.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1020,
    "kind": "file",
    "name": "src/TemporalGisplayFinalV.js",
    "content": "import { Gisplay } from './Gisplay/Gisplay';\r\n\r\nmodule.exports = {\r\n\r\n\r\n    ////////////////POINTS\r\n    //usaaccidents GEOJSON (Dot Map)\r\n    usaaccidents: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Alcohol Involvement',\r\n                    externalName: 'f1',\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'fileAccidents',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Alcohol Involvement',\r\n                    mappingMethod: 'colorbrewer-qualitative'\r\n                    // mapping: [\r\n                    //     { value: \"Alcohol Involvement\", visual: \"red\" },\r\n                    //     { value: \"No Alcohol\", visual: \"blue\" }\r\n                    // ]\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsUSAOneBound = {\r\n            bounds: {\r\n                usa: { //USA\r\n                    NE: { lng: -57.578144, lat: 71.521815 },\r\n                    SW: { lng: -175.351582, lat: 4.205206 },\r\n                    description: 'Mainland USA'\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MB',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeDotMap(parsingOptions, variableUsage, globalOptionsUSAOneBound);\r\n    },\r\n\r\n    usa_accidents_figures: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Alcohol Involvement',\r\n                    externalName: 'f1',\r\n                },\r\n                {\r\n                    internalName: 'Number of deaths',\r\n                    externalName: 'f2'\r\n                    // values: [0, 23],\r\n                    // classBreakMethod: 'equalintervals'\r\n                }\r\n            ],\r\n            /* optionalVariables: [\r\n                {\r\n                    internalName: 'Tem alcool',\r\n                    externalName: 'f1',\r\n                },\r\n                {\r\n                    internalName: 'Num mortos',\r\n                    externalName: 'f2',\r\n                }\r\n            ], */\r\n            urls: {\r\n                dataURL: 'fileFigures',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            thematicInformation: {\r\n                orientation: {\r\n                    internalName: 'Alcohol Involvement',\r\n                    mapping: [\r\n                        { value: \"Alcohol Involvement\", visual: 0 },\r\n                        { value: \"No Alcohol\", visual: 50 }\r\n                    ]\r\n                },\r\n                color: {\r\n                    internalName: 'Number of deaths',\r\n                    // mapping: [\"#f03b20\", \"#2c7fb8\", \"#1c9099\"],\r\n                    // classBreaks: [0, 1, 2, 5, 23],\r\n                    numberOfClasses: 3,\r\n                    mappingMethod: 'colorbrewer-sequential',\r\n                    classBreaksMethod: 'quantiles'\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsUSA = {\r\n            bounds: {\r\n                usa: { //USA\r\n                    NE: { lng: -67.631836, lat: 48.57479 },\r\n                    SW: { lng: -123.793945, lat: 23.563987 }\r\n                },\r\n                alaska: { //Alaska\r\n                    NE: { lng: -138.427734, lat: 72.289067 },\r\n                    SW: { lng: -174.638672, lat: 50.176898 }\r\n                },\r\n                hawaii: { //Hawaii\r\n                    NE: { lng: -162.388916, lat: 17.056785 },\r\n                    SW: { lng: -153.4021, lat: 22.917923 }\r\n                }\r\n            },\r\n            layout: {\r\n                vertical: {\r\n                    sizes: [40, 60],\r\n                    descendants: [\r\n                        {\r\n                            horizontal: {\r\n                                sizes: [60, 40],\r\n                                descendants: [\"alaska\", \"hawaii\"]\r\n                            }\r\n                        },\r\n                        \"usa\"\r\n                    ]\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MB',\r\n            // provider: 'MBGL',\r\n            showLoader: true\r\n        };\r\n        Gisplay.makeFiguresMap(parsingOptions, variableUsage, globalOptionsUSA);\r\n    },\r\n\r\n    NYYellowColorShape: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Store flag',\r\n                    externalName: 'store_and_fwd_flag'\r\n                },\r\n                {\r\n                    internalName: 'Trip Distance',\r\n                    externalName: 'trip_distance',\r\n                },\r\n                {\r\n                    internalName: 'Latitude',\r\n                    externalName: 'pickup_latitude',\r\n                },\r\n                {\r\n                    internalName: 'Longitude',\r\n                    externalName: 'pickup_longitude',\r\n                },\r\n                {\r\n                    internalName: 'MTA Tax',\r\n                    externalName: 'mta_tax',\r\n                },\r\n                {\r\n                    internalName: 'Vendor ID',\r\n                    externalName: 'VendorID',\r\n                },\r\n                {\r\n                    internalName: 'Pickup Date',\r\n                    externalName: 'tpep_pickup_datetime',\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'csvTaxis1M'\r\n            },\r\n            csv: {\r\n                numWorkers: 4,\r\n                chunkSize: 1024 * 1024 * 10,\r\n            }\r\n        };\r\n\r\n        let variableUsage = {\r\n            spatialInformation: {\r\n                longitude: { internalName: 'Longitude' },\r\n                latitude: { internalName: 'Latitude' }\r\n            },\r\n            temporalInformation: {\r\n                internalName: 'Pickup Date',\r\n                granularity: 'month'\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Trip Distance',\r\n                    mappingMethod: 'colorbrewer-sequential',\r\n                    numberOfClasses: 3,\r\n                    // classBreaks: [0, 17.5, 47.5, 100]\r\n                    // classBreaks:  [0, 7.349999999999998, 18.450000000000024, 30],\r\n                    classBreaksMethod: 'quantiles'\r\n                    // mapping: [\"#ff0000\", \"#0000ff\", \"#0000ff\", \"#0000ff\", \"#0000ff\", \"#ff0000\", \"#ff0000\"],\r\n                },\r\n                shape: {\r\n                    internalName: 'Store flag',\r\n                    mapping:\r\n                        [\r\n                            { value: 'Y', visual: 'filled_square' },\r\n                            { value: 'N', visual: 'triangle' }\r\n                        ]\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsNYCity = {\r\n            bounds: {\r\n                ny: { //NY\r\n                    NE: { lng: -74.30809, lat: 40.604569 },\r\n                    SW: { lng: -73.727188, lat: 40.938414 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MBGL',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeDotMap(parsingOptions, variableUsage, globalOptionsNYCity);\r\n    },\r\n\r\n    NYYellowSize: function () { //PROP SYMBOLS\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Store flag',\r\n                    externalName: 'store_and_fwd_flag',\r\n                },\r\n                {\r\n                    internalName: 'Trip Distance',\r\n                    externalName: 'trip_distance',\r\n                },\r\n                {\r\n                    internalName: 'Pickup Date',\r\n                    externalName: 'tpep_pickup_datetime',\r\n                },\r\n                {\r\n                    internalName: 'Latitude',\r\n                    externalName: 'pickup_latitude',\r\n                },\r\n                {\r\n                    internalName: 'Longitude',\r\n                    externalName: 'pickup_longitude',\r\n                },\r\n                {\r\n                    internalName: 'MTA Tax',\r\n                    externalName: 'mta_tax',\r\n                },\r\n                {\r\n                    internalName: 'Vendor ID',\r\n                    externalName: 'VendorID',\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'csvTaxis1MProp',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            spatialInformation: {\r\n                longitude: { internalName: 'Longitude' },\r\n                latitude: { internalName: 'Latitude' }\r\n            },\r\n            temporalInformation: {\r\n                internalName: 'Pickup Date',\r\n                granularity: 'year'\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Store flag',\r\n                    mapping: [\r\n                        { value: \"Y\", visual: \"red\" },\r\n                        { value: \"N\", visual: \"blue\" }\r\n                    ]\r\n                    // mapping: [\"red\", \"blue\"],\r\n                },\r\n                size: {\r\n                    internalName: 'Trip Distance',\r\n                    mapping: [15, 40, 100],\r\n                    classBreaksMethod: 'quantiles'\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsNYCity = {\r\n            bounds: {\r\n                ny: {\r\n                    NE: { lng: -74.30809, lat: 40.604569 },\r\n                    SW: { lng: -73.727188, lat: 40.938414 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'GM',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeProportionalSymbolsMap(parsingOptions, variableUsage, globalOptionsNYCity);\r\n    },\r\n\r\n    usaaccidents_by_county_centroid: function () { //PROP SYMBOLS\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Number of deaths',\r\n                    externalName: 'f1',\r\n                    // values: [1, 8587],\r\n                    // classBreakMethod: 'quantiles'\r\n                    // classBreaks: [0, 1, 20, 23]\r\n                },\r\n                {\r\n                    internalName: 'State',\r\n                    externalName: 'f2',\r\n                },\r\n                {\r\n                    internalName: 'County',\r\n                    externalName: 'f3',\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'fileCentroid',\r\n            }\r\n        };\r\n        let mappingOptions = {\r\n            thematicInformation: {\r\n                size: {\r\n                    internalName: 'Number of deaths',\r\n                    mapping: [30, 50, 100],\r\n                    classBreaksMethod: 'quantiles'\r\n                }\r\n            }\r\n        };\r\n        \r\n        let globalOptionsUSAOneBound = {\r\n            bounds: {\r\n                usa: { //USA\r\n                    NE: { lng: -57.578144, lat: 71.521815 },\r\n                    SW: { lng: -175.351582, lat: 4.205206 },\r\n                    description: 'Mainland USA'\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'HM',\r\n            showLoader: true\r\n        };\r\n        Gisplay.makeProportionalSymbolsMap(parsingOptions, mappingOptions, globalOptionsUSAOneBound);\r\n    },\r\n\r\n    NYTrees: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Latitude da arvore',\r\n                    externalName: 'Latitude'\r\n                },\r\n                {\r\n                    internalName: 'Longitude da arvore',\r\n                    externalName: 'longitude'\r\n                },\r\n                {\r\n                    internalName: 'Tree Status',\r\n                    externalName: 'status'\r\n                },\r\n                /*  {\r\n                     internalName: 'Saude da arvore',\r\n                     externalName: 'health'\r\n                 },\r\n                 {\r\n                     internalName: 'Especie',\r\n                     externalName: 'spc_latin'\r\n                 }, */\r\n                /*  {\r\n                     internalName: 'Problemas da arvore',\r\n                     externalName: 'problems'\r\n                 }, */\r\n                /* {\r\n                    internalName: 'SideWalk',\r\n                    externalName: 'sidewalk'\r\n                }, */\r\n            ],\r\n            urls: {\r\n                dataURL: 'nytrees'\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            spatialInformation: {\r\n                longitude: { internalName: 'Longitude da arvore' },\r\n                latitude: { internalName: 'Latitude da arvore' }\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Tree Status',\r\n                    mappingMethod: 'colorbrewer-qualitative'\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsNYCity = {\r\n            bounds: {\r\n                ny: {\r\n                    NE: { lng: -74.30809, lat: 40.604569 },\r\n                    SW: { lng: -73.727188, lat: 40.938414 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'GM',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeDotMap(parsingOptions, variableUsage, globalOptionsNYCity);\r\n    },\r\n\r\n    PTPulmonia: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Gnero',\r\n                    externalName: 'gender',\r\n                },\r\n                /* {\r\n                    internalName: 'Idade do paciente',\r\n                    externalName: 'age',\r\n                    values: [0, 102],\r\n                    numberOfClasses: 5\r\n                }, */\r\n                {\r\n                    internalName: 'Ano do caso de pneumonia',\r\n                    externalName: 'year',\r\n                },\r\n                {\r\n                    internalName: 'Latitude',\r\n                    externalName: 'latitudeParish',\r\n                },\r\n                {\r\n                    internalName: 'Longitude',\r\n                    externalName: 'LongitudeParish',\r\n                }\r\n            ],\r\n            optionalVariables: [\r\n                {\r\n                    internalName: 'Dias de admisso',\r\n                    externalName: 'admissionDaysClass',\r\n                },\r\n                {\r\n                    internalName: 'Nome Hospital',\r\n                    externalName: 'desigHospital',\r\n                }/* ,\r\n                {\r\n                    internalName: 'Ano do caso de pulmonia',\r\n                    externalName: 'year',\r\n                } */\r\n            ],\r\n            urls: {\r\n                dataURL: 'ptPulmonia',\r\n            },\r\n        };\r\n        let variableUsage = {\r\n            temporalInformation: {\r\n                internalName: 'Ano do caso de pneumonia',\r\n                granularity: 'year',\r\n            },\r\n            spatialInformation: {\r\n                longitude: { internalName: 'Longitude' },\r\n                latitude: { internalName: 'Latitude' }\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Gnero',\r\n                    mappingMethod: 'colorbrewer-qualitative'\r\n                    /*   mapping: [\r\n                          { value: \"M\", visual: \"blue\" },\r\n                          { value: \"F\", visual: \"pink\" }\r\n                      ], */\r\n                    // values: [\"M\", \"F\"]\r\n                }\r\n            }\r\n            /*  shape: {\r\n                 externalName: 'age',\r\n                 mapping: {\r\n                     \"M\": \"square\",\r\n                     \"F\": \"circlefull\",\r\n                 },\r\n             } */\r\n        };\r\n\r\n        let globalOptionsPortugalLXPorto = {\r\n            bounds: {\r\n                pt: { //PT\r\n                    NE: { lng: -4.954834, lat: 42.666281 },\r\n                    SW: { lng: -10.953369, lat: 35.406961 },\r\n                    description: 'Portugal Continental'\r\n                },\r\n                lx: { //Lisboa\r\n                    NE: { lng: -8.915405, lat: 39.047956 },\r\n                    SW: { lng: -9.560852, lat: 38.62757 },\r\n                    description: 'Portugal Continental'\r\n                },\r\n                porto: { //Porto\r\n                    NE: { lng: -8.520584, lat: 41.238046 },\r\n                    SW: { lng: -8.736877, lat: 41.071069 },\r\n                    description: 'Portugal Continental'\r\n                }\r\n            },\r\n            layout: {\r\n                vertical: {\r\n                    sizes: [40, 60],\r\n                    descendants: [\r\n                        {\r\n                            horizontal: {\r\n                                sizes: [50, 50],\r\n                                descendants: [\"porto\", \"lx\"]\r\n                            }\r\n                        },\r\n                        \"pt\"\r\n                    ]\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MBGL',\r\n            showLoader: true,\r\n            timeControl: 'interval'\r\n        };\r\n        Gisplay.makeDotMap(parsingOptions, variableUsage, globalOptionsPortugalLXPorto);\r\n    },\r\n\r\n    //////////// POLYGONS\r\n    usaaccidents_by_county: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Number of deaths',\r\n                    externalName: 'f3'\r\n                },\r\n                {\r\n                    internalName: 'State',\r\n                    externalName: 'f1',\r\n                },\r\n                {\r\n                    internalName: 'County',\r\n                    externalName: 'f2',\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'choroplethByCounty',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Number of deaths',\r\n                    mapping: [\"#ece7f2\", \"#a6bddb\", \"#2b8cbe\"],\r\n                    classBreaksMethod: 'quantiles'\r\n                    // mappingMethod: 'colorbrewer-qualitative'\r\n                    // mapping: [\r\n                    //     { value: \"Alcohol Involvement\", visual: \"red\" },\r\n                    //     { value: \"No Alcohol\", visual: \"blue\" }\r\n                    // ]\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsUSA = {\r\n            bounds: {\r\n                usa: { //USA\r\n                    NE: { lng: -67.631836, lat: 48.57479 },\r\n                    SW: { lng: -123.793945, lat: 23.563987 }\r\n                },\r\n                alaska: { //Alaska\r\n                    NE: { lng: -138.427734, lat: 72.289067 },\r\n                    SW: { lng: -174.638672, lat: 50.176898 }\r\n                },\r\n                hawaii: { //Hawaii\r\n                    NE: { lng: -162.388916, lat: 17.056785 },\r\n                    SW: { lng: -153.4021, lat: 22.917923 }\r\n                }\r\n            },\r\n            layout: {\r\n                vertical: {\r\n                    sizes: [40, 60],\r\n                    descendants: [\r\n                        {\r\n                            horizontal: {\r\n                                sizes: [60, 40],\r\n                                descendants: [\"alaska\", \"hawaii\"]\r\n                            }\r\n                        },\r\n                        \"usa\"\r\n                    ]\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MB',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeChoropleth(parsingOptions, variableUsage, globalOptionsUSA);\r\n    },\r\n\r\n    //texture\r\n    crimes_frequent_com_areas: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    /*      internalName: 'Amount stolen',\r\n                         externalName: 'f3',\r\n                         values: [1, 8587],\r\n                         classBreakMethod: 'quantiles' */\r\n                    internalName: 'Type of robbery',\r\n                    externalName: 'f2'\r\n                    // values: ['THEFT', 'BATTERY', 'NARCOTICS']\r\n                },\r\n                {\r\n                    internalName: 'Amount stolen',\r\n                    externalName: 'f3',\r\n                    // values: [35, 3395]\r\n                },\r\n                {\r\n                    internalName: 'Conty',\r\n                    externalName: 'f1',\r\n                },\r\n                {\r\n                    internalName: 'Amount stolen',\r\n                    externalName: 'f3',\r\n                }\r\n            ],\r\n            /* optionalVariables: [\r\n                {\r\n                    internalName: 'Conty',\r\n                    externalName: 'f1',\r\n                },\r\n                {\r\n                    internalName: 'Amount stolen',\r\n                    externalName: 'f3',\r\n                }\r\n            ], */\r\n            urls: {\r\n                dataURL: 'crimesFreqComAreas',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            thematicInformation: {\r\n                texture: {\r\n                    internalName: 'Type of robbery',\r\n                    mapping: [\r\n                        { value: \"THEFT\", visual: 'crossPattern' },\r\n                        { value: \"BATTERY\", visual: 'plusPattern' },\r\n                        { value: \"NARCOTICS\", visual: 'wavePattern' },\r\n                    ]\r\n                },\r\n                color: {\r\n                    internalName: 'Amount stolen',\r\n                    mappingMethod: 'colorbrewer-sequential',\r\n                    classBreaksMethod: 'quantiles'\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsUSA = {\r\n            bounds: {\r\n                world: {\r\n                    NE: { lng: -86.82312, lat: 42.823498 },\r\n                    SW: { lng: -89.27124, lat: 40.771991 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MB',\r\n            showLoader: true\r\n        };\r\n        Gisplay.makeChoropleth(parsingOptions, variableUsage, globalOptionsUSA);\r\n    },\r\n\r\n    //WITH IDS\r\n    IDsDistritosPT: function () { //DUMMY DATA\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Nmero de acidentes',\r\n                    externalName: 'Num_Accidents'\r\n                    // values: [10, 222]\r\n                },\r\n                {\r\n                    internalName: 'Identificador do distrito',\r\n                    externalName: 'ID_District'\r\n                },\r\n                {\r\n                    internalName: 'Ano dos acidentes',\r\n                    externalName: 'Year'\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'data',\r\n                geospatialURL: 'distritos',\r\n                idOnDataURL: 'ID_District',\r\n                idOnGeoSpatialURL: 'ID_1'\r\n            },\r\n            /*   time: {\r\n                  internalName: 'Ano dos acidentes',\r\n                  externalName: 'Year',\r\n                  granularity: 'year',\r\n              } */\r\n        };\r\n        let variableUsage = {\r\n            temporalInformation: {\r\n                internalName: 'Ano dos acidentes',\r\n                granularity: 'year'\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Nmero de acidentes',\r\n                    mappingMethod: 'colorbrewer-sequential',\r\n                    classBreaksMethod: 'quantiles',\r\n                    // classBreaks: [40, 70, 222]\r\n                    // mapping: [\"#000000\", \"#a1b2c3\"],\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsPortugal = {\r\n            bounds: {\r\n                pt: { //PT\r\n                    NE: { lng: -4.954834, lat: 42.666281 },\r\n                    SW: { lng: -10.953369, lat: 35.406961 }\r\n                },\r\n                acores: { //Acores\r\n                    NE: { lng: -23.543701, lat: 40.430224 },\r\n                    SW: { lng: -32.794189, lat: 35.406961 }\r\n                },\r\n                madeira: { //PT\r\n                    NE: { lng: -15.477848, lat: 33.770015 },\r\n                    SW: { lng: -17.784977, lat: 31.830899 }\r\n                }\r\n            },\r\n            layout: {\r\n                vertical: {\r\n                    sizes: [40, 60],\r\n                    descendants: [\r\n                        {\r\n                            horizontal: {\r\n                                sizes: [60, 40],\r\n                                descendants: [\"acores\", \"madeira\"]\r\n                            }\r\n                        },\r\n                        \"pt\"\r\n                    ]\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'GM',\r\n            showLoader: true\r\n        };\r\n\r\n        Gisplay.makeChoropleth(parsingOptions, variableUsage, globalOptionsPortugal/* globalOptionsPortugalContinental */);\r\n    },\r\n\r\n    //WITH IDS\r\n    allCountriesEmploymentRate15_24: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Employment 15 to 24 yo (%)',\r\n                    externalName: 'aged_15_24_employment_rate_percent'\r\n                },\r\n                {\r\n                    internalName: 'Country',\r\n                    externalName: 'geo',\r\n                },\r\n                {\r\n                    internalName: 'Ano',\r\n                    externalName: 'time',\r\n                }\r\n            ],\r\n            urls: { //geo,time,annual_hiv_deaths_number_all_ages\r\n                dataURL: 'employmentFileCSV',\r\n                geospatialURL: 'worldFile2',\r\n                idOnDataURL: 'geo',\r\n                idOnGeoSpatialURL: 'ISO_A3'\r\n            }\r\n        };\r\n        let variableUsage = { //geo,time,aged_15_24_employment_rate_percent\r\n            temporalInformation: {\r\n                internalName: 'Ano',\r\n                granularity: 'year'\r\n            },\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Employment 15 to 24 yo (%)',\r\n                    classBreaksMethod: 'quantiles',\r\n                    mappingMethod: 'colorbrewer-sequential'\r\n                    // classBreaks: [11.3, 18.99, ]\r\n                    // mapping: [\"#000000\", \"#a1b2c3\"],\r\n                    // values: [11.3, 81.2],\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalOptionsWorld = {\r\n            bounds: {\r\n                world: {\r\n                    NE: { lng: 180, lat: 90 },\r\n                    SW: { lng: -180, lat: -90 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'GM',\r\n            showLoader: true\r\n        };\r\n        Gisplay.makeChoropleth(parsingOptions, variableUsage, globalOptionsWorld);\r\n    },\r\n\r\n    //////////// LINES\r\n    worldRoads: function () {\r\n        let parsingOptions = {\r\n            variableDeclarations: [\r\n                {\r\n                    internalName: 'Tipo de via',\r\n                    externalName: 'type',\r\n                    // values: [10, 1000]\r\n                    // values: ['Secondary Highway', 'Major Highway', 'Ferry Route', 'Beltway', 'Bypass', 'Road', 'Ferry, seasonal', 'Unknown', 'Track']\r\n                }\r\n            ],\r\n            urls: {\r\n                dataURL: 'worldLines',\r\n            }\r\n        };\r\n        let variableUsage = {\r\n            thematicInformation: {\r\n                color: {\r\n                    internalName: 'Tipo de via',\r\n                    mappingMethod: 'colorbrewer-qualitative'\r\n                    /*  mapping: [\r\n                          { value: 'Secondary Highway', visual: 'red' },\r\n                          { value: 'Major Highway', visual: 'pink' },\r\n                          { value: 'Ferry Route', visual: 'blue', },\r\n                          { value: 'Beltway', visual: 'orange' },\r\n                          { value: 'Bypass', visual: 'navy' },\r\n                          { value: 'Road', visual: 'tomato' },\r\n                          { value: 'Ferry, seasonal', visual: 'green' },\r\n                          { value: 'Unknown', visual: 'yellow' },\r\n                          { value: 'Track', visual: 'brown' }\r\n                      ] */\r\n\r\n                    // values: ['Secondary Highway', 'Major Highway', 'Ferry Route', 'Beltway', 'Bypass', 'Road', 'Ferry, seasonal', 'Unknown', 'Track']\r\n                    // mapping: [\"red\", \"blue\"],\r\n                }\r\n            }\r\n        };\r\n\r\n        let globalWorldOpts = {\r\n            bounds: {\r\n                world: { //\r\n                    NE: { lng: 180, lat: 90 },\r\n                    SW: { lng: -180, lat: -90 }\r\n                }\r\n            },\r\n            container: 'gisplay2',\r\n            provider: 'MBGL',\r\n            showLoader: true\r\n        };\r\n        Gisplay.makeLinesMap(parsingOptions, variableUsage, globalWorldOpts);\r\n    },\r\n};\r\n\r\n",
    "static": true,
    "longname": "C:/Users/Sysop/Desktop/All Tests/Testes4/20 01 2018/gisplayv2/ES6/src/TemporalGisplayFinalV.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "Aqui vai estar o cdigo para a API Gisplay v2. Esta verso conter alguns melhoramentos da API anterior e ser adicionada a componente temporal  mesma.\r\n\r\n---\r\n# **Instalao**\r\n1. Instalar [node.js](https://nodejs.org/en/)\r\n2. Aps esta instalao fazer clone deste projeto com o git: ```git clone https://rr_alves@bitbucket.org/Gisplay_Team/gisplayv2.git ```\r\n3. Navegar para a pasta do projeto (```cd gisplayv2```)\r\n4. Executar os seguintes comandos por esta ordem:\r\n    - ```npm i```\r\n    - ```npm start```\r\n5. Abrir o ficheiro index.html da pasta dist num browser atualizado(Opera, Chrome, Firefox).\r\n\r\nOU\r\n\r\n1. Instalar [node.js](https://nodejs.org/en/)\r\n2. Executar o seguinte comando\r\n\r\n    > **Windows**: ```git clone https://rr_alves@bitbucket.org/Gisplay_Team/gisplayv2.git; cd ./gisplayv2/ES6; npm i; npm start```\r\n\r\n    > **OSX?/Linux**: ```git clone https://rr_alves@bitbucket.org/Gisplay_Team/gisplayv2.git && cd ./gisplayv2/ES6 && npm i && npm start```\r\n\r\n3. Abrir o ficheiro index.html da pasta dist num browser atualizado(Opera, Chrome, Firefox).\r\n\r\n\r\n# **Demos**\r\n\r\nDemos podem ser vistos em: [ Rui Alves GitHub Online page. ]( https://iursevla.github.io/gisplayv2Demos/)\r\n\r\nEstes sero atualizados automaticamente quando for corrido o comando \r\n```\r\n> node shell.js\r\n```\r\n\r\n# **Tools Used**\r\n\r\n| Nome          | Uso                            |URLs                            |\r\n| ------------- | ------------------------------ |------------------------------ |\r\n| `1.webpack2`     | **Bundle de todo o cdigo.**       | [webpack.js](https://webpack.js.org) + [github](https://github.com/webpack/webpack)|\r\n| `2.shelljs`     | **Executar comandos nativos c/ JS**     |[shelljs.org](http://shelljs.org) +   [github](https://github.com/shelljs/shelljs)|\r\n| `3.VSCode`      | **IDE utilizado**     |[vscode](https://code.visualstudio.com) + [extensions](https://marketplace.visualstudio.com/VSCode)|\r\n| `4.Mocha Ou Karma`      | **Test JS code**     | [mochajs](https://mochajs.org) + [Karma]() ?|\r\n| `5.Chrome Profiler for GPU and CPU`      | **Profiling code**     | [GPU Memory Tracing Chromium](https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/probe-gpu.md)|\r\n| `6.ESDoc`      | **Document Code**     | [ESDoc](https://esdoc.org) + [GitHub](https://github.com/esdoc/esdoc) |\r\n\r\n## **1.webpack2** \r\n~~~~\r\nFazer bundling do codigo e passar de ES2015 para o browser(criando um nico ficheiro gisplayv2.bundle.js)\r\n~~~~\r\n  > * [babel-loader](https://github.com/babel/babel-loader) - Load files ES2015 e transformar para o browser. \r\n  \r\n  > * [mocha-webpack](https://www.npmjs.com/package/mocha-webpack) - Unit Test (Not used atm)\r\n  \r\n\r\n  > *  [Tutorial Mocha](https://medium.com/caffeine-and-testing/testing-es6-modules-with-mocha-using-babel-with-browserify-e6f5514f66d3#.sm859e5om) \r\n\r\n  > * [Testing with webpack2](https://cafedev.org/article/2016/12/testing-with-wepack-2-inject-loader-karma-mocha-chai-and-sinon/) - Como correr Unit Tests no webpack2.\r\n\r\n## **2. shelljs** \r\n~~~~\r\nAutomaticamente correr comandos para fazer commit para o repositrio github dos Demos\r\n\r\nBasicamente permite executar comandos nativos (e.g., ls, dir, rm) em qualquer SO(Windows, Linux, OSX) atravs de javascript.\r\n\r\nNo caso deste repositrio, no ficheiro shell.js  possvel ver que este faz a cpia do ficheiro index.html e do ficheiro gisplayv2.bundle.js para a pasta do repositrio github pages que criei. Depois faz commit e push para esse mesmo repositorio online.\r\n\r\nUsando o github pages permite aceder online aos demos que forem sendo criados (O link est na pagina me deste repositorio). \r\n~~~~\r\n\r\n\r\n## **3. VSCode IDE** \r\n~~~~\r\nBom IDE para JS, TS. Particularmente linguagens web funciona muito bem.\r\n~~~~\r\n- [Debbuger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome) - Debug your JavaScript code in the Chrome browser, or any other target that supports the Chrome Debugger protocol.\r\n\r\n- [open in browser](https://marketplace.visualstudio.com/items?itemName=techer.open-in-browser) - Open index.html file in any installed browser.\r\n\r\n- [Complete JSDoc Tags](https://marketplace.visualstudio.com/items?itemName=HookyQR.JSDocTagComplete) - Autocomplete JSDoc Tags.\r\n## **4. Testing** \r\n~~~\r\n Mochajs\r\n~~~\r\n > * [Use ES6 files on Mocha](http://krasimirtsonev.com/blog/article/using-mocha-with-es6-spec-files)\r\n > * [Write simple Tests with Mocha in JS](https://www.youtube.com/watch?v=oW8uHfe8Jyk)\r\n > * [Mocha instalation](https://mochajs.org/#installation)\r\n\r\nOs passos abaixo no necessitam de ser feitos se tiverem sido seguidos os passos iniciais de instalao.\r\n1. ```npm i -g mocha```\r\n2. ```npm i -D mocha```\r\n3. ```npm i -D chai```\r\n4. Package.json add: ```\"test\": \"mocha --compilers js:babel-core/register ./test/**/*.js\"```\r\n5. Criar babel.rc file com: ```{ \"presets\": [\"es2015\"] }```\r\n6. Criar pasta test e la dentro colocar o(s) ficheiros(.js) de teste.\r\n7. ```npm test```\r\n\r\n\r\n## **5. Profiling** \r\n1.  [\r\nChrome DevTools: JavaScript CPU Profiling in Chrome 58](https://developers.google.com/web/updates/2016/12/devtools-javascript-cpu-profile-migration) \r\n2. [MemoryInfra](https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/README.md) - Tool integrated in Chromium/Chrome/Opera\r\n3. [GPU](https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/probe-gpu.md)\r\n\r\n## **6. Documentation** \r\nUsar [ESDoc](https://esdoc.org). Permite ainda usar Mocha para testes.\r\n\r\nVer [Integration Test Codes](https://esdoc.org/manual/usage/feature.html#integration-test-codes).\r\n\r\nVer resultado final [ESDoc Test](https://doc.esdoc.org/github.com/esdoc/esdoc/test.html)\r\n\r\n---\r\n\r\n# **Fases**\r\n1. Modificar API corrente de modo a resolver problemas pertinentes. **06/03 - 03/04** (Ver abaixo)  \r\n2. Reformulao da API tendo em conta a componente temporal\r\n3. Implementao.\r\n4. Avaliao comparativa.\r\n5. Escrita do documento final.\r\n",
    "longname": "C:\\Users\\Sysop\\Desktop\\All Tests\\Testes4\\20 01 2018\\gisplayv2\\ES6\\README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\r\n  \"name\": \"gisplay-es6-webpack\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"Gisplay with ES6 version using webpack.\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"start\": \"webpack -d --watch\",\r\n    \"prod\": \"webpack -p\",\r\n    \"test\": \"mocha --compilers js:babel-core/register ./test/**/*.js\"\r\n  },\r\n  \"author\": \"Rui Alves\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"esdoc\": \"^1.0.3\",\r\n    \"esdoc-standard-plugin\": \"^1.0.0\",\r\n    \"light-server\": \"^2.2.1\",\r\n    \"merge-images\": \"^1.0.5\",\r\n    \"raw-loader\": \"^0.5.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"babel-core\": \"^6.23.1\",\r\n    \"babel-loader\": \"^6.4.0\",\r\n    \"babel-preset-env\": \"^1.2.1\",\r\n    \"babel-preset-es2015\": \"^6.24.0\",\r\n    \"chai\": \"^3.5.0\",\r\n    \"copy-webpack-plugin\": \"^4.0.1\",\r\n    \"css-hot-loader\": \"^1.3.1\",\r\n    \"css-loader\": \"^0.28.7\",\r\n    \"eslint\": \"^3.18.0\",\r\n    \"extract-text-webpack-plugin\": \"^3.0.0\",\r\n    \"file-loader\": \"^0.11.2\",\r\n    \"html-webpack-plugin\": \"^2.28.0\",\r\n    \"live-server\": \"^1.2.0\",\r\n    \"loader-utils\": \"^1.1.0\",\r\n    \"mocha\": \"^3.2.0\",\r\n    \"shelljs\": \"^0.7.7\",\r\n    \"style-loader\": \"^0.18.2\",\r\n    \"webpack\": \"^2.2.1\",\r\n    \"worker-loader\": \"^0.8.0\"\r\n  }\r\n}\r\n",
    "longname": "C:\\Users\\Sysop\\Desktop\\All Tests\\Testes4\\20 01 2018\\gisplayv2\\ES6\\package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]
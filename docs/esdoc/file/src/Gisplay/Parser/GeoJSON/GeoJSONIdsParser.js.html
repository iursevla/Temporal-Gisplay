<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js | gisplay-es6-webpack</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Gisplay with ES6 version using webpack."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="gisplay-es6-webpack"><meta property="twitter:description" content="Gisplay with ES6 version using webpack."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay">Gisplay</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Gisplay.js~Gisplay.html">Gisplay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayDefaults.js~GisplayDefaults.html">GisplayDefaults</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayDynamicLoader.js~GisplayDynamicLoader.html">GisplayDynamicLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayError.js~GisplayError.html">GisplayError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayErrorChecker.js~GisplayErrorChecker.html">GisplayErrorChecker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/GisplayOptions.js~GisplayOptions.html">GisplayOptions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-helpers">Gisplay/Helpers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Helpers/ColorBrewer.js~ColorBrewer.html">ColorBrewer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Helpers/WebGLUtils.js~WebGLUtils.html">WebGLUtils</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-maps">Gisplay/Maps</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/ChangeMap.js~ChangeMap.html">ChangeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Choropleth.js~Choropleth.html">Choropleth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/DotMap.js~DotMap.html">DotMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/FiguresMap.js~FiguresMap.html">FiguresMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/GisplayMap.js~GisplayMap.html">GisplayMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/LinesMap.js~LinesMap.html">LinesMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap.html">ProportionalSymbolsMap</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-maps-background-maps">Gisplay/Maps/Background Maps</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapBingMaps.js~BGMapBingMaps.html">BGMapBingMaps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapGoogleMaps.js~BGMapGoogleMaps.html">BGMapGoogleMaps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapHereMaps.js~BGMapHereMaps.html">BGMapHereMaps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapMapBox.js~BGMapMapBox.html">BGMapMapBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapMapBoxGLJS.js~BGMapMapBoxGLJS.html">BGMapMapBoxGLJS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Background Maps/BGMapWrapper.js~BGMapWrapper.html">BGMapWrapper</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-parser">Gisplay/Parser</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Parser/Parser.js~Parser.html">Parser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-parser-csv">Gisplay/Parser/CSV</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Parser/CSV/CSVParser.js~CSVParser.html">CSVParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-parser-geojson">Gisplay/Parser/GeoJSON</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js~GeoJSONIdsParser.html">GeoJSONIdsParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Parser/GeoJSON/GeoJSONParser.js~GeoJSONParser.html">GeoJSONParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-shaders">Gisplay/Shaders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Shaders/ShadersInfo.js~ShadersInfo.html">ShadersInfo</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gisplay-vvs">Gisplay/VVs</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/CategoricalVariable.js~CategoricalVariable.html">CategoricalVariable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/ContinuousVariable.js~ContinuousVariable.html">ContinuousVariable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/DataVariable.js~DataVariable.html">DataVariable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/MapVariable.js~MapVariable.html">MapVariable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/MapVariableCombination.js~MapVariableCombination.html">MapVariableCombination</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/Picking.js~WebGLPicking.html">WebGLPicking</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/TemporalGranule.js~TemporalGranule.html">TemporalGranule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/TimeVariable.js~TimeVariable.html">TimeVariable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/VVs/URLVariable.js~URLVariable.html">URLVariable</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Gisplay/Parser/GeoJSON/GeoJSONIdsParser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { GisplayDefaults } from &apos;../../GisplayDefaults&apos;;

const earcut = require(&apos;../../../lib/earcut&apos;);
// import { earcut } from &apos;../../../lib/earcut&apos;;
// import earcut from &apos;script-loader!../../../lib/earcut&apos;;

/**
 * GeoJSONIds Parser.
 * @export
 * @class GeoJSONIdsParser
 */
export class GeoJSONIdsParser {

    /**
     * Creates an instance of GeoJSONIdsParser.
     * @param {Blob} geoSpatialURL - The file to read and process. 
     * @param {string} geoSpatialId - The id of the geometry on the geospatial file.
     * @param {WebGLRenderingContext} webgl - The WebGLRenderingContext.
     * @memberof GeoJSONIdsParser
     */
    constructor(geoSpatialURL, geoSpatialId, webgl) {
        /**
         * The id of the geometry on the geospatial file.
         * @type {string}
         */
        this.geoSpatialId = geoSpatialId;
        /**
         * The WebGL Rendering context.
         * @type {WebGLRenderingContext}
         */
        this.webglContext = webgl;
        /**
         * The initial index for the polygon or line.
         * @type {number}
         */
        this.initialIndex = 0;
        /**
         * The color number to be used for each polygon/line/point that is read from the file.
         * @type {number}
         */
        this.RGBAColorNumber = 1;
        /** 
         * An array that holds all points for all polygons/lines. 
         * @type {Array&lt;number&gt;|WebGLBuffer}
         */
        this.allPoints = [];
        /** 
         * An array that holds all colors for all polygons/lines. One color for each vertex.
         * @type {Array&lt;number&gt;|WebGLBuffer}
         */
        this.allColors = [];

        /** 
         * The identifier of the type of primitive (Point, polygon or line).
         * @type {number}
         */
        this.geometryPrimitive;
        /**
         * The Filereader.
         * @type {FileReader}
         */
        this.reader = this.createFileReader();
        this.reader.readAsText(geoSpatialURL);
    }

    /**
     * Creates a FileReader object and adds the load and error events.
     * @returns {FileReader} - The Filereader object which will be used to read from the file.
     * @memberof GeoJSONIdsParser
     */
    createFileReader() {
        let reader = new FileReader();
        reader.onloadend = (e) =&gt; { this.processFile(e.target.result); };
        reader.onerror = (e) =&gt; { console.error(e); };
        return reader;
    }

    /**
     * Process the GeoJSON file.
     * @param {Object} fileData - The GeoJSON data that was read from the file. 
     * @memberof GeoJSONIdsParser
     */
    processFile(fileData) {
        let geojson = JSON.parse(fileData);
        console.log(geojson);
        console.time(&quot;geojsonIdsParser&quot;);
        let geometryIdsMap = new Map();
        for (let feature of geojson.features)
            geometryIdsMap.set(feature.properties[this.geoSpatialId], this.processFeature(feature));
        // this.endParser(geometryIdsMap);

        if (GisplayDefaults.hasPolygons(this.geometryPrimitive) || GisplayDefaults.hasLines(this.geometryPrimitive)) { //POLYGON OR LINES
            this.joinAllPoints();
            this.joinAllColors();
        }

        console.log(geometryIdsMap);
        this.dispatchIdGeometryEndEvent(geometryIdsMap);
        console.timeEnd(&quot;geojsonIdsParser&quot;);
    }

    /**
     * Process point or polygon.
     * @param {Object} feature - The feature to process.
     * @returns {Polygon|Array&lt;number&gt;} - The processed polygon or the point coordinates.
     * @memberof GeoJSONIdsParser
     */
    processFeature(feature) {
        if (this.geometryPrimitive === undefined)
            this._setGeometryPrimitive(feature.geometry.type);

        if (feature.geometry.type === &apos;Polygon&apos; || feature.geometry.type === &apos;MultiPolygon&apos;) {
            return this.processPolygon(feature);
        } else if (feature.geometry.type === &apos;Point&apos;) {
            return this.processPoint(feature);
        } else if (feature.geometry.type === &apos;LineString&apos; || feature.geometry.type === &apos;MultiLineString&apos;) {
            return this.processLine(feature);
        }
        else
            throw new Error(&quot;GeoJSON feature is not a Polygon, a Point or a Line&quot;);
    }

    /**
     * Set the type of geometry primitive for the data read. Only need to be called once. 
     * @param {string} geometryType - The type of geometry. 
     * @memberof GeoJSONParser
     */
    _setGeometryPrimitive(geometryType) {
        switch (geometryType) {
            case &apos;Point&apos;:
                this.geometryPrimitive = GisplayDefaults.getPrimitive().POINT;
                break;
            case &apos;Polygon&apos;:
            case &apos;MultiPolygon&apos;:
                this.geometryPrimitive = GisplayDefaults.getPrimitive().POLYGON;
                break;
            case &apos;LineString&apos;:
            case &apos;MultiLineString&apos;:
                this.geometryPrimitive = GisplayDefaults.getPrimitive().LINE;
                break;
        }
    }

    /**
     * Returns the point and it&apos;s RGBA color.
     * @param {{geometry: JSON, properties: JSON}} point - The geometry and properties of the point.
     * @returns {{spatial: {lineIndices:Array&lt;number&gt;}, RGBA:Array&lt;number&gt;}} - The point coordinates and the RGBA that identifies it.
     * @memberof GeoJSONParser
     */
    processPoint(point) {
        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);
        return { spatial: point.geometry.coordinates, RGBA };
    }

    /**
     * Add the polygon points to the array of all polygon points and saves the polygon borders and triangulation indices.
     * The triangles and vertices calculated by earcut triangulation.
     * @param {{geometry: JSON, properties: JSON}} polygon - The geometry and properties of the polygon.
     * @returns {Array&lt;{triangles: Array&lt;number&gt;, vertices: Array&lt;number&gt;}&gt;} - An array of Polygons. Each polygon has it&apos;s vertices (lng,lat) and triangles (which vertices to connect to create triangles).
     * @see http://www.macwright.org/2015/03/23/geojson-second-bite.html#polygons
     * @see https://github.com/mapbox/earcut/
     * @memberOf GeoJSONParser
     */
    processPolygon(polygon) {
        let polygonIndices = [], //Vertices given by earcut
            bordersIndices = []; //Save all triangles for the processed polygon or multipolygon
        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);
        if (polygon.geometry.type === &quot;Polygon&quot;) { //@TODO: [Demos never use this if statement.]

            let outsidepolygon = polygon.geometry.coordinates[0]; //See: http://geojson.org/geojson-spec.html#polygon
            let tempVerts = new Array();

            for (let out = 0; out &lt; outsidepolygon.length - 1; out++) {
                tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);
                this.allPoints.push(outsidepolygon[out][0], outsidepolygon[out][1]);
                this.allColors.push(...RGBA);
            }

            let earcutVertices = earcut(tempVerts);
            let finalVertices = earcutVertices.map((e) =&gt; e + this.initialIndex);
            for (let finalVertex of finalVertices)
                polygonIndices.push(finalVertex);

            this._createBorders(tempVerts.length / 2, bordersIndices);
            this.initialIndex += tempVerts.length / 2;
        }
        else if (polygon.geometry.type == &quot;MultiPolygon&quot;) { //See http://geojson.org/geojson-spec.html#multipolygon
            for (const cs of polygon.geometry.coordinates) { //For each polygon
                let tempVerts = new Array();

                let outsidepolygon = cs[0];
                for (const c of outsidepolygon) {
                    tempVerts.push(c[0], c[1]);
                    this.allPoints.push(c[0], c[1]);
                    this.allColors.push(...RGBA);
                }

                let earcutVertices = earcut(tempVerts);
                let finalVertices = earcutVertices.map((e) =&gt; e + this.initialIndex);
                for (let finalVertex of finalVertices)
                    polygonIndices.push(finalVertex);

                this._createBorders(tempVerts.length / 2, bordersIndices);
                this.initialIndex += (tempVerts.length / 2); //Update the first index for the next polygon
            }
        }
        return { spatial: { polygonIndices, bordersIndices }, RGBA };
    }

    /**
     * Create the border indices for the polygon starting at it&apos;s initial index.
     * @param {number} numVertices - The number of vertices of the polygon. 
     * @param {Array&lt;number&gt;} bordersIndices - The array of indices. If it&apos;s a multipolygon it might contain some indices otherwise it&apos;s empty.
     * @memberof GeoJSONParser
     */
    _createBorders(numVertices, bordersIndices) {
        //Loop tempVerts and look create indices for this 
        bordersIndices.push(this.initialIndex);
        let currentIndex = this.initialIndex;
        for (let i = 1; i &lt; numVertices; i++) {
            currentIndex++;
            bordersIndices.push(currentIndex, currentIndex);
        }
        bordersIndices.push(this.initialIndex);
    }

    /**
     * Process the line (LineString or MultiLineString).
     * @param {Object} feature - The GeoJSON Feature. 
     * @returns {Array&lt;number&gt;|Array&lt;Array&lt;number&gt;&gt;} - the line (array of points) or a group of lines (array of arrays of points).
     * @see http://wiki.geojson.org/GeoJSON_draft_version_6#MultiLineString
     * @memberof GeoJSONParser
     */
    processLine(feature) {
        let lineIndices = [];
        let RGBA = GisplayDefaults.numberToRGBA(this.RGBAColorNumber++);
        if (feature.geometry.type === &apos;LineString&apos;) {
            /**
                 {
                    &quot;type&quot;: &quot;LineString&quot;,
                    &quot;coordinates&quot;: [
                        [100.0, 0.0], [101.0, 1.0]
                    ]
                }
            */

            let lngLatPoints = [];
            for (const pt of feature.geometry.coordinates) {
                lngLatPoints.push(pt[0], pt[1]); //Push lng,lat
                this.allPoints.push(pt[0], pt[1]);
                this.allColors.push(...RGBA);
            }
            this._createLines(lngLatPoints.length / 2, lineIndices);
            this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line
        }
        else {
            /**
                {
                    &quot;type&quot;: &quot;MultiLineString&quot;,
                    &quot;coordinates&quot;: [
                        [ [100.0, 0.0], [101.0, 1.0] ],
                        [ [102.0, 2.0], [103.0, 3.0] ]
                    ]
                }
             */
            for (const line of feature.geometry.coordinates) { //Loop over each line inside multiLineStr
                let lngLatPoints = [];
                for (const pt of line) { //Loop over each point of this line
                    lngLatPoints.push(pt[0], pt[1]); //Push lng/lat
                    this.allPoints.push(pt[0], pt[1]);
                    this.allColors.push(...RGBA);
                }
                // points.push(linePoints);// [[100, 0, 101, 1], [102, 2, 103, 3]]
                this._createLines(lngLatPoints.length / 2, lineIndices);
                this.initialIndex += (lngLatPoints.length / 2); //Update the first index for the next line
            }
        }
        // return lineIndices;//this.bindLineToWebGLContext(points);
        return { spatial: { lineIndices }, RGBA };//this.bindLineToWebGLContext(points);
    }

    /**
     * Create line segments between each two indices.
     * @param {number} numIndices - The number of indices to add.
     * @param {Array&lt;number&gt;} lineIndices - The indices for the line (If it&apos;s a multilinestring may already contain indices).
     * @memberof GeoJSONIdsParser
     */
    _createLines(numIndices, lineIndices) {
        lineIndices.push(this.initialIndex);
        let currentIndex = this.initialIndex;
        for (let i = 1; i &lt; numIndices - 1; i++) {
            currentIndex++;
            lineIndices.push(currentIndex, currentIndex);
        }
        lineIndices.push(++currentIndex);
    }

    /**
     * Join all points of all polygons/lines into a single WebGL buffer.
     * @memberof Parser
     */
    joinAllPoints() {
        let webglContext = this.webglContext;
        const vertArray = new Float32Array(this.allPoints);
        const bufferP = webglContext.createBuffer();
        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);
        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);
        this.allPoints = bufferP;
    }

    /**
     * Join all points of all polygons/lines into a single WebGL buffer.
     * @memberof Parser
     */
    joinAllColors() {
        let webglContext = this.webglContext;
        const vertArray = new Uint8Array(this.allColors);
        const bufferP = webglContext.createBuffer();
        webglContext.bindBuffer(webglContext.ARRAY_BUFFER, bufferP);
        webglContext.bufferData(webglContext.ARRAY_BUFFER, vertArray, webglContext.STATIC_DRAW);
        this.allColors = bufferP;
    }

    /**
     * Dispatch the event for the geometry ids.
     * @param {Map&lt;string, Polygon|Array&lt;number&gt;&gt;} geometryIdsMap - The map with ids and respective geometry. 
     * @memberof Parser
     */
    dispatchIdGeometryEndEvent(geometryIdsMap) {
        document.dispatchEvent(new CustomEvent(&quot;geometryIdsEnd&quot;, {  //Retornar pelo menos os dados processados e as classes 
            detail: {
                geometryIdsMap: geometryIdsMap,
                allPoints: this.allPoints,
                allColors: this.allColors,
                geometryPrimitive: this.geometryPrimitive
            }
        }));
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.3)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

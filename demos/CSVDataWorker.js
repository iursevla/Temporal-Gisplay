/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!**************************************************************************************************!*\
  !*** ./~/babel-loader/lib?{"presets":["es2015"]}!./src/Gisplay/Parser/CSV/File/CSVDataWorker.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../VVs/DataVariable\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _URLVariable = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../VVs/URLVariable\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _TimeVariable = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../VVs/TimeVariable\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _CategoricalVariable = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../VVs/CategoricalVariable\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _ContinuousVariable = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../VVs/ContinuousVariable\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _GisplayDefaults = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../GisplayDefaults\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar worker = self;\n\nvar CSVDataWorker = function () {\n    function CSVDataWorker() {\n        var _this = this;\n\n        _classCallCheck(this, CSVDataWorker);\n\n        // console.log(\"-------------------CSV Data Worker-------------------\");\n        /**\r\n         * The first row read by this data worker.\r\n         * @type {string}\r\n         */\n        this.firstWorkerRow = '';\n        /**\r\n         * The last row of the last chunk read by the parser.\r\n         * @type {string}\r\n         */\n        this.lastWorkerRow = '';\n        /**\r\n         * Save the remaining of the last row from the chunk that was read.\r\n         * It's used when a chunk didn't end in a row delimitir character.\r\n         * @type {string}\r\n         */\n        this.remainingChunkRow = '';\n\n        /**\r\n         * The data file.\r\n         * @type {File}\r\n         */\n        this.dataFile = null;\n        /**\r\n         * The start byte for this worker.\r\n         * @type {number}\r\n         */\n        this.startByte = 0;\n        /**\r\n         * The end byte for this worker.\r\n         * @type {number}\r\n         */\n        this.endByte = 0;\n        /**\r\n         * The size of each chunk to read from the file.\r\n         * @type {number}\r\n         */\n        this.chunkSize = 0;\n        /**\r\n         * The index of this worker. DELETE?\r\n         * @type {number}\r\n         */\n        this.workerIndex = -1;\n        /**\r\n         * Number of columns for each row. DELETE?\r\n         * @type {number}\r\n         */\n        this.numColumnsPerRow = -1; //NOT USED ATM\n\n        /**\r\n         * The row delimiter.\r\n         * @type {string}\r\n         */\n        this.rowDelimiter = '';\n        /**\r\n         * The column delimiter.\r\n         * @type {string}\r\n         */\n        this.columnDelimiter = '';\n\n        /**\r\n         * The header indices. \r\n         * The array is split into 5 positions: [0]categorical, [1]continuous, [2]geometry, [3]time and [4]optional variables. \r\n         * @type {Array<Array<number>>}\r\n         */\n        this.headerIndices = [];\n\n        //TIME \n        /**\r\n         * The time variable.\r\n         * @type {TimeVariable}\r\n         */\n        this.timeVariable = null;\n        /**\r\n         * The granularity of the time variable.\r\n         * @type {string}\r\n         */\n        this.timeGranularity = '';\n\n        //CATEGORICAL\n        /**\r\n         * The categorical variables present in the user options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\n        this.categoricalVariables = [];\n        /**\r\n         * If the options contain any categorical variable.\r\n         * @type {boolean}\r\n         */\n        this.hasCategoricalVariables = false;\n\n        //CONTINUOUS\n        /**\r\n         * The continuous variables.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\n        this.continuousVariables = [];\n\n        //OPTIONAL\n        /**\r\n         * The optional variables.\r\n         * @type {Array<DataVariable>}\r\n         */\n        this.optionalVariables = [];\n\n        /**\r\n         * The FileReader used to read a portion of the file.\r\n         * @type {FileReader}\r\n         */\n        this.reader = this.createFileReader();\n        worker.onmessage = function (e) {\n            _this.onMessage(e.data);\n        };\n\n        //SAVE INFORMATION\n        /**\r\n         * Used to save the rows directly read from the file\r\n         * @type {Array<Array<string|number>>}\r\n         */\n        this.dataRowsSaved = []; //Save rows read by this Worker\n        /**\r\n         * The final data rows which contain all information to be sent to the main thread.\r\n         * @type {Array<Array<{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}>>}\r\n         */\n        this.finalDataRows = [];\n        // this.numRowsRead = 0;\n\n        /** \r\n         * Will be true when we want to process the last line.\r\n         * @type {boolean}\r\n         */\n        this.isLastLine = false;\n    }\n\n    /**\r\n     * Create file reader.\r\n     * @returns {FileReader} - the FileReader used to read a portion of the file.\r\n     * @memberof CSVDataWorker\r\n     */\n\n\n    _createClass(CSVDataWorker, [{\n        key: 'createFileReader',\n        value: function createFileReader() {\n            var _this2 = this;\n\n            var reader = new FileReader();\n            reader.onload = function (e) {\n                _this2.chunkReadFromFile(e);\n            };\n            reader.onerror = function (e) {\n                console.error(e);\n            };\n            return reader;\n        }\n\n        /**\r\n         * When the worker receives a message. \r\n         * @param {{protocolMessage: string, messageData:Object}} dataMessage - The data message that was sent by the main Thread.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'onMessage',\n        value: function onMessage(dataMessage) {\n            // console.log(\"-------------------CSV Data Worker-------------------\");\n            // console.log(dataMessage);\n            var protocolMessages = _GisplayDefaults.GisplayDefaults.MESSAGES_CSV();\n            switch (dataMessage.protocolMessage) {\n                case protocolMessages.TO_START:\n                    {\n                        //Worker processed it's part\n                        //File and chunk information\n                        var workerOptions = dataMessage.messageData.workerOptions;\n                        this.dataFile = workerOptions.dataFile;\n                        this.startByte = workerOptions.startByte;\n                        this.endByte = workerOptions.endByte;\n                        this.chunkSize = workerOptions.chunkSize;\n                        this.workerIndex = workerOptions.workerIndex;\n                        this.numColumnsPerRow = workerOptions.numColumnsPerRow;\n                        this.rowDelimiter = workerOptions.rowDelimiter;\n                        this.columnDelimiter = workerOptions.columnDelimiter;\n                        //Indices and class calc\n                        this.headerIndices = workerOptions.headerIndices;\n                        //Save Categorical/Continuous and time Vars\n                        this._saveVariables(dataMessage.messageData.workerOptions);\n                        //Start reading file\n                        this.readNextChunk();\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT:\n                    {\n                        console.log(\"TO_LIMIT_CAT\");\n                        var catVarsCategoriesMap = new Map();\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = this.categoricalVariables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var catVar = _step.value;\n\n                                catVarsCategoriesMap.set(catVar.getInternalName(), catVar.getCategories());\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        var contVarsMinMaxMap = new Map();\n                        var _iteratorNormalCompletion2 = true;\n                        var _didIteratorError2 = false;\n                        var _iteratorError2 = undefined;\n\n                        try {\n                            for (var _iterator2 = this.continuousVariables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                var contVar = _step2.value;\n\n                                contVarsMinMaxMap.set(contVar.getInternalName(), [contVar.getMin(), contVar.getMax()]);\n                            } // console.log(this.workerIndex, catVarsCategoriesMap, contVarsMinMaxMap, this.timeVariable, this.timeVariable.getTemporalGranulesSet())\n                        } catch (err) {\n                            _didIteratorError2 = true;\n                            _iteratorError2 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                    _iterator2.return();\n                                }\n                            } finally {\n                                if (_didIteratorError2) {\n                                    throw _iteratorError2;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT,\n                            messageData: {\n                                categoricalVariables: catVarsCategoriesMap,\n                                continousVariables: contVarsMinMaxMap,\n                                timeVariable: this.timeVariable ? this.timeVariable.getTemporalGranulesSet() : this.timeVariable\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT_RES:\n                    {\n                        var continousVarsMinMax = dataMessage.messageData;\n                        var _iteratorNormalCompletion3 = true;\n                        var _didIteratorError3 = false;\n                        var _iteratorError3 = undefined;\n\n                        try {\n                            for (var _iterator3 = this.continuousVariables.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                                var _step3$value = _slicedToArray(_step3.value, 2),\n                                    i = _step3$value[0],\n                                    _contVar = _step3$value[1];\n\n                                _contVar.setMinMax(continousVarsMinMax[i][0]);\n                                _contVar.setMinMax(continousVarsMinMax[i][1]);\n                                _contVar.setStep(); //Update step value\n                            }\n\n                            //Loop through data and calculate bins for each continuous variable\n                        } catch (err) {\n                            _didIteratorError3 = true;\n                            _iteratorError3 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                    _iterator3.return();\n                                }\n                            } finally {\n                                if (_didIteratorError3) {\n                                    throw _iteratorError3;\n                                }\n                            }\n                        }\n\n                        var contPosStart = this.categoricalVariables.length;\n                        var contPosEnd = contPosStart + this.continuousVariables.length;\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = undefined;\n\n                        try {\n                            for (var _iterator4 = this.dataRowsSaved[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                                var data = _step4.value;\n\n                                for (var i = contPosStart; i < contPosEnd; i++) {\n                                    this.continuousVariables[i - contPosStart].addValueToBins(data[i]);\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError4 = true;\n                            _iteratorError4 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                    _iterator4.return();\n                                }\n                            } finally {\n                                if (_didIteratorError4) {\n                                    throw _iteratorError4;\n                                }\n                            }\n                        }\n\n                        var histograms = [];\n                        var _iteratorNormalCompletion5 = true;\n                        var _didIteratorError5 = false;\n                        var _iteratorError5 = undefined;\n\n                        try {\n                            for (var _iterator5 = this.continuousVariables[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                                var _contVar2 = _step5.value;\n\n                                histograms.push(_contVar2.getHistogram());\n                            } // console.log(this.continuousVariables[0].getHistogram());\n                        } catch (err) {\n                            _didIteratorError5 = true;\n                            _iteratorError5 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                    _iterator5.return();\n                                }\n                            } finally {\n                                if (_didIteratorError5) {\n                                    throw _iteratorError5;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT_RES,\n                            messageData: {\n                                histograms: histograms\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_JOIN_DATA:\n                    {\n                        //Process data and then send the res data\n                        if (this.workerIndex === 0) {\n                            console.log(\"I will process the data....NOT\");\n                            console.log(dataMessage.messageData);\n                        }\n\n                        var catVars = dataMessage.messageData.categoricalVariables;\n                        var _iteratorNormalCompletion6 = true;\n                        var _didIteratorError6 = false;\n                        var _iteratorError6 = undefined;\n\n                        try {\n                            for (var _iterator6 = catVars.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                                var _step6$value = _slicedToArray(_step6.value, 2),\n                                    _i2 = _step6$value[0],\n                                    _catVar = _step6$value[1];\n\n                                this.categoricalVariables[_i2].valueToIndexMap = _catVar.valueToIndexMap;\n                            }\n                        } catch (err) {\n                            _didIteratorError6 = true;\n                            _iteratorError6 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                    _iterator6.return();\n                                }\n                            } finally {\n                                if (_didIteratorError6) {\n                                    throw _iteratorError6;\n                                }\n                            }\n                        }\n\n                        var contVars = dataMessage.messageData.continuousVariables;\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = undefined;\n\n                        try {\n                            for (var _iterator7 = contVars.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                var _step7$value = _slicedToArray(_step7.value, 2),\n                                    _i3 = _step7$value[0],\n                                    _contVar3 = _step7$value[1];\n\n                                this.continuousVariables[_i3].classIntervals = _contVar3.classIntervals;\n                            }\n                        } catch (err) {\n                            _didIteratorError7 = true;\n                            _iteratorError7 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                    _iterator7.return();\n                                }\n                            } finally {\n                                if (_didIteratorError7) {\n                                    throw _iteratorError7;\n                                }\n                            }\n                        }\n\n                        var tVar = dataMessage.messageData.timeVariable;\n                        if (tVar) this.timeVariable.temporalGranulesMap = tVar.temporalGranulesMap;\n\n                        var msgData = dataMessage.messageData;\n                        var mvcs = msgData.mvcs,\n                            numberMVCs = mvcs.size,\n                            numberTGs = msgData.numberTGs;\n                        this._joinData(mvcs, numberTGs);\n\n                        var numTotalElements = 0; //Create array to send information about this worker\n                        console.error(this.finalDataRows);\n                        /*    if (this.continuousVariables.length > 0) {\r\n                               for (let i = 0; i < numberMVCs; i++)\r\n                                   for (let j = 0; j < numberTGs; j++)\r\n                                       numTotalElements += this.finalDataRows[i][j].continuousData[0].length;\r\n                           } else {\r\n                               // throw new Error(\"\"); */\n                        for (var _i = 0; _i < numberMVCs; _i++) {\n                            for (var j = 0; j < numberTGs; j++) {\n                                if (this.headerIndices[2].length) numTotalElements += this.finalDataRows[_i][j].spatialData.length / 2; //Lat/Lng\n                                else numTotalElements += this.finalDataRows[_i][j].spatialData.length; //Ids\n                            }\n                        }\n                        // }\n                        console.warn(numTotalElements);\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_JOIN_DATA,\n                            messageData: {\n                                numTotalElements: numTotalElements,\n                                workerIndex: this.workerIndex\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_GENERATE_RGBA:\n                    {\n                        // Should Generate RGBAs for all MVCs/TGs \n                        this._generateRGBACodes(dataMessage.messageData);\n                        worker.postMessage({ protocolMessage: protocolMessages.END_GENERATE_RGBA });\n                        break;\n                    }\n                case protocolMessages.TO_SEND_DATA:\n                    {\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_SEND_DATA,\n                            messageData: {\n                                finalDataRows: this.finalDataRows\n                            }\n                        });\n                        break;\n                    }\n            }\n        }\n\n        /**\r\n         * Generate RGBA codes for each element in each MVC/TG.\r\n         * @param {Array<Array<number>} startRGBANum - The start RGBA number for this worker.. \r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_generateRGBACodes',\n        value: function _generateRGBACodes(startRGBANum) {\n            var numMVCs = this.finalDataRows.length,\n                numTGs = this.finalDataRows[0].length;\n            for (var i = 0; i < numMVCs; i++) {\n                // let startRGBA = startingRGBANumber[i],\n                // let startRGBANum = GisplayDefaults.RGBAToNumber(...startRGBA);\n                for (var j = 0; j < numTGs; j++) {\n                    var numberOfElements = 0;\n                    if (this.headerIndices[2].length) numberOfElements = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else numberOfElements = this.finalDataRows[i][j].spatialData.length; //Ids\n                    // let continuousDataLength = this.finalDataRows[i][j].continuousData[0].length; //Using continuous data that might not exist\n                    if (numberOfElements > 0) {\n                        for (var k = 0; k < numberOfElements; k++) {\n                            var _finalDataRows$i$j$RG;\n\n                            var RGBA = _GisplayDefaults.GisplayDefaults.numberToRGBA(startRGBANum);\n                            (_finalDataRows$i$j$RG = this.finalDataRows[i][j].RGBA).push.apply(_finalDataRows$i$j$RG, _toConsumableArray(RGBA));\n                            this.finalDataRows[i][j].numberRGBA.push(startRGBANum++);\n                        }\n                    }\n                }\n            }\n            this.verifyIntegrityRGBA(numMVCs, numTGs);\n        }\n    }, {\n        key: 'verifyIntegrityRGBA',\n        value: function verifyIntegrityRGBA(numMVCs, numTGs) {\n            // console.warn(\"VERIFY INTEGRITY\")\n            for (var i = 0; i < numMVCs; i++) {\n                for (var j = 0; j < numTGs; j++) {\n                    var continuousDataLength = 0;\n                    if (this.headerIndices[2].length) continuousDataLength = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else continuousDataLength = this.finalDataRows[i][j].spatialData.length; //Ids\n                    if (continuousDataLength > 0) for (var k = 0; k < continuousDataLength - 1; k++) {\n                        console.assert(this.finalDataRows[i][j].numberRGBA[k] + 1 === this.finalDataRows[i][j].numberRGBA[k + 1]);\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Join the data into MVCs and TGs.\r\n         * @param {Map<string, number>} mvcs - The generated MVCs map and respective index.\r\n         * @param {number} numberTGs - The number of temporal granules.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_joinData',\n        value: function _joinData(mvcs, numberTGs) {\n            //Loop through rows and copy them to the final array\n            //categorical vars and time var can be ignored (they are known by the arrays indices)\n            //Save cont vars, geometry, opt vars and RGBA value\n\n            var hasIds = this.headerIndices[2].length ? false : true;\n            var geoPositions = hasIds ? 1 : 2;\n\n            // console.warn(this.timeVariable, mvcs);\n            var numberMVCs = mvcs.size,\n                numCatVars = this.categoricalVariables.length,\n                numContVars = this.continuousVariables.length,\n                geoStartPos = numCatVars + numContVars,\n                geoEndPos = geoStartPos + geoPositions,\n                timePos = geoEndPos;\n\n            this.finalDataRows = this._createFinalRows(numberMVCs, numberTGs);\n            //For each row saved then split it to its place\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = this.dataRowsSaved[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var rowSaved = _step8.value;\n\n                    var finalRow = [];\n                    var combination = '';\n\n                    var _iteratorNormalCompletion9 = true;\n                    var _didIteratorError9 = false;\n                    var _iteratorError9 = undefined;\n\n                    try {\n                        for (var _iterator9 = this.categoricalVariables.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                            var _step9$value = _slicedToArray(_step9.value, 2),\n                                _i6 = _step9$value[0],\n                                catVar = _step9$value[1];\n\n                            combination += catVar.findIndex(rowSaved[_i6]);\n                        }\n                    } catch (err) {\n                        _didIteratorError9 = true;\n                        _iteratorError9 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                _iterator9.return();\n                            }\n                        } finally {\n                            if (_didIteratorError9) {\n                                throw _iteratorError9;\n                            }\n                        }\n                    }\n\n                    var contValues = [];\n                    var _iteratorNormalCompletion10 = true;\n                    var _didIteratorError10 = false;\n                    var _iteratorError10 = undefined;\n\n                    try {\n                        for (var _iterator10 = this.continuousVariables.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                            var _step10$value = _slicedToArray(_step10.value, 2),\n                                j = _step10$value[0],\n                                contVar = _step10$value[1];\n\n                            var contValue = rowSaved[j + numCatVars];\n                            combination += contVar.findClassIntervalIndex(contValue);\n                            contValues.push(contValue);\n                        }\n                    } catch (err) {\n                        _didIteratorError10 = true;\n                        _iteratorError10 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                                _iterator10.return();\n                            }\n                        } finally {\n                            if (_didIteratorError10) {\n                                throw _iteratorError10;\n                            }\n                        }\n                    }\n\n                    var mvcIndex = mvcs.get(combination);\n                    var tgIndex = this.timeVariable !== undefined ? this.timeVariable.getTGMapIndex(rowSaved[timePos]) : 0;\n                    if (tgIndex === undefined) console.error(\"HERE\");\n                    for (var i = 0; i < contValues.length; i++) {\n                        this.finalDataRows[mvcIndex][tgIndex].continuousData[i].push(contValues[i]);\n                    }for (var _i4 = geoStartPos; _i4 < geoEndPos; _i4++) {\n                        this.finalDataRows[mvcIndex][tgIndex].spatialData.push(rowSaved[_i4]);\n                    }for (var _i5 = timePos + 1; _i5 < rowSaved.length; _i5++) {\n                        this.finalDataRows[mvcIndex][tgIndex].optionalData[_i5 - timePos - 1].push(rowSaved[_i5]);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n\n            this.dataRowsSaved = undefined; //Allows Garbage collection\n        }\n\n        /**\r\n         * Create the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @param {number} numberMVCs - Number of existing map variable combinations.\r\n         * @param {number} numberTGs - Number of existing temporal granules . \r\n         * @returns {Array<any>} - the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_createFinalRows',\n        value: function _createFinalRows(numberMVCs, numberTGs) {\n            var finalRows = [];\n\n            //Create arrays for optionalData\n            var optionalDataArrays = [];\n            for (var i = 0; i < this.optionalVariables.length; i++) {\n                //Create multiple arrays one for each optional variable\n                optionalDataArrays[i] = [];\n            }var continuosDataArrays = [];\n            for (var _i7 = 0; _i7 < this.continuousVariables.length; _i7++) {\n                //Create multiple arrays one for each optional variable\n                continuosDataArrays[_i7] = [];\n            } //Create array for final Rows\n            for (var _i8 = 0; _i8 < numberMVCs; _i8++) {\n                finalRows[_i8] = [];\n                for (var j = 0; j < numberTGs; j++) {\n                    finalRows[_i8][j] = {\n                        continuousData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(continuosDataArrays),\n                        spatialData: [],\n                        optionalData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(optionalDataArrays),\n                        RGBA: [],\n                        numberRGBA: []\n                    };\n                }\n            }\n            // console.log(finalRows);\n            return finalRows;\n        }\n\n        /**\r\n         * Recreate the variables sent by the main thread.\r\n         * @param {{continousVariables: Array<ContinuousVariable>, categoricalVariables: Array<CategoricalVariable>, timeVariable: TimeVariable}} data - Data sent by the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_saveVariables',\n        value: function _saveVariables(data) {\n            var contVars = [];\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n                for (var _iterator11 = data.continuousVariables[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                    var contVar = _step11.value;\n\n                    console.log(contVar);\n                    contVars.push(new _ContinuousVariable.ContinuousVariable(contVar.externalName, contVar.internalName, contVar.typeOfVisualVariable, contVar.shaderVariableQualifier, contVar.visualVariableMapping, contVar.classBreaks, contVar.numberOfClasses, contVar.classBreakMethod, contVar.classBreakMethodParams));\n                }\n                // let doa = true;\n                // if (doa) {\n            } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                        _iterator11.return();\n                    }\n                } finally {\n                    if (_didIteratorError11) {\n                        throw _iteratorError11;\n                    }\n                }\n            }\n\n            var catVars = [];\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = data.categoricalVariables[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var catVar = _step12.value;\n\n                    catVars.push(new _CategoricalVariable.CategoricalVariable(catVar.externalName, catVar.internalName, catVar.typeOfVisualVariable, catVar.shaderVariableQualifier, catVar.visualVariableMapping, null));\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n\n            var tVar = data.timeVariable;\n            var timeVariable = void 0;\n            if (tVar !== undefined) {\n                timeVariable = new _TimeVariable.TimeVariable(tVar.externalName, tVar.internalName, tVar.granularity, tVar.timeControl);\n            }\n            var optVars = [];\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n                for (var _iterator13 = data.optionalVariables[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                    var optVar = _step13.value;\n\n                    optVars.push(new _DataVariable.DataVariable(optVar.externalName, optVar.internalName));\n                } //TIME\n                // this.timeVariable = workerOptions.timeVariable;\n            } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                        _iterator13.return();\n                    }\n                } finally {\n                    if (_didIteratorError13) {\n                        throw _iteratorError13;\n                    }\n                }\n            }\n\n            this.timeVariable = timeVariable;\n            this.timeGranularity = this.timeVariable ? this.timeVariable.getGranularity() : '';\n            //CATEGORICAL\n            this.categoricalVariables = catVars; //workerOptions.categoricalVariables;\n            this.hasCategoricalVariables = this.categoricalVariables.length > 0;\n            //CONTINOUS \n            this.continuousVariables = contVars; //workerOptions.continuousVariables;\n            //OPTIONAL VARS\n            this.optionalVariables = optVars;\n            // }\n        }\n\n        /**\r\n         * Reads a chunk of bytes from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'readNextChunk',\n        value: function readNextChunk() {\n            var start = Math.min(this.startByte, this.endByte);\n            var end = Math.min(this.startByte + this.chunkSize, this.endByte);\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Reads more 1000 bytes to finish the last line of the worker.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'readLastLine',\n        value: function readLastLine() {\n            if (this.lastWorkerRow.length === 0) return true;\n            var start = Math.min(this.startByte, this.endByte);\n            var end = this.endByte + 1000;\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Called after a chunk is read from the file.\r\n         * @param {ProgressEvent} e - Event associated with the read data.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'chunkReadFromFile',\n        value: function chunkReadFromFile(e) {\n            if (this.isLastLine) {\n                // console.warn(\"last line\", this.workerIndex, e.target.result);\n                var rows = (this.lastWorkerRow + e.target.result).split(this.rowDelimiter);\n                // console.warn(this.workerIndex, rows);\n                this.processRows(rows, 0, 1);\n                this.sendENDStartMessage();\n            } else {\n                this.startByte += this.chunkSize;\n                this.processChunk(e.target.result);\n                if (this.startByte >= this.endByte) {\n                    // console.log(\"END\");\n                    // console.log(\"NumRows Worker\", this.workerIndex, \"is:\", this.numRowsRead, \"\\nFIRSTROW = \", this.firstWorkerRow, \"\\nLASTROW = \", this.lastWorkerRow);\n                    //Post message with first and last row\n                    // console.warn(\"worker Terminated\", this.workerIndex, this.firstWorkerRow, this.lastWorkerRow);\n                    this.isLastLine = true;\n                    var isDone = this.readLastLine();\n                    if (isDone) //Only the ones that returned true from the readLastLine() method will send back to the \n                        this.sendENDStartMessage();\n                } else this.readNextChunk();\n            }\n        }\n    }, {\n        key: 'sendENDStartMessage',\n        value: function sendENDStartMessage() {\n            console.warn(\"END\", this.workerIndex, this.dataRowsSaved.length);\n            worker.postMessage({\n                protocolMessage: _GisplayDefaults.GisplayDefaults.MESSAGES_CSV().END_START,\n                messageData: {\n                    workerIndex: this.workerIndex\n                    // firstWorkerRow: this.firstWorkerRow,\n                    // lastWorkerRow: this.lastWorkerRow\n                }\n            });\n        }\n\n        /**\r\n         * Process the chunk that was read from the file.\r\n         * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n         * @see https://image.prntscr.com/image/BkaRp8qSQuyt9phoSh71ZA.png\r\n         * @see https://image.prntscr.com/image/FAQ8CVH9S1W6X0RoZrOWfw.png - Edge case for \\r\\n.\r\n         * @see https://image.prntscr.com/image/yYXWcZwLQjSNYqIiuQEcKQ.png - Edge case example.\r\n         * @param {any} chunkText  - The text read from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'processChunk',\n        value: function processChunk(chunkText) {\n            var rows = (this.remainingChunkRow + chunkText).split(this.rowDelimiter); //May not have the best performance (has to create new string due to string immutability). Could be changed but solution has to solve the EDGE CASE.\n            this.remainingChunkRow = rows[rows.length - 1];\n            var startRowIndex = 0,\n                endRowIndex = rows.length - 1; //The index to start and end the rows processing\n\n            if (!this.firstWorkerRow) {\n                //Save 1st row of this worker \n                this.firstWorkerRow = rows[0];\n                startRowIndex = 1; //Ignore first row of first chunk in any worker\n            }\n            if (!this.lastWorkerRow && this.startByte >= this.endByte) {\n                // console.log(this.workerIndex, this.lastWorkerRow);\n                this.lastWorkerRow = this.remainingChunkRow; //Save last row if it's the last chunk (See split image) \n                // console.log(this.workerIndex, rows, this.dataRowsSaved, this.firstWorkerRow, this.lastWorkerRow);\n\n                // console.error(this.workerIndex, this.remainingChunkRow);\n            }\n            this.processRows(rows, startRowIndex, endRowIndex);\n        }\n\n        /**\r\n         * Process the rows that are in the rows array. The first row of the 1st chunk read from the file should be ignored.\r\n         * @param {Array<string>} rows - The rows, each one in a position of the array. \r\n         * @param {number} startRowIndex - The row to start processing.\r\n         * @param {number} endRowIndex - The last row to process.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'processRows',\n        value: function processRows(rows, startRowIndex, endRowIndex) {\n            var resRows = [];\n            // this.numRowsRead += (endRowIndex - startRowIndex); //DELETE\n            var categoricalIndices = this.headerIndices[0];\n            var continuousIndices = this.headerIndices[1];\n            var geometryIndices = this.headerIndices[2];\n            var hasIdGeometry = false;\n            if (+geometryIndices === +geometryIndices) {\n                geometryIndices = [geometryIndices];\n                hasIdGeometry = true;\n            }\n            var timeIndex = this.headerIndices[3];\n            var hasTime = this.timeGranularity !== ''; //OR this.timeVariable !== undefined\n            var optinalIndices = this.headerIndices[4];\n            for (var i = startRowIndex; i < endRowIndex; i++) {\n                this.numRowsRead++;\n                var columns = rows[i].split(this.columnDelimiter);\n                /* if (columns.length !== this.numColumnsPerRow) //Check for errors\r\n                    throw new Error(\"Wrong number of columns\");\r\n                 */\n                var row = [];\n\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = categoricalIndices.entries()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var _step14$value = _slicedToArray(_step14.value, 2),\n                            _i9 = _step14$value[0],\n                            catIndex = _step14$value[1];\n\n                        var category = columns[catIndex];\n                        if (this.categoricalVariables[_i9].classCalculationRequired()) this.categoricalVariables[_i9].addCategory(category);\n                        row.push(category);\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion15 = true;\n                var _didIteratorError15 = false;\n                var _iteratorError15 = undefined;\n\n                try {\n                    for (var _iterator15 = continuousIndices.entries()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var _step15$value = _slicedToArray(_step15.value, 2),\n                            _i10 = _step15$value[0],\n                            contIndex = _step15$value[1];\n\n                        var value = +columns[contIndex];\n                        /* if (value >= 80000.10)\r\n                            console.warn(\"WUUUT\"); */\n                        this.continuousVariables[_i10].setMinMax(value);\n                        row.push(value); //String to number\n                    }\n                } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                            _iterator15.return();\n                        }\n                    } finally {\n                        if (_didIteratorError15) {\n                            throw _iteratorError15;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = geometryIndices[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var geoIndex = _step16.value;\n\n                        if (hasIdGeometry) {\n                            var _value = columns[geoIndex];\n                            if (+_value === +_value) row.push(+_value);else row.push(_value.toUpperCase());\n                        } else row.push(+columns[geoIndex]);\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n\n                if (hasTime) {\n                    var granule = this.getGranule(columns[timeIndex]);\n                    this.timeVariable.addTemporalGranule(granule);\n                    this.timeVariable.addTemporalGranuleToSet(granule);\n                    row.push(granule);\n                }\n\n                var _iteratorNormalCompletion17 = true;\n                var _didIteratorError17 = false;\n                var _iteratorError17 = undefined;\n\n                try {\n                    for (var _iterator17 = optinalIndices[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                        var optionalIndex = _step17.value;\n\n                        if (+columns[optionalIndex] === +columns[optionalIndex]) //It's a number?\n                            row.push(+columns[optionalIndex]);else row.push(columns[optionalIndex]);\n                    }\n                    // resRows.push(row);\n                } catch (err) {\n                    _didIteratorError17 = true;\n                    _iteratorError17 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                            _iterator17.return();\n                        }\n                    } finally {\n                        if (_didIteratorError17) {\n                            throw _iteratorError17;\n                        }\n                    }\n                }\n\n                this.dataRowsSaved.push(row);\n            }\n            // console.log(this.workerIndex, this.dataRowsSaved.length);\n        }\n\n        /**\r\n         * TODO: DELETE AND Replace with GisplayDefaults.getGranule(timeString)\r\n         * Convert the time string to the granularity we want.\r\n         * @param {string} timeString - The time as it was read from the file. \r\n         * @returns {number} - The granul\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'getGranule',\n        value: function getGranule(timeString) {\n            var value = void 0;\n            // console.warn(timeString, this.timeGranularity);\n            /*\r\n            //if cyclic then ...\r\n            day of year -> dayOfYear (n temos )\r\n            month of year -> monthOfYear (temos)\r\n            day of month -> dayOfMonth (temos)\r\n            hour of day -> hourOfDay (temos)\r\n            minute of hour -> minuteOfHour (temos)\r\n            \r\n            //else continuous\r\n            year -> 2015, 2016 ...\r\n            month -> 2015_01, 2015_02 ... 2016_01 etc\r\n            day -> 2015_01_01, 2015_01_02 ...\r\n            hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n            minute\r\n            value\r\n            */\n\n            switch (this.timeGranularity) {\n                //CYCLIC\n                case 'monthOfYear':\n                    //Mes do ano\n                    value = new Date(timeString).getMonth() + 1; //GOOD\n                    break;\n                case 'dayOfYear':\n                    value = -1; //CHANGE to calculate day of year\n                    break;\n                case 'dayOfMonth':\n                    value = new Date(timeString).getDate(); //GOOD\n                    break;\n                case 'hourOfDay':\n                    value = new Date(timeString).getHours(); //GOOD\n                    break;\n                case 'minuteOfHour':\n                    value = new Date(timeString).getMinutes(); //GOOD\n                    break;\n\n                //CONTINUOUS\n                case 'year':\n                    value = new Date(timeString).getFullYear();\n                    break;\n                case 'month':\n                    //Mes do ano\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\n                    break;\n                case 'day':\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\n                    // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\n                    break;\n                case 'value':\n                    value = +timeString;\n                    break;\n            }\n            // console.log(value);\n            return value;\n        }\n    }]);\n\n    return CSVDataWorker;\n}();\n\nnew CSVDataWorker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9QYXJzZXIvQ1NWL0ZpbGUvQ1NWRGF0YVdvcmtlci5qcz8wYTc4Il0sInNvdXJjZXNDb250ZW50IjpbImxldCB3b3JrZXIgPSBzZWxmO1xyXG5cclxuaW1wb3J0IHsgRGF0YVZhcmlhYmxlIH0gZnJvbSAnLi4vLi4vVlZzL0RhdGFWYXJpYWJsZSc7XHJcbmltcG9ydCB7IFVSTFZhcmlhYmxlIH0gZnJvbSAnLi4vLi4vVlZzL1VSTFZhcmlhYmxlJztcclxuaW1wb3J0IHsgVGltZVZhcmlhYmxlIH0gZnJvbSAnLi4vLi4vVlZzL1RpbWVWYXJpYWJsZSc7XHJcbmltcG9ydCB7IENhdGVnb3JpY2FsVmFyaWFibGUgfSBmcm9tICcuLi8uLi9WVnMvQ2F0ZWdvcmljYWxWYXJpYWJsZSc7XHJcbmltcG9ydCB7IENvbnRpbnVvdXNWYXJpYWJsZSB9IGZyb20gJy4uLy4uL1ZWcy9Db250aW51b3VzVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBHaXNwbGF5RGVmYXVsdHMgfSBmcm9tICcuLi8uLi9HaXNwbGF5RGVmYXVsdHMnO1xyXG5cclxuY2xhc3MgQ1NWRGF0YVdvcmtlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS1DU1YgRGF0YSBXb3JrZXItLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmaXJzdCByb3cgcmVhZCBieSB0aGlzIGRhdGEgd29ya2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maXJzdFdvcmtlclJvdyA9ICcnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXN0IHJvdyBvZiB0aGUgbGFzdCBjaHVuayByZWFkIGJ5IHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RXb3JrZXJSb3cgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlIHRoZSByZW1haW5pbmcgb2YgdGhlIGxhc3Qgcm93IGZyb20gdGhlIGNodW5rIHRoYXQgd2FzIHJlYWQuXHJcbiAgICAgICAgICogSXQncyB1c2VkIHdoZW4gYSBjaHVuayBkaWRuJ3QgZW5kIGluIGEgcm93IGRlbGltaXRpciBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbWFpbmluZ0NodW5rUm93ID0gJyc7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIGZpbGUuXHJcbiAgICAgICAgICogQHR5cGUge0ZpbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhRmlsZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHN0YXJ0IGJ5dGUgZm9yIHRoaXMgd29ya2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydEJ5dGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBlbmQgYnl0ZSBmb3IgdGhpcyB3b3JrZXIuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuZEJ5dGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIGVhY2ggY2h1bmsgdG8gcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGlzIHdvcmtlci4gREVMRVRFP1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53b3JrZXJJbmRleCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBjb2x1bW5zIGZvciBlYWNoIHJvdy4gREVMRVRFP1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zUGVyUm93ID0gLTE7IC8vTk9UIFVTRUQgQVRNXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByb3cgZGVsaW1pdGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb3dEZWxpbWl0ZXIgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sdW1uIGRlbGltaXRlci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sdW1uRGVsaW1pdGVyID0gJyc7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoZWFkZXIgaW5kaWNlcy4gXHJcbiAgICAgICAgICogVGhlIGFycmF5IGlzIHNwbGl0IGludG8gNSBwb3NpdGlvbnM6IFswXWNhdGVnb3JpY2FsLCBbMV1jb250aW51b3VzLCBbMl1nZW9tZXRyeSwgWzNddGltZSBhbmQgWzRdb3B0aW9uYWwgdmFyaWFibGVzLiBcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWFkZXJJbmRpY2VzID0gW107XHJcblxyXG4gICAgICAgIC8vVElNRSBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7VGltZVZhcmlhYmxlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGltZVZhcmlhYmxlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZ3JhbnVsYXJpdHkgb2YgdGhlIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVHcmFudWxhcml0eSA9ICcnO1xyXG5cclxuICAgICAgICAvL0NBVEVHT1JJQ0FMXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhdGVnb3JpY2FsIHZhcmlhYmxlcyBwcmVzZW50IGluIHRoZSB1c2VyIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PENhdGVnb3JpY2FsVmFyaWFibGU+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgb3B0aW9ucyBjb250YWluIGFueSBjYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhc0NhdGVnb3JpY2FsVmFyaWFibGVzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vQ09OVElOVU9VU1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb250aW51b3VzIHZhcmlhYmxlcy5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8Q29udGludW91c1ZhcmlhYmxlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy9PUFRJT05BTFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcHRpb25hbCB2YXJpYWJsZXMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PERhdGFWYXJpYWJsZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcHRpb25hbFZhcmlhYmxlcyA9IFtdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgRmlsZVJlYWRlciB1c2VkIHRvIHJlYWQgYSBwb3J0aW9uIG9mIHRoZSBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtGaWxlUmVhZGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5jcmVhdGVGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7IHRoaXMub25NZXNzYWdlKGUuZGF0YSk7IH07XHJcblxyXG4gICAgICAgIC8vU0FWRSBJTkZPUk1BVElPTlxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gc2F2ZSB0aGUgcm93cyBkaXJlY3RseSByZWFkIGZyb20gdGhlIGZpbGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8c3RyaW5nfG51bWJlcj4+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YVJvd3NTYXZlZCA9IFtdOyAvL1NhdmUgcm93cyByZWFkIGJ5IHRoaXMgV29ya2VyXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZpbmFsIGRhdGEgcm93cyB3aGljaCBjb250YWluIGFsbCBpbmZvcm1hdGlvbiB0byBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8e2NvbnRpbnVvdXNEYXRhOiBBcnJheTxBcnJheTxudW1iZXI+Piwgc3BhdGlhbERhdGE6IEFycmF5PG51bWJlcj4sb3B0aW9uYWxEYXRhOiBBcnJheTxBcnJheTxudW1iZXJ8c3RyaW5nPj4sIFJHQkE6IEFycmF5PG51bWJlcj4sIG51bWJlclJHQkE6IEFycmF5PG51bWJlcj59Pj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maW5hbERhdGFSb3dzID0gW107XHJcbiAgICAgICAgLy8gdGhpcy5udW1Sb3dzUmVhZCA9IDA7XHJcblxyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBXaWxsIGJlIHRydWUgd2hlbiB3ZSB3YW50IHRvIHByb2Nlc3MgdGhlIGxhc3QgbGluZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzTGFzdExpbmUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBmaWxlIHJlYWRlci5cclxuICAgICAqIEByZXR1cm5zIHtGaWxlUmVhZGVyfSAtIHRoZSBGaWxlUmVhZGVyIHVzZWQgdG8gcmVhZCBhIHBvcnRpb24gb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBjcmVhdGVGaWxlUmVhZGVyKCkge1xyXG4gICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4geyB0aGlzLmNodW5rUmVhZEZyb21GaWxlKGUpOyB9O1xyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGUpID0+IHsgY29uc29sZS5lcnJvcihlKTsgfTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgd29ya2VyIHJlY2VpdmVzIGEgbWVzc2FnZS4gXHJcbiAgICAgKiBAcGFyYW0ge3twcm90b2NvbE1lc3NhZ2U6IHN0cmluZywgbWVzc2FnZURhdGE6T2JqZWN0fX0gZGF0YU1lc3NhZ2UgLSBUaGUgZGF0YSBtZXNzYWdlIHRoYXQgd2FzIHNlbnQgYnkgdGhlIG1haW4gVGhyZWFkLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgb25NZXNzYWdlKGRhdGFNZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tQ1NWIERhdGEgV29ya2VyLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhTWVzc2FnZSk7XHJcbiAgICAgICAgbGV0IHByb3RvY29sTWVzc2FnZXMgPSBHaXNwbGF5RGVmYXVsdHMuTUVTU0FHRVNfQ1NWKCk7XHJcbiAgICAgICAgc3dpdGNoIChkYXRhTWVzc2FnZS5wcm90b2NvbE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX1NUQVJUOiB7IC8vV29ya2VyIHByb2Nlc3NlZCBpdCdzIHBhcnRcclxuICAgICAgICAgICAgICAgIC8vRmlsZSBhbmQgY2h1bmsgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgIGxldCB3b3JrZXJPcHRpb25zID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEud29ya2VyT3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUZpbGUgPSB3b3JrZXJPcHRpb25zLmRhdGFGaWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJ5dGUgPSB3b3JrZXJPcHRpb25zLnN0YXJ0Qnl0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kQnl0ZSA9IHdvcmtlck9wdGlvbnMuZW5kQnl0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtTaXplID0gd29ya2VyT3B0aW9ucy5jaHVua1NpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlckluZGV4ID0gd29ya2VyT3B0aW9ucy53b3JrZXJJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtQ29sdW1uc1BlclJvdyA9IHdvcmtlck9wdGlvbnMubnVtQ29sdW1uc1BlclJvdztcclxuICAgICAgICAgICAgICAgIHRoaXMucm93RGVsaW1pdGVyID0gd29ya2VyT3B0aW9ucy5yb3dEZWxpbWl0ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkRlbGltaXRlciA9IHdvcmtlck9wdGlvbnMuY29sdW1uRGVsaW1pdGVyO1xyXG4gICAgICAgICAgICAgICAgLy9JbmRpY2VzIGFuZCBjbGFzcyBjYWxjXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckluZGljZXMgPSB3b3JrZXJPcHRpb25zLmhlYWRlckluZGljZXM7XHJcbiAgICAgICAgICAgICAgICAvL1NhdmUgQ2F0ZWdvcmljYWwvQ29udGludW91cyBhbmQgdGltZSBWYXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlVmFyaWFibGVzKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLndvcmtlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgLy9TdGFydCByZWFkaW5nIGZpbGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZE5leHRDaHVuaygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX0xJTUlUU19DQVQ6IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9fTElNSVRfQ0FUXCIpXHJcbiAgICAgICAgICAgICAgICBsZXQgY2F0VmFyc0NhdGVnb3JpZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhdFZhciBvZiB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdFZhcnNDYXRlZ29yaWVzTWFwLnNldChjYXRWYXIuZ2V0SW50ZXJuYWxOYW1lKCksIGNhdFZhci5nZXRDYXRlZ29yaWVzKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBjb250VmFyc01pbk1heE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udFZhciBvZiB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udFZhcnNNaW5NYXhNYXAuc2V0KGNvbnRWYXIuZ2V0SW50ZXJuYWxOYW1lKCksIFtjb250VmFyLmdldE1pbigpLCBjb250VmFyLmdldE1heCgpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgY2F0VmFyc0NhdGVnb3JpZXNNYXAsIGNvbnRWYXJzTWluTWF4TWFwLCB0aGlzLnRpbWVWYXJpYWJsZSwgdGhpcy50aW1lVmFyaWFibGUuZ2V0VGVtcG9yYWxHcmFudWxlc1NldCgpKVxyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9MSU1JVFNfQ0FULFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpY2FsVmFyaWFibGVzOiBjYXRWYXJzQ2F0ZWdvcmllc01hcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGlub3VzVmFyaWFibGVzOiBjb250VmFyc01pbk1heE1hcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVZhcmlhYmxlOiB0aGlzLnRpbWVWYXJpYWJsZSA/IHRoaXMudGltZVZhcmlhYmxlLmdldFRlbXBvcmFsR3JhbnVsZXNTZXQoKSA6IHRoaXMudGltZVZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fTElNSVRTX0NBVF9SRVM6IHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250aW5vdXNWYXJzTWluTWF4ID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbaSwgY29udFZhcl0gb2YgdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0TWluTWF4KGNvbnRpbm91c1ZhcnNNaW5NYXhbaV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0TWluTWF4KGNvbnRpbm91c1ZhcnNNaW5NYXhbaV1bMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0U3RlcCgpOyAvL1VwZGF0ZSBzdGVwIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Mb29wIHRocm91Z2ggZGF0YSBhbmQgY2FsY3VsYXRlIGJpbnMgZm9yIGVhY2ggY29udGludW91cyB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRQb3NTdGFydCA9IHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRQb3NFbmQgPSBjb250UG9zU3RhcnQgKyB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGF0YSBvZiB0aGlzLmRhdGFSb3dzU2F2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRQb3NTdGFydDsgaSA8IGNvbnRQb3NFbmQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51b3VzVmFyaWFibGVzW2kgLSBjb250UG9zU3RhcnRdLmFkZFZhbHVlVG9CaW5zKGRhdGFbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBoaXN0b2dyYW1zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRWYXIgb2YgdGhpcy5jb250aW51b3VzVmFyaWFibGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpc3RvZ3JhbXMucHVzaChjb250VmFyLmdldEhpc3RvZ3JhbSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXNbMF0uZ2V0SGlzdG9ncmFtKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9MSU1JVFNfQ0FUX1JFUyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b2dyYW1zOiBoaXN0b2dyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fSk9JTl9EQVRBOiB7XHJcbiAgICAgICAgICAgICAgICAvL1Byb2Nlc3MgZGF0YSBhbmQgdGhlbiBzZW5kIHRoZSByZXMgZGF0YVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud29ya2VySW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkkgd2lsbCBwcm9jZXNzIHRoZSBkYXRhLi4uLk5PVFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY2F0VmFycyA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLmNhdGVnb3JpY2FsVmFyaWFibGVzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgY2F0VmFyXSBvZiBjYXRWYXJzLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzW2ldLnZhbHVlVG9JbmRleE1hcCA9IGNhdFZhci52YWx1ZVRvSW5kZXhNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRWYXJzID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEuY29udGludW91c1ZhcmlhYmxlcztcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIGNvbnRWYXJdIG9mIGNvbnRWYXJzLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXNbaV0uY2xhc3NJbnRlcnZhbHMgPSBjb250VmFyLmNsYXNzSW50ZXJ2YWxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB0VmFyID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEudGltZVZhcmlhYmxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRWYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUudGVtcG9yYWxHcmFudWxlc01hcCA9IHRWYXIudGVtcG9yYWxHcmFudWxlc01hcDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnRGF0YSA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhO1xyXG4gICAgICAgICAgICAgICAgbGV0IG12Y3MgPSBtc2dEYXRhLm12Y3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyTVZDcyA9IG12Y3Muc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJUR3MgPSBtc2dEYXRhLm51bWJlclRHcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2pvaW5EYXRhKG12Y3MsIG51bWJlclRHcyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBudW1Ub3RhbEVsZW1lbnRzID0gMDsgLy9DcmVhdGUgYXJyYXkgdG8gc2VuZCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIHdvcmtlclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmZpbmFsRGF0YVJvd3MpO1xyXG4gICAgICAgICAgICAgICAgLyogICAgaWYgKHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJNVkNzOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyVEdzOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3RhbEVsZW1lbnRzICs9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5jb250aW51b3VzRGF0YVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcIlwiKTsgKi9cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTVZDczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJUR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdGFsRWxlbWVudHMgKz0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3RhbEVsZW1lbnRzICs9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGg7IC8vSWRzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG51bVRvdGFsRWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9KT0lOX0RBVEEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtVG90YWxFbGVtZW50czogbnVtVG90YWxFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VySW5kZXg6IHRoaXMud29ya2VySW5kZXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19HRU5FUkFURV9SR0JBOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgR2VuZXJhdGUgUkdCQXMgZm9yIGFsbCBNVkNzL1RHcyBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlUkdCQUNvZGVzKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhKTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfR0VORVJBVEVfUkdCQSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19TRU5EX0RBVEE6IHtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9TRU5EX0RBVEEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhUm93czogdGhpcy5maW5hbERhdGFSb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIFJHQkEgY29kZXMgZm9yIGVhY2ggZWxlbWVudCBpbiBlYWNoIE1WQy9URy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPn0gc3RhcnRSR0JBTnVtIC0gVGhlIHN0YXJ0IFJHQkEgbnVtYmVyIGZvciB0aGlzIHdvcmtlci4uIFxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ld0RhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgX2dlbmVyYXRlUkdCQUNvZGVzKHN0YXJ0UkdCQU51bSkge1xyXG4gICAgICAgIGxldCBudW1NVkNzID0gdGhpcy5maW5hbERhdGFSb3dzLmxlbmd0aCxcclxuICAgICAgICAgICAgbnVtVEdzID0gdGhpcy5maW5hbERhdGFSb3dzWzBdLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1WQ3M7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBsZXQgc3RhcnRSR0JBID0gc3RhcnRpbmdSR0JBTnVtYmVyW2ldLFxyXG4gICAgICAgICAgICAvLyBsZXQgc3RhcnRSR0JBTnVtID0gR2lzcGxheURlZmF1bHRzLlJHQkFUb051bWJlciguLi5zdGFydFJHQkEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVRHczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtYmVyT2ZFbGVtZW50cyA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkVsZW1lbnRzID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mRWxlbWVudHMgPSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uc3BhdGlhbERhdGEubGVuZ3RoOyAvL0lkc1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLmNvbnRpbnVvdXNEYXRhWzBdLmxlbmd0aDsgLy9Vc2luZyBjb250aW51b3VzIGRhdGEgdGhhdCBtaWdodCBub3QgZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZkVsZW1lbnRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtYmVyT2ZFbGVtZW50czsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSR0JBID0gR2lzcGxheURlZmF1bHRzLm51bWJlclRvUkdCQShzdGFydFJHQkFOdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uUkdCQS5wdXNoKC4uLlJHQkEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0ubnVtYmVyUkdCQS5wdXNoKHN0YXJ0UkdCQU51bSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZXJpZnlJbnRlZ3JpdHlSR0JBKG51bU1WQ3MsIG51bVRHcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmVyaWZ5SW50ZWdyaXR5UkdCQShudW1NVkNzLCBudW1UR3MpIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJWRVJJRlkgSU5URUdSSVRZXCIpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NVkNzOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1UR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlckluZGljZXNbMl0ubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aDsgLy9JZHNcclxuICAgICAgICAgICAgICAgIGlmIChjb250aW51b3VzRGF0YUxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb250aW51b3VzRGF0YUxlbmd0aCAtIDE7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLm51bWJlclJHQkFba10gKyAxID09PSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0ubnVtYmVyUkdCQVtrICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSm9pbiB0aGUgZGF0YSBpbnRvIE1WQ3MgYW5kIFRHcy5cclxuICAgICAqIEBwYXJhbSB7TWFwPHN0cmluZywgbnVtYmVyPn0gbXZjcyAtIFRoZSBnZW5lcmF0ZWQgTVZDcyBtYXAgYW5kIHJlc3BlY3RpdmUgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyVEdzIC0gVGhlIG51bWJlciBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZOZXdEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIF9qb2luRGF0YShtdmNzLCBudW1iZXJUR3MpIHtcclxuICAgICAgICAvL0xvb3AgdGhyb3VnaCByb3dzIGFuZCBjb3B5IHRoZW0gdG8gdGhlIGZpbmFsIGFycmF5XHJcbiAgICAgICAgLy9jYXRlZ29yaWNhbCB2YXJzIGFuZCB0aW1lIHZhciBjYW4gYmUgaWdub3JlZCAodGhleSBhcmUga25vd24gYnkgdGhlIGFycmF5cyBpbmRpY2VzKVxyXG4gICAgICAgIC8vU2F2ZSBjb250IHZhcnMsIGdlb21ldHJ5LCBvcHQgdmFycyBhbmQgUkdCQSB2YWx1ZVxyXG5cclxuICAgICAgICBsZXQgaGFzSWRzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aCA/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgICBsZXQgZ2VvUG9zaXRpb25zID0gaGFzSWRzID8gMSA6IDI7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2Fybih0aGlzLnRpbWVWYXJpYWJsZSwgbXZjcyk7XHJcbiAgICAgICAgbGV0IG51bWJlck1WQ3MgPSBtdmNzLnNpemUsXHJcbiAgICAgICAgICAgIG51bUNhdFZhcnMgPSB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgbnVtQ29udFZhcnMgPSB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBnZW9TdGFydFBvcyA9IG51bUNhdFZhcnMgKyBudW1Db250VmFycyxcclxuICAgICAgICAgICAgZ2VvRW5kUG9zID0gZ2VvU3RhcnRQb3MgKyBnZW9Qb3NpdGlvbnMsXHJcbiAgICAgICAgICAgIHRpbWVQb3MgPSBnZW9FbmRQb3M7XHJcblxyXG4gICAgICAgIHRoaXMuZmluYWxEYXRhUm93cyA9IHRoaXMuX2NyZWF0ZUZpbmFsUm93cyhudW1iZXJNVkNzLCBudW1iZXJUR3MpO1xyXG4gICAgICAgIC8vRm9yIGVhY2ggcm93IHNhdmVkIHRoZW4gc3BsaXQgaXQgdG8gaXRzIHBsYWNlXHJcbiAgICAgICAgZm9yIChjb25zdCByb3dTYXZlZCBvZiB0aGlzLmRhdGFSb3dzU2F2ZWQpIHtcclxuICAgICAgICAgICAgbGV0IGZpbmFsUm93ID0gW107XHJcbiAgICAgICAgICAgIGxldCBjb21iaW5hdGlvbiA9ICcnO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgW2ksIGNhdFZhcl0gb2YgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbiArPSBjYXRWYXIuZmluZEluZGV4KHJvd1NhdmVkW2ldKTtcclxuICAgICAgICAgICAgbGV0IGNvbnRWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgW2osIGNvbnRWYXJdIG9mIHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250VmFsdWUgPSByb3dTYXZlZFtqICsgbnVtQ2F0VmFyc107XHJcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbiArPSBjb250VmFyLmZpbmRDbGFzc0ludGVydmFsSW5kZXgoY29udFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRWYWx1ZXMucHVzaChjb250VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbXZjSW5kZXggPSBtdmNzLmdldChjb21iaW5hdGlvbik7XHJcbiAgICAgICAgICAgIGxldCB0Z0luZGV4ID0gdGhpcy50aW1lVmFyaWFibGUgIT09IHVuZGVmaW5lZCA/IHRoaXMudGltZVZhcmlhYmxlLmdldFRHTWFwSW5kZXgocm93U2F2ZWRbdGltZVBvc10pIDogMDtcclxuICAgICAgICAgICAgaWYgKHRnSW5kZXggPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJIRVJFXCIpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udFZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxEYXRhUm93c1ttdmNJbmRleF1bdGdJbmRleF0uY29udGludW91c0RhdGFbaV0ucHVzaChjb250VmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGdlb1N0YXJ0UG9zOyBpIDwgZ2VvRW5kUG9zOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbbXZjSW5kZXhdW3RnSW5kZXhdLnNwYXRpYWxEYXRhLnB1c2gocm93U2F2ZWRbaV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGltZVBvcyArIDE7IGkgPCByb3dTYXZlZC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxEYXRhUm93c1ttdmNJbmRleF1bdGdJbmRleF0ub3B0aW9uYWxEYXRhW2kgLSB0aW1lUG9zIC0gMV0ucHVzaChyb3dTYXZlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YVJvd3NTYXZlZCA9IHVuZGVmaW5lZDsgLy9BbGxvd3MgR2FyYmFnZSBjb2xsZWN0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGZpbmFsIHJvdyB0byBob2xkIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHRoZSB3b3JrZXIgc2hvdWxkIHNlbmQgYXQgdGhlIGVuZCB0byB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyTVZDcyAtIE51bWJlciBvZiBleGlzdGluZyBtYXAgdmFyaWFibGUgY29tYmluYXRpb25zLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclRHcyAtIE51bWJlciBvZiBleGlzdGluZyB0ZW1wb3JhbCBncmFudWxlcyAuIFxyXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59IC0gdGhlIGZpbmFsIHJvdyB0byBob2xkIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHRoZSB3b3JrZXIgc2hvdWxkIHNlbmQgYXQgdGhlIGVuZCB0byB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWTmV3RGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBfY3JlYXRlRmluYWxSb3dzKG51bWJlck1WQ3MsIG51bWJlclRHcykge1xyXG4gICAgICAgIGxldCBmaW5hbFJvd3MgPSBbXTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgYXJyYXlzIGZvciBvcHRpb25hbERhdGFcclxuICAgICAgICBsZXQgb3B0aW9uYWxEYXRhQXJyYXlzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbmFsVmFyaWFibGVzLmxlbmd0aDsgaSsrKSAvL0NyZWF0ZSBtdWx0aXBsZSBhcnJheXMgb25lIGZvciBlYWNoIG9wdGlvbmFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIG9wdGlvbmFsRGF0YUFycmF5c1tpXSA9IFtdO1xyXG5cclxuICAgICAgICBsZXQgY29udGludW9zRGF0YUFycmF5cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmxlbmd0aDsgaSsrKSAvL0NyZWF0ZSBtdWx0aXBsZSBhcnJheXMgb25lIGZvciBlYWNoIG9wdGlvbmFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIGNvbnRpbnVvc0RhdGFBcnJheXNbaV0gPSBbXTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgYXJyYXkgZm9yIGZpbmFsIFJvd3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck1WQ3M7IGkrKykge1xyXG4gICAgICAgICAgICBmaW5hbFJvd3NbaV0gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJUR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgZmluYWxSb3dzW2ldW2pdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhOiBHaXNwbGF5RGVmYXVsdHMuY2xvbmVOZXN0ZWRBcnJheShjb250aW51b3NEYXRhQXJyYXlzKSxcclxuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsRGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxEYXRhOiBHaXNwbGF5RGVmYXVsdHMuY2xvbmVOZXN0ZWRBcnJheShvcHRpb25hbERhdGFBcnJheXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJHQkE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclJHQkE6IFtdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZmluYWxSb3dzKTtcclxuICAgICAgICByZXR1cm4gZmluYWxSb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGUgdGhlIHZhcmlhYmxlcyBzZW50IGJ5IHRoZSBtYWluIHRocmVhZC5cclxuICAgICAqIEBwYXJhbSB7e2NvbnRpbm91c1ZhcmlhYmxlczogQXJyYXk8Q29udGludW91c1ZhcmlhYmxlPiwgY2F0ZWdvcmljYWxWYXJpYWJsZXM6IEFycmF5PENhdGVnb3JpY2FsVmFyaWFibGU+LCB0aW1lVmFyaWFibGU6IFRpbWVWYXJpYWJsZX19IGRhdGEgLSBEYXRhIHNlbnQgYnkgdGhlIG1haW4gdGhyZWFkLlxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ld0RhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgX3NhdmVWYXJpYWJsZXMoZGF0YSkge1xyXG4gICAgICAgIGxldCBjb250VmFycyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udFZhciBvZiBkYXRhLmNvbnRpbnVvdXNWYXJpYWJsZXMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coY29udFZhcik7XHJcbiAgICAgICAgICAgIGNvbnRWYXJzLnB1c2gobmV3IENvbnRpbnVvdXNWYXJpYWJsZShcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuZXh0ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5pbnRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb250VmFyLnR5cGVPZlZpc3VhbFZhcmlhYmxlLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5zaGFkZXJWYXJpYWJsZVF1YWxpZmllcixcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIudmlzdWFsVmFyaWFibGVNYXBwaW5nLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrcyxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIubnVtYmVyT2ZDbGFzc2VzLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrTWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrTWV0aG9kUGFyYW1zXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXQgZG9hID0gdHJ1ZTtcclxuICAgICAgICAvLyBpZiAoZG9hKSB7XHJcbiAgICAgICAgbGV0IGNhdFZhcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhdFZhciBvZiBkYXRhLmNhdGVnb3JpY2FsVmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgIGNhdFZhcnMucHVzaChuZXcgQ2F0ZWdvcmljYWxWYXJpYWJsZShcclxuICAgICAgICAgICAgICAgIGNhdFZhci5leHRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjYXRWYXIuaW50ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnR5cGVPZlZpc3VhbFZhcmlhYmxlLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnNoYWRlclZhcmlhYmxlUXVhbGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnZpc3VhbFZhcmlhYmxlTWFwcGluZyxcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdFZhciA9IGRhdGEudGltZVZhcmlhYmxlO1xyXG4gICAgICAgIGxldCB0aW1lVmFyaWFibGU7XHJcbiAgICAgICAgaWYgKHRWYXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aW1lVmFyaWFibGUgPSBuZXcgVGltZVZhcmlhYmxlKFxyXG4gICAgICAgICAgICAgICAgdFZhci5leHRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICB0VmFyLmludGVybmFsTmFtZSxcclxuICAgICAgICAgICAgICAgIHRWYXIuZ3JhbnVsYXJpdHksXHJcbiAgICAgICAgICAgICAgICB0VmFyLnRpbWVDb250cm9sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvcHRWYXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBvcHRWYXIgb2YgZGF0YS5vcHRpb25hbFZhcmlhYmxlcylcclxuICAgICAgICAgICAgb3B0VmFycy5wdXNoKG5ldyBEYXRhVmFyaWFibGUob3B0VmFyLmV4dGVybmFsTmFtZSwgb3B0VmFyLmludGVybmFsTmFtZSkpO1xyXG5cclxuICAgICAgICAvL1RJTUVcclxuICAgICAgICAvLyB0aGlzLnRpbWVWYXJpYWJsZSA9IHdvcmtlck9wdGlvbnMudGltZVZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMudGltZVZhcmlhYmxlID0gdGltZVZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMudGltZUdyYW51bGFyaXR5ID0gdGhpcy50aW1lVmFyaWFibGUgPyB0aGlzLnRpbWVWYXJpYWJsZS5nZXRHcmFudWxhcml0eSgpIDogJyc7XHJcbiAgICAgICAgLy9DQVRFR09SSUNBTFxyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMgPSBjYXRWYXJzOy8vd29ya2VyT3B0aW9ucy5jYXRlZ29yaWNhbFZhcmlhYmxlcztcclxuICAgICAgICB0aGlzLmhhc0NhdGVnb3JpY2FsVmFyaWFibGVzID0gdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIC8vQ09OVElOT1VTIFxyXG4gICAgICAgIHRoaXMuY29udGludW91c1ZhcmlhYmxlcyA9IGNvbnRWYXJzOy8vd29ya2VyT3B0aW9ucy5jb250aW51b3VzVmFyaWFibGVzO1xyXG4gICAgICAgIC8vT1BUSU9OQUwgVkFSU1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWxWYXJpYWJsZXMgPSBvcHRWYXJzO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgY2h1bmsgb2YgYnl0ZXMgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIHJlYWROZXh0Q2h1bmsoKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5taW4odGhpcy5zdGFydEJ5dGUsIHRoaXMuZW5kQnl0ZSk7XHJcbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMuc3RhcnRCeXRlICsgdGhpcy5jaHVua1NpemUsIHRoaXMuZW5kQnl0ZSk7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIucmVhZEFzVGV4dCh0aGlzLmRhdGFGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIG1vcmUgMTAwMCBieXRlcyB0byBmaW5pc2ggdGhlIGxhc3QgbGluZSBvZiB0aGUgd29ya2VyLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgcmVhZExhc3RMaW5lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RXb3JrZXJSb3cubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0Qnl0ZSwgdGhpcy5lbmRCeXRlKTtcclxuICAgICAgICBsZXQgZW5kID0gdGhpcy5lbmRCeXRlICsgMTAwMDtcclxuICAgICAgICB0aGlzLnJlYWRlci5yZWFkQXNUZXh0KHRoaXMuZGF0YUZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIGEgY2h1bmsgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBlIC0gRXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWFkIGRhdGEuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBjaHVua1JlYWRGcm9tRmlsZShlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0TGluZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJsYXN0IGxpbmVcIiwgdGhpcy53b3JrZXJJbmRleCwgZS50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgbGV0IHJvd3MgPSAodGhpcy5sYXN0V29ya2VyUm93ICsgZS50YXJnZXQucmVzdWx0KS5zcGxpdCh0aGlzLnJvd0RlbGltaXRlcik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2Fybih0aGlzLndvcmtlckluZGV4LCByb3dzKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUm93cyhyb3dzLCAwLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRU5EU3RhcnRNZXNzYWdlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydEJ5dGUgKz0gdGhpcy5jaHVua1NpemU7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NodW5rKGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Qnl0ZSA+PSB0aGlzLmVuZEJ5dGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRU5EXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJOdW1Sb3dzIFdvcmtlclwiLCB0aGlzLndvcmtlckluZGV4LCBcImlzOlwiLCB0aGlzLm51bVJvd3NSZWFkLCBcIlxcbkZJUlNUUk9XID0gXCIsIHRoaXMuZmlyc3RXb3JrZXJSb3csIFwiXFxuTEFTVFJPVyA9IFwiLCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG4gICAgICAgICAgICAgICAgLy9Qb3N0IG1lc3NhZ2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCByb3dcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIndvcmtlciBUZXJtaW5hdGVkXCIsIHRoaXMud29ya2VySW5kZXgsIHRoaXMuZmlyc3RXb3JrZXJSb3csIHRoaXMubGFzdFdvcmtlclJvdyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGFzdExpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzRG9uZSA9IHRoaXMucmVhZExhc3RMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSAvL09ubHkgdGhlIG9uZXMgdGhhdCByZXR1cm5lZCB0cnVlIGZyb20gdGhlIHJlYWRMYXN0TGluZSgpIG1ldGhvZCB3aWxsIHNlbmQgYmFjayB0byB0aGUgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRU5EU3RhcnRNZXNzYWdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkTmV4dENodW5rKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbmRFTkRTdGFydE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiRU5EXCIsIHRoaXMud29ya2VySW5kZXgsIHRoaXMuZGF0YVJvd3NTYXZlZC5sZW5ndGgpO1xyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogR2lzcGxheURlZmF1bHRzLk1FU1NBR0VTX0NTVigpLkVORF9TVEFSVCxcclxuICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgIHdvcmtlckluZGV4OiB0aGlzLndvcmtlckluZGV4LFxyXG4gICAgICAgICAgICAgICAgLy8gZmlyc3RXb3JrZXJSb3c6IHRoaXMuZmlyc3RXb3JrZXJSb3csXHJcbiAgICAgICAgICAgICAgICAvLyBsYXN0V29ya2VyUm93OiB0aGlzLmxhc3RXb3JrZXJSb3dcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgY2h1bmsgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9wdC1QVC9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3BsaXRcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9pbWFnZS5wcm50c2NyLmNvbS9pbWFnZS9Ca2FScDhxU1F1eXQ5cGhvU2g3MVpBLnBuZ1xyXG4gICAgICogQHNlZSBodHRwczovL2ltYWdlLnBybnRzY3IuY29tL2ltYWdlL0ZBUThDVkg5UzFXNlgwUm9ack9XZncucG5nIC0gRWRnZSBjYXNlIGZvciBcXHJcXG4uXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vaW1hZ2UucHJudHNjci5jb20vaW1hZ2UveVlYV2Nad0xRalNOWXFJaXVRRWNLUS5wbmcgLSBFZGdlIGNhc2UgZXhhbXBsZS5cclxuICAgICAqIEBwYXJhbSB7YW55fSBjaHVua1RleHQgIC0gVGhlIHRleHQgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0NodW5rKGNodW5rVGV4dCkge1xyXG4gICAgICAgIGxldCByb3dzID0gKHRoaXMucmVtYWluaW5nQ2h1bmtSb3cgKyBjaHVua1RleHQpLnNwbGl0KHRoaXMucm93RGVsaW1pdGVyKTsgLy9NYXkgbm90IGhhdmUgdGhlIGJlc3QgcGVyZm9ybWFuY2UgKGhhcyB0byBjcmVhdGUgbmV3IHN0cmluZyBkdWUgdG8gc3RyaW5nIGltbXV0YWJpbGl0eSkuIENvdWxkIGJlIGNoYW5nZWQgYnV0IHNvbHV0aW9uIGhhcyB0byBzb2x2ZSB0aGUgRURHRSBDQVNFLlxyXG4gICAgICAgIHRoaXMucmVtYWluaW5nQ2h1bmtSb3cgPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IFtzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleF0gPSBbMCwgcm93cy5sZW5ndGggLSAxXTsgLy9UaGUgaW5kZXggdG8gc3RhcnQgYW5kIGVuZCB0aGUgcm93cyBwcm9jZXNzaW5nXHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0V29ya2VyUm93KSB7IC8vU2F2ZSAxc3Qgcm93IG9mIHRoaXMgd29ya2VyIFxyXG4gICAgICAgICAgICB0aGlzLmZpcnN0V29ya2VyUm93ID0gcm93c1swXTtcclxuICAgICAgICAgICAgc3RhcnRSb3dJbmRleCA9IDE7IC8vSWdub3JlIGZpcnN0IHJvdyBvZiBmaXJzdCBjaHVuayBpbiBhbnkgd29ya2VyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5sYXN0V29ya2VyUm93ICYmIHRoaXMuc3RhcnRCeXRlID49IHRoaXMuZW5kQnl0ZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLndvcmtlckluZGV4LCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RXb3JrZXJSb3cgPSB0aGlzLnJlbWFpbmluZ0NodW5rUm93OyAvL1NhdmUgbGFzdCByb3cgaWYgaXQncyB0aGUgbGFzdCBjaHVuayAoU2VlIHNwbGl0IGltYWdlKSBcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgcm93cywgdGhpcy5kYXRhUm93c1NhdmVkLCB0aGlzLmZpcnN0V29ya2VyUm93LCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcih0aGlzLndvcmtlckluZGV4LCB0aGlzLnJlbWFpbmluZ0NodW5rUm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUm93cyhyb3dzLCBzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIHRoZSByb3dzIHRoYXQgYXJlIGluIHRoZSByb3dzIGFycmF5LiBUaGUgZmlyc3Qgcm93IG9mIHRoZSAxc3QgY2h1bmsgcmVhZCBmcm9tIHRoZSBmaWxlIHNob3VsZCBiZSBpZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSByb3dzIC0gVGhlIHJvd3MsIGVhY2ggb25lIGluIGEgcG9zaXRpb24gb2YgdGhlIGFycmF5LiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvd0luZGV4IC0gVGhlIHJvdyB0byBzdGFydCBwcm9jZXNzaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFJvd0luZGV4IC0gVGhlIGxhc3Qgcm93IHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzUm93cyhyb3dzLCBzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCkge1xyXG4gICAgICAgIGxldCByZXNSb3dzID0gW107XHJcbiAgICAgICAgLy8gdGhpcy5udW1Sb3dzUmVhZCArPSAoZW5kUm93SW5kZXggLSBzdGFydFJvd0luZGV4KTsgLy9ERUxFVEVcclxuICAgICAgICBsZXQgY2F0ZWdvcmljYWxJbmRpY2VzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzBdO1xyXG4gICAgICAgIGxldCBjb250aW51b3VzSW5kaWNlcyA9IHRoaXMuaGVhZGVySW5kaWNlc1sxXTtcclxuICAgICAgICBsZXQgZ2VvbWV0cnlJbmRpY2VzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzJdO1xyXG4gICAgICAgIGxldCBoYXNJZEdlb21ldHJ5ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCtnZW9tZXRyeUluZGljZXMgPT09ICtnZW9tZXRyeUluZGljZXMpIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnlJbmRpY2VzID0gW2dlb21ldHJ5SW5kaWNlc107XHJcbiAgICAgICAgICAgIGhhc0lkR2VvbWV0cnkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGltZUluZGV4ID0gdGhpcy5oZWFkZXJJbmRpY2VzWzNdO1xyXG4gICAgICAgIGxldCBoYXNUaW1lID0gdGhpcy50aW1lR3JhbnVsYXJpdHkgIT09ICcnOyAvL09SIHRoaXMudGltZVZhcmlhYmxlICE9PSB1bmRlZmluZWRcclxuICAgICAgICBsZXQgb3B0aW5hbEluZGljZXMgPSB0aGlzLmhlYWRlckluZGljZXNbNF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPCBlbmRSb3dJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtUm93c1JlYWQrKztcclxuICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSByb3dzW2ldLnNwbGl0KHRoaXMuY29sdW1uRGVsaW1pdGVyKTtcclxuICAgICAgICAgICAgLyogaWYgKGNvbHVtbnMubGVuZ3RoICE9PSB0aGlzLm51bUNvbHVtbnNQZXJSb3cpIC8vQ2hlY2sgZm9yIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgbnVtYmVyIG9mIGNvbHVtbnNcIik7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBbaSwgY2F0SW5kZXhdIG9mIGNhdGVnb3JpY2FsSW5kaWNlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjYXRlZ29yeSA9IGNvbHVtbnNbY2F0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXNbaV0uY2xhc3NDYWxjdWxhdGlvblJlcXVpcmVkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlc1tpXS5hZGRDYXRlZ29yeShjYXRlZ29yeSk7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChjYXRlZ29yeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IFtpLCBjb250SW5kZXhdIG9mIGNvbnRpbnVvdXNJbmRpY2VzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gK2NvbHVtbnNbY29udEluZGV4XTtcclxuICAgICAgICAgICAgICAgIC8qIGlmICh2YWx1ZSA+PSA4MDAwMC4xMClcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXVVVVVFwiKTsgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludW91c1ZhcmlhYmxlc1tpXS5zZXRNaW5NYXgodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcm93LnB1c2godmFsdWUpOyAvL1N0cmluZyB0byBudW1iZXJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2VvSW5kZXggb2YgZ2VvbWV0cnlJbmRpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzSWRHZW9tZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbHVtbnNbZ2VvSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgrdmFsdWUgPT09ICt2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goK3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHZhbHVlLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCtjb2x1bW5zW2dlb0luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChoYXNUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ3JhbnVsZSA9IHRoaXMuZ2V0R3JhbnVsZShjb2x1bW5zW3RpbWVJbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUuYWRkVGVtcG9yYWxHcmFudWxlKGdyYW51bGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUuYWRkVGVtcG9yYWxHcmFudWxlVG9TZXQoZ3JhbnVsZSk7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChncmFudWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uYWxJbmRleCBvZiBvcHRpbmFsSW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCtjb2x1bW5zW29wdGlvbmFsSW5kZXhdID09PSArY29sdW1uc1tvcHRpb25hbEluZGV4XSkgLy9JdCdzIGEgbnVtYmVyP1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCtjb2x1bW5zW29wdGlvbmFsSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChjb2x1bW5zW29wdGlvbmFsSW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNSb3dzLnB1c2gocm93KTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhUm93c1NhdmVkLnB1c2gocm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgdGhpcy5kYXRhUm93c1NhdmVkLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBERUxFVEUgQU5EIFJlcGxhY2Ugd2l0aCBHaXNwbGF5RGVmYXVsdHMuZ2V0R3JhbnVsZSh0aW1lU3RyaW5nKVxyXG4gICAgICogQ29udmVydCB0aGUgdGltZSBzdHJpbmcgdG8gdGhlIGdyYW51bGFyaXR5IHdlIHdhbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZVN0cmluZyAtIFRoZSB0aW1lIGFzIGl0IHdhcyByZWFkIGZyb20gdGhlIGZpbGUuIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgZ3JhbnVsXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBnZXRHcmFudWxlKHRpbWVTdHJpbmcpIHtcclxuICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKHRpbWVTdHJpbmcsIHRoaXMudGltZUdyYW51bGFyaXR5KTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIC8vaWYgY3ljbGljIHRoZW4gLi4uXHJcbiAgICAgICAgZGF5IG9mIHllYXIgLT4gZGF5T2ZZZWFyIChuIHRlbW9zIClcclxuICAgICAgICBtb250aCBvZiB5ZWFyIC0+IG1vbnRoT2ZZZWFyICh0ZW1vcylcclxuICAgICAgICBkYXkgb2YgbW9udGggLT4gZGF5T2ZNb250aCAodGVtb3MpXHJcbiAgICAgICAgaG91ciBvZiBkYXkgLT4gaG91ck9mRGF5ICh0ZW1vcylcclxuICAgICAgICBtaW51dGUgb2YgaG91ciAtPiBtaW51dGVPZkhvdXIgKHRlbW9zKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vZWxzZSBjb250aW51b3VzXHJcbiAgICAgICAgeWVhciAtPiAyMDE1LCAyMDE2IC4uLlxyXG4gICAgICAgIG1vbnRoIC0+IDIwMTVfMDEsIDIwMTVfMDIgLi4uIDIwMTZfMDEgZXRjXHJcbiAgICAgICAgZGF5IC0+IDIwMTVfMDFfMDEsIDIwMTVfMDFfMDIgLi4uXHJcbiAgICAgICAgaG91ciAtPiAyMDE1XzAxXzAxXzAxLCAyMDE1XzAxXzAxXzAxIC4uLlxyXG4gICAgICAgIG1pbnV0ZVxyXG4gICAgICAgIHZhbHVlXHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnRpbWVHcmFudWxhcml0eSkge1xyXG4gICAgICAgICAgICAvL0NZQ0xJQ1xyXG4gICAgICAgICAgICBjYXNlICdtb250aE9mWWVhcic6IC8vTWVzIGRvIGFub1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAobmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIDEpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXlPZlllYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTsgLy9DSEFOR0UgdG8gY2FsY3VsYXRlIGRheSBvZiB5ZWFyXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5T2ZNb250aCc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERhdGUoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaG91ck9mRGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0SG91cnMoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlT2ZIb3VyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0TWludXRlcygpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy9DT05USU5VT1VTXHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogLy9NZXMgZG8gYW5vXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIl9cIiArIChuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiX1wiICsgKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1vbnRoKCkgKyAxKSArIFwiX1wiICsgbmV3IERhdGUodGltZVN0cmluZykuZ2V0RGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgPSBOdW1iZXIobmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiXCIgKyBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgXCJcIiArIG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERheSgpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICt0aW1lU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxubmV3IENTVkRhdGFXb3JrZXIoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvUGFyc2VyL0NTVi9GaWxlL0NTVkRhdGFXb3JrZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBZkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWdCQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFYQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBWUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUEzSUE7QUE2SUE7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUVBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWtCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUVBO0FBekNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBaUJBO0FBbEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFtQkE7QUFBQTtBQUNBO0FBQUE7QUFRQTtBQTVCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBeENBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF5Q0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUlBO0FBN0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXVCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBakNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBMENBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBaERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ })
/******/ ]);
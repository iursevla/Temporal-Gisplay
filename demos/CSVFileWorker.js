/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/GisplayDefaults.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.GisplayDefaults = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _defaults = __webpack_require__(/*! ./defaults.json */ 9);\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nvar _GisplayError = __webpack_require__(/*! ./GisplayError */ 2);\n\nvar _CategoricalVariable = __webpack_require__(/*! ./VVs/CategoricalVariable */ 3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class that exports the Gisplay default values.\r\n * @export\r\n * @class GisplayDefaults\r\n */\nvar GisplayDefaults = exports.GisplayDefaults = function () {\n    function GisplayDefaults() {\n        _classCallCheck(this, GisplayDefaults);\n    }\n\n    _createClass(GisplayDefaults, null, [{\n        key: 'getAvailableClassBreaksMethods',\n\n\n        /**\r\n         * Returns the available class break methods.\r\n         * @returns All available class break methods for the Temporal Gisplay API.\r\n         * @memberOf GisplayOptions\r\n         */\n        value: function getAvailableClassBreaksMethods() {\n            return {\n                QUANTILES: 'quantiles',\n                EQUAL_INTERVALS: 'equalintervals'\n            }; //defaultsFile.availableClasssBreakMethods; //[\"quantiles\", \"equalintervals\", \"k-means\"];\n        }\n\n        /**\r\n         * Returns a list of available background map providers.\r\n         * @returns - All available background map providers under Gisplay API.\r\n         * @memberof GisplayOptions\r\n         */\n\n    }, {\n        key: 'getAvailableBackgroundProviders',\n        value: function getAvailableBackgroundProviders() {\n            return {\n                GOOGLE_MAPS: 'GM',\n                MAPBOX: 'MB',\n                MAPBOXGL: 'MBGL',\n                HERE_MAPS: 'HM',\n                BING_MAPS: 'BM'\n            }; // defaultsFile.bgmapsProviders \n            /*['Google Maps', 'GM', //All variants of Google Maps\r\n                'Mapbox', 'MB', //All variants of Mapbox\r\n                'Here Maps', 'HM',\r\n                'Bing Maps', 'BM'];*/\n        }\n\n        /**\r\n         * TODO: DELETE\r\n         * Returns the default class method to calculate classes for continuous variables.\r\n         * @static\r\n         * @returns {string} - Returns quantiles, the default method for class calculation.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultClassBreakMethod',\n        value: function getDefaultClassBreakMethod() {\n            return _defaults2.default.defaultClassBreakMethod; //'equalintervals';\n        }\n\n        /**\r\n         * Returns the list of available granularities.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getAvailableGranularities',\n        value: function getAvailableGranularities() {\n            return ['monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour', 'year', 'month', 'day', 'value'];\n        }\n\n        /**\r\n         * Returns the list of available visual variables in the Temporal Gispaly API.\r\n         * @static\r\n         * @returns  the list of available visual variables in the Temporal Gispaly API.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getAvailableVisualVariables',\n        value: function getAvailableVisualVariables() {\n            return {\n                COLOR: 'color',\n                SHAPE: 'shape',\n                SIZE: 'size',\n                ORIENTATION: 'orientation',\n                TEXTURE: 'texture',\n                POSITION: 'position',\n                OPACITY: 'opacity'\n            };\n        }\n\n        /**\r\n         * Returns the available color brewer methods.\r\n         * @returns {Array<string>} - the available color brewer methods.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getAvailableColorBrewerMethods',\n        value: function getAvailableColorBrewerMethods() {\n            return ['colorbrewer-' + GisplayDefaults.SEQUENTIAL().toLocaleLowerCase(), 'colorbrewer-' + GisplayDefaults.DIVERGENT().toLocaleLowerCase(), 'colorbrewer-' + GisplayDefaults.QUALITATIVE().toLocaleLowerCase()];\n        }\n\n        /**\r\n         * List of colors that can be used to replace (hide) the background maps.\r\n         * @static\r\n         * @returns {Array<string>} - the list of colors that can be used to replace (hide) the background maps.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getBackgroundColors',\n        value: function getBackgroundColors() {\n            return ['white', 'black', 'tomato'];\n        }\n\n        /**\r\n         * Convert the time string to the granularity we want.\r\n         * @param {string} timeString - The time as it was read from the file. \r\n         * @returns {number} - The granul\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'getGranule',\n        value: function getGranule(timeString) {\n            var value = void 0;\n            // console.warn(timeString, this.timeGranularity);\n            /*\r\n                //if cyclic then ...\r\n                day of year -> dayOfYear (n temos )\r\n                month of year -> monthOfYear (temos)\r\n                day of month -> dayOfMonth (temos)\r\n                hour of day -> hourOfDay (temos)\r\n                minute of hour -> minuteOfHour (temos)\r\n                \r\n                //else continuous\r\n                year -> 2015, 2016 ...\r\n                month -> 2015_01, 2015_02 ... 2016_01 etc\r\n                day -> 2015_01_01, 2015_01_02 ...\r\n                hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n                minute\r\n                value\r\n            */\n            switch (this.timeGranularity) {\n                //CYCLIC\n                case 'monthOfYear':\n                    //Mes do ano\n                    value = new Date(timeString).getMonth() + 1; //GOOD\n                    break;\n                case 'dayOfYear':\n                    value = -1; //CHANGE to calculate day of year\n                    break;\n                case 'dayOfMonth':\n                    value = new Date(timeString).getDate(); //GOOD\n                    break;\n                case 'hourOfDay':\n                    value = new Date(timeString).getHours(); //GOOD\n                    break;\n                case 'minuteOfHour':\n                    value = new Date(timeString).getMinutes(); //GOOD\n                    break;\n\n                //CONTINUOUS\n                case 'year':\n                    value = new Date(timeString).getFullYear();\n                    break;\n                case 'month':\n                    //Mes do ano\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\n                    break;\n                case 'day':\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\n                    // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\n                    break;\n                case 'value':\n                    value = +timeString;\n                    break;\n            }\n            // console.log(value);\n            return value;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     VISUAL VARIABLES   ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The color visual variable.\r\n         * @static\r\n         * @returns {string} - the string 'color'.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'COLOR',\n        value: function COLOR() {\n            return _defaults2.default.visualVariables.COLOR;\n        }\n\n        /**\r\n         * The saturation visual variable.\r\n         * @static \r\n         * @returns {string} - The saturation visual variable string. \r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'OPACITY',\n        value: function OPACITY() {\n            return _defaults2.default.visualVariables.OPACITY;\n        }\n\n        /**\r\n         * The shape visual variable.\r\n         * @static\r\n         * @returns {string} - The shape visual  variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SHAPE',\n        value: function SHAPE() {\n            return _defaults2.default.visualVariables.SHAPE;\n        }\n\n        /**\r\n         * The position visual variable.\r\n         * @static\r\n         * @returns {string} - The position visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'POSITION',\n        value: function POSITION() {\n            return _defaults2.default.visualVariables.POSITION;\n        }\n\n        /**\r\n         * The variable that is used to hold the matrix projection \r\n         * @static\r\n         * @returns {string} - the projection matrix variable name on all shaders.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'MPROJ',\n        value: function MPROJ() {\n            return _defaults2.default.defaultShadersVariables.projectionMatrix;\n        }\n\n        /**\r\n         * The texture visual variable.\r\n         * @static\r\n         * @returns {string} - The texture visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'TEXTURE',\n        value: function TEXTURE() {\n            return _defaults2.default.visualVariables.TEXTURE;\n        }\n\n        /**\r\n         * The size visual variable.\r\n         * @static\r\n         * @returns {string} - The size visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SIZE',\n        value: function SIZE() {\n            return _defaults2.default.visualVariables.SIZE;\n        }\n\n        /**\r\n         * The orientation visual variable.\r\n         * @static\r\n         * @returns {string} - The orientation visual  variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'ORIENTATION',\n        value: function ORIENTATION() {\n            return _defaults2.default.visualVariables.ORIENTATION;\n        }\n\n        /**\r\n         * Returns the index of the given shape.\r\n         * @static\r\n         * @param {string} shapeName - The name of the given shape.\r\n         * @returns {number} - the index of the given shape.\r\n         * @throws {GisplayError} - If the given shape does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findShapeIndex',\n        value: function findShapeIndex(shapeName) {\n            // console.warn(shapeTextureName);\n            var shapeIndex = _defaults2.default.shapes[shapeName];\n            if (shapeIndex >= 0) return shapeIndex;\n            throw new _GisplayError.GisplayError('Shape with name: ' + shapeName + ', not found.');\n        }\n\n        /**\r\n         * Returns the index of the given pattern.\r\n         * @static\r\n         * @param {string} patternName - The name of the given pattern.\r\n         * @returns {number} - the index of the given pattern.\r\n         * @throws {GisplayError} - If the given pattern does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findPatternIndex',\n        value: function findPatternIndex(patternName) {\n            var patternIndex = _defaults2.default.patterns[patternName];\n            if (patternIndex >= 0) return patternIndex;\n            throw new _GisplayError.GisplayError('Pattern with name: ' + patternName + ', not found.');\n        }\n\n        /**\r\n         * Returns the index of the given figure name.\r\n         * @static\r\n         * @param {string} figureName - The figure name. \r\n         * @returns {number} - the index of the given figure name.\r\n         * @throws {GisplayError} - If the given figure does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findFigureIndex',\n        value: function findFigureIndex(figureName) {\n            var figureIndex = _defaults2.default.figures[figureName];\n            if (figureIndex >= 0) return figureIndex;\n            throw new _GisplayError.GisplayError('Figure with name: ' + figureName + ', not found.');\n        }\n\n        /**\r\n         * Returns the default color.\r\n         * @static\r\n         * @returns {Array<number>}  - the default color. \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultColor',\n        value: function getDefaultColor() {\n            return _defaults2.default.defaultColor;\n        }\n\n        /**\r\n         * Returns the index of the default shape.\r\n         * @static\r\n         * @returns {number} - the index of the default shape .\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultShapeIndex',\n        value: function getDefaultShapeIndex() {\n            return this.findShapeIndex(_defaults2.default.defaultShape); //GisplayDefaults.CIRCLE_FULL.name);\n        }\n\n        /**\r\n         * Returns the index of the default texture.\r\n         * @static\r\n         * @returns {number} - the index of the default texture.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultTextureIndex',\n        value: function getDefaultTextureIndex() {\n            return this.findShapeIndex(_defaults2.default.defaultTexture);\n        }\n\n        /**\r\n         * Returns the index of the default figure.\r\n         * @static\r\n         * @returns {number} - the index of the default figure.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultFigureIndex',\n        value: function getDefaultFigureIndex() {\n            return this.findFigureIndex(_defaults2.default.defaultFigure);\n        }\n\n        /**\r\n         * Returns the default size of a point for the Gisplay API.\r\n         * @static\r\n         * @returns {number=15} - the default size of a point for the Gisplay API.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultSizeValue',\n        value: function getDefaultSizeValue() {\n            return _defaults2.default.defaultSize;\n        }\n\n        /**\r\n         * Returns the minimum size for points.\r\n         * @static\r\n         * @returns {number} -  the minimum size for points.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMinSizeValue',\n        value: function getMinSizeValue() {\n            return _defaults2.default.minSize;\n        }\n\n        /**\r\n         * Returns the maximum size for points.\r\n         * @static\r\n         * @returns {number} -  the maximum size for points.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMaxSizeValue',\n        value: function getMaxSizeValue() {\n            return _defaults2.default.maxSize;\n        }\n\n        /**\r\n         * Returns the default orientation of a figure or shape in the Gisplay API.\r\n         * @static\r\n         * @returns {number=0} - the default orientation of a figure or shape in the Gisplay API. \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultOrientationValue',\n        value: function getDefaultOrientationValue() {\n            return _defaults2.default.defaultOrientation;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     IMAGE DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the size of the any shape image.\r\n         * @static\r\n         * @returns {number} - the size of the any shape image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getShapeImageSize',\n        value: function getShapeImageSize() {\n            return _defaults2.default.shapesImageSize;\n        }\n\n        /**\r\n         * Returns the size of the any pattern image.\r\n         * @static\r\n         * @returns {number} - the size of the any pattern image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getPatternImageSize',\n        value: function getPatternImageSize() {\n            return _defaults2.default.patternsImageSize;\n        }\n\n        /**\r\n         * Returns the size of the any figure image.\r\n         * @static\r\n         * @returns {number} - the size of the any figure image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getFigureImageSize',\n        value: function getFigureImageSize() {\n            return _defaults2.default.figuresImageSize;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     WEBGL DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The default alpha value for the \r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultAlphaValue',\n        value: function getDefaultAlphaValue() {\n            return _defaults2.default.defaultAlpha;\n        }\n\n        /**\r\n         * Returns the number of bytes for each element of a Float32Array.\r\n         * @static\r\n         * @returns {number} - the number of bytes for each element of a Float32Array.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getFloat32BytesPerElement',\n        value: function getFloat32BytesPerElement() {\n            return Float32Array.BYTES_PER_ELEMENT;\n        }\n\n        /**\r\n         * The number of bytes for each element of a Uint8Array (Unsigned int).\r\n         * @static\r\n         * @returns {number} - the number of bytes for each element of a Uint8Array (Unsigned int).\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getUint8BytesPerElement',\n        value: function getUint8BytesPerElement() {\n            return Uint8Array.BYTES_PER_ELEMENTM;\n        }\n\n        /**\r\n         * Returns the names of the borders files (vertex and fragment shaders).\r\n         * @static\r\n         * @returns {{borderVertexFileName: string, borderFragmentFileName:string}}\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getBordersShadersFileNames',\n        value: function getBordersShadersFileNames() {\n            return { borderVertexFileName: 'borders.vert', borderFragmentFileName: 'borders.frag' };\n        }\n\n        /**\r\n         * Returns the default color for the borders.\r\n         * @static\r\n         * @returns {Array<number>} - the default color for the borders.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultBordersColor',\n        value: function getDefaultBordersColor() {\n            return [0, 0, 0];\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     WEBGL SIZE     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The min data name to be used in all shaders that use size as a visual variable.\r\n         * @static\r\n         * @returns {string} - min data name to be used in all shaders that use size as a visual variable.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMinSizeDataName',\n        value: function getMinSizeDataName() {\n            return 'minData';\n        }\n\n        /**\r\n         * The max data name to be used in all shaders that use size as a visual variable.\r\n         * @static\r\n         * @returns {string} - max data name to be used in all shaders that use size as a visual variable.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMaxSizeDataName',\n        value: function getMaxSizeDataName() {\n            return 'maxData';\n        }\n    }, {\n        key: 'getMinSizePixels',\n        value: function getMinSizePixels() {\n            return { name: 'minPixels', value: _defaults2.default.minSize };\n        }\n    }, {\n        key: 'getMaxSizePixels',\n        value: function getMaxSizePixels() {\n            return { name: 'maxPixels', value: _defaults2.default.maxSize };\n        }\n\n        /*\r\n        #####################################################################\r\n        ######################     PARSERS PRIMITIVE     ####################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the type of primitive we want.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getPrimitive',\n        value: function getPrimitive() {\n            return {\n                POINT: 0,\n                POLYGON: 1,\n                LINE: 2,\n                CSVPOINT: 3,\n                CSVIDS: 4\n            };\n        }\n\n        /**\r\n         * Returns the list of geometry primitives.\r\n         * @static\r\n         * @returns the list of geometry primitives.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getGeometryPrimitives',\n        value: function getGeometryPrimitives() {\n            return {\n                POINT: 'Point',\n                POLYGON: 'Polygon',\n                MULTIPOLYGON: 'MultiPolygon',\n                LINESTRING: 'LineString',\n                MULTILINESTRING: 'MultiLineString'\n            };\n        }\n\n        /**\r\n         * Returns true if the given primitive is polygon.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is polygon.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasPolygons',\n        value: function hasPolygons(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().POLYGON;\n        }\n\n        /**\r\n         * Returns true if the given primitive is line.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is line.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasLines',\n        value: function hasLines(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().LINE;\n        }\n\n        /**\r\n         * Returns true if the given primitive is line.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is line.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasPoints',\n        value: function hasPoints(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().POINT;\n        }\n\n        /**\r\n         * Returns true if the given primitive is points coming from the CSV Parser.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is points coming from the CSV Parser.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasCSVPoints',\n        value: function hasCSVPoints(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().CSVPOINT;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################      WEBGL PICKING     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Convert the given RGBA color color to it's respective integer value. \r\n         * @param {number} r - The red value.\r\n         * @param {number} g - The green value.\r\n         * @param {number} b - The blue value.\r\n         * @param {number} a - The alpha value.\r\n         * @returns {number} - the integer value converted from the given RGBA value.\r\n         * @see https://github.com/mcwhittemore/rgb-to-int/blob/master/index.js\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'RGBAToNumber',\n        value: function RGBAToNumber(r, g, b, a) {\n            // return r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a;\n            return r * Math.pow(256, 3) + (g << 16 | b << 8 | a); // g<<16 === g * 2^16\n        }\n\n        /**\r\n         * Convert the given number to it's RGBA representation.\r\n         * @static\r\n         * @param {number} num - The number to be converted. \r\n         * @returns {Array<number>} - the RGBA representation of the given number.\r\n         * @see https://math.stackexchange.com/a/1636055\r\n         * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'numberToRGBA',\n        value: function numberToRGBA(num) {\n            var r = Math.floor(num / Math.pow(256, 3));\n            var g = Math.floor(num / Math.pow(256, 2) % 256);\n            var b = Math.floor(num / 256 % 256);\n            var a = num - (Math.pow(256, 3) * r + Math.pow(256, 2) * g + 256 * b);\n            return [r, g, b, a];\n        }\n\n        /**\r\n         * The name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n         * @static\r\n         * @returns {string} - he name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isPickingName',\n        value: function isPickingName() {\n            return 'isPicking';\n        }\n\n        /**\r\n         * The name of the variable that holds the RGBA colors used for picking.\r\n         * @static\r\n         * @returns {string} - the name of the variable that holds the RGBA colors used for picking.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'pickingColorName',\n        value: function pickingColorName() {\n            return 'pickingColor';\n        }\n\n        /**\r\n         * Returns the name of the picking identifier for the MVC/TG.\r\n         * @static\r\n         * @returns {string} - the name of the picking identifier for the MVC/TG.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'pickingMVCTGIdentifierName',\n        value: function pickingMVCTGIdentifierName() {\n            return \"MVCTGPickingColor\";\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     TIME DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the instant time variable.\r\n         * @static\r\n         * @returns {string} - the instant time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'INSTANT',\n        value: function INSTANT() {\n            return _defaults2.default.timeVariables.INSTANT;\n        }\n\n        /**\r\n         * Returns the interval time variable.\r\n         * @static\r\n         * @returns {string} -  the interval time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'INTERVAL',\n        value: function INTERVAL() {\n            return _defaults2.default.timeVariables.INTERVAL;\n        }\n\n        /**\r\n         * The animation time variable.\r\n         * @static\r\n         * @returns {string} - the animation time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'ANIMATION',\n        value: function ANIMATION() {\n            return _defaults2.default.timeVariables.ANIMATION;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     DATA NATURE     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the sequential data nature.\r\n         * @static\r\n         * @returns {string} - the sequential data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SEQUENTIAL',\n        value: function SEQUENTIAL() {\n            return 'sequential';\n        }\n\n        /**\r\n         * Returns the divergent data nature.\r\n         * @static\r\n         * @returns {string} - the divergent data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'DIVERGENT',\n        value: function DIVERGENT() {\n            return 'divergent';\n        }\n\n        /**\r\n         * Returns the qualitative data nature.\r\n         * @static\r\n         * @returns {string} - the qualitative data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'QUALITATIVE',\n        value: function QUALITATIVE() {\n            return 'qualitative';\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     ESSENTIALS         ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Verifies if the given value is a string.\r\n         * @static\r\n         * @param {any} value - The value to test if it has type string. \r\n         * @returns {boolean} - true, if the given value is a string, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isString',\n        value: function isString(value) {\n            return typeof value === 'string';\n        }\n\n        /**\r\n         * Returns true, if the type of value is number.\r\n         * @static\r\n         * @param {any} value \r\n         * @returns {boolean} -  true, if the type of value is number, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isNumber',\n        value: function isNumber(value) {\n            return typeof value === 'number';\n        }\n\n        /**\r\n         * Clone a nested array in Javascript.\r\n         * @static\r\n         * @param {Array<any>} arr - The given array. \r\n         * @returns {Array<any>} - the cloned nested array.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'cloneNestedArray',\n        value: function cloneNestedArray(arr) {\n            var i = void 0,\n                copy = void 0;\n            if (Array.isArray(arr)) {\n                copy = arr.slice(0);\n                for (var _i = 0; _i < copy.length; _i++) {\n                    copy[_i] = this.cloneNestedArray(copy[_i]);\n                }return copy;\n            } else if ((typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object') throw new Error('Cannot clone array containing an object!');else return arr;\n        }\n\n        /**\r\n         * Returns the number of threads on the user computer.\r\n         * @static\r\n         * @returns {number} - a number between 1 and the number of logical processors potentially available to the user agent\r\n         * @see https://html.spec.whatwg.org/multipage/workers.html#navigator.hardwareconcurrency\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getNumberThreads',\n        value: function getNumberThreads() {\n            return navigator.hardwareConcurrency;\n        }\n\n        /**\r\n         * Returns true if the given Map Variable is an instance of CategoricalVariable.\r\n         * @static\r\n         * @param {any} mapVariable - The value given. \r\n         * @returns {boolean} - true, if the given value is an instance of CategoricalVariable, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isCategoricalMapVariable',\n        value: function isCategoricalMapVariable(mapVariable) {\n            return mapVariable instanceof _CategoricalVariable.CategoricalVariable;\n        }\n\n        /**\r\n         * Request a range of bytes from the given url.\r\n         * @param {string|URL} url -The url to request the bytes from.\r\n         * @see \r\n         * @returns {Promise<string>} - The string of text from startByte to endByte.\r\n         * @memberof CSVNetWorkParser\r\n         */\n\n    }, {\n        key: 'requestRangeOfBytes',\n        value: function requestRangeOfBytes(url, startByte, endByte) {\n            console.log(url);\n            fetch(url, {\n                headers: {\n                    'Range': 'bytes=' + startByte + '-' + endByte\n                },\n                mode: 'cors'\n            }).then(function (response) {\n                console.log(response);\n                if (response.ok) return new Promise(function (res, rej) {\n                    return res(response.text());\n                });\n            }).catch(function (err) {\n                console.error(err);\n                throw new _GisplayError.GisplayError('Error making request to the remote URL to get range of bytes.');\n            });\n        }\n\n        /**\r\n         * Returns the size of the remote file in bytes.\r\n         * @param {string|URL} url -The url to request it's size.\r\n         * @returns {number} - the size of the remote file in bytes.\r\n         * @see https://stackoverflow.com/a/48266945 - Get content length from the response\r\n         * @see https://github.com/evanlucas/remote-file-size/blob/master/index.js - Remote file size in Node.js\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD - HEAD method\r\n         * @memberof CSVNetWorkParser\r\n         */\n\n    }, {\n        key: 'requestFileSize',\n        value: function requestFileSize(url) {\n            fetch(url, { method: 'HEAD' }) //HEAD request\n            .then(function (response) {\n                var fileSize = response.headers.get('Content-Length');\n                if (fileSize >= 0) return new Promise(function (res, rej) {\n                    return res(fileSize);\n                });\n                throw new _GisplayError.GisplayError('Cannot get the size of the remote file.');\n            }).catch(function (err) {\n                console.log(err);\n                throw new _GisplayError.GisplayError('Error making request to the remote URL size.');\n            });\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################          LEGEND        ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the list of possible initial positions for the Legend div element.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getLegendPositions',\n        value: function getLegendPositions() {\n            return {\n                TOP_LEFT: 'tl',\n                TOP_RIGHT: 'tr',\n                BOTTOM_LEFT: 'bl',\n                BOTTOM_RIGHT: 'br'\n            };\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################          EVENTS        ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the list of messages for the CSV parser.\r\n         * @static\r\n         * @returns - the list of messages for the CSV parser.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'MESSAGES_CSV',\n        value: function MESSAGES_CSV() {\n            return {\n                TO_START: 'start', //From TP to Ws to start processing their part\n                END_START: 'end_start', //FROM each W to TP flag that the W as terminated its part\n\n                TO_LIMITS_CAT: 'limits_categories', //FROM TP to Ws to get the min and max and categories for each cat and cont vars \n                END_LIMITS_CAT: 'end_limits_categories', //FROM each W to TP with min/max and categories\n\n                TO_LIMITS_CAT_RES: 'limits_categories_res', //FROM TP to Ws with the resulting classes/categories and time granules\n                END_LIMITS_CAT_RES: 'end_limits_categories_res', //FROM each W to TP meaning the W has all the MVCs and TGs in place\n\n                TO_JOIN_DATA: 'join_data', //FROM TP To Ws with information about MVCs and TGs in order to join the final rows\n                END_JOIN_DATA: 'end_join_data', //FROM Ws To TP as a flag to receive data\n\n                TO_GENERATE_RGBA: 'generate_rgba', //FROM TP To Ws to generate RGBA information for each row\n                END_GENERATE_RGBA: 'end_generate_rgba', //FROM each W to TP meaning the W generated all RGBA values\n\n                TO_SEND_DATA: 'send_data', //FROM TP to one W at a time to receive its data\n                END_SEND_DATA: 'end_send_data' //FROM W to TP with the MVCs and TGs created \n            };\n        }\n\n        /**\r\n         * Returns the list of events that exist in the Temporal Gisplay API.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getEvents',\n        value: function getEvents() {\n            return {\n                /**\r\n                * The name of the library loaded event.\r\n                * @type {string}\r\n                */\n                LIBRARY_LOADED_EVENT: 'libraryLoaded',\n                /**\r\n                 * The name of the parser ended event.\r\n                 * @type {string}\r\n                 */\n                PARSER_ENDED_EVENT: 'parserEnd',\n                /**\r\n                 * The name of the event for geometry ids.\r\n                 * @type {string}\r\n                 */\n                GEOMETRY_IDS_EVENT: 'geometryIdsEnd',\n                /**\r\n                 * The shapes image loaded event.\r\n                 * Needed, otherwise could cause the error: https://github.com/jywarren/webgl-distort/issues/4\r\n                 * @type {string}\r\n                 */\n                SHAPES_IMAGE_LOADED_EVENT: 'shapesImageLoaded',\n                /**\r\n                 * The patterns image loaded event.\r\n                 * @type {string}\r\n                 */\n                PATTERNS_IMAGE_LOADED_EVENT: 'patternsImageLoaded',\n                /**\r\n                 * The figures image loaded event.\r\n                 * @type {string}\r\n                 */\n                FIGURES_IMAGE_LOADED_EVENT: 'figuresImageLoaded',\n                /**\r\n                 * The time range changed event.\r\n                 * @type {string}\r\n                 */\n                TIME_RANGE_CHANGED: 'TimeRangeChanged',\n                /**\r\n                 * The legend changed event.\r\n                 * @type {string}\r\n                 */\n                LEGEND_CHANGED: 'LegendChanged',\n                /**\r\n                 * The extended temporal navigator legend changed event.\r\n                 * @type {string}\r\n                 */\n                EXTENDED_TEMPORAL_NAVIGATOR_LEGEND_CHANGED: 'extended_temporal_navigator_legend',\n                /**\r\n                 * The extended temporal navigator time axis changed event.\r\n                 * @type {string}\r\n                 */\n                EXTENDED_TEMPORAL_NAVIGATOR_TIME_CHANGED: 'extended_temporal_navigator_time',\n                /**\r\n                 * The event for the resize of the window.\r\n                 * @type {string}\r\n                 */\n                RESIZE: 'resize'\n            };\n        }\n\n        /**\r\n         * Returns the list of keys and their key codes to be used by TimeControl and ETN.\r\n         * @static\r\n         * @returns {{LEFT_ARROW: number, A_KEY:number, RIGHT_ARROW: number, D_KEY: number, DOWN_ARROW: number, S_KEY: number, UP_ARROW: number, W_KEY: number}} - the list of keys and their key codes to be used by TimeControl and ETN.\r\n         * @see https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes - Key codes\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getKeyboardKeyCodes',\n        value: function getKeyboardKeyCodes() {\n            return {\n                LEFT_ARROW: 37,\n                A_KEY: 65,\n                RIGHT_ARROW: 39,\n                D_KEY: 68,\n                DOWN_ARROW: 40,\n                S_KEY: 83,\n                UP_ARROW: 38,\n                W_KEY: 87\n            };\n        }\n    }]);\n\n    return GisplayDefaults;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5RGVmYXVsdHMuanM/YWRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdHNGaWxlIGZyb20gJy4vZGVmYXVsdHMuanNvbic7XHJcbmltcG9ydCB7IEdpc3BsYXlFcnJvciB9IGZyb20gJy4vR2lzcGxheUVycm9yJztcclxuaW1wb3J0IHsgQ2F0ZWdvcmljYWxWYXJpYWJsZSB9IGZyb20gJy4vVlZzL0NhdGVnb3JpY2FsVmFyaWFibGUnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgZXhwb3J0cyB0aGUgR2lzcGxheSBkZWZhdWx0IHZhbHVlcy5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgR2lzcGxheURlZmF1bHRzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheURlZmF1bHRzIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBjbGFzcyBicmVhayBtZXRob2RzLlxyXG4gICAgICogQHJldHVybnMgQWxsIGF2YWlsYWJsZSBjbGFzcyBicmVhayBtZXRob2RzIGZvciB0aGUgVGVtcG9yYWwgR2lzcGxheSBBUEkuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheU9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEF2YWlsYWJsZUNsYXNzQnJlYWtzTWV0aG9kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBRVUFOVElMRVM6ICdxdWFudGlsZXMnLFxyXG4gICAgICAgICAgICBFUVVBTF9JTlRFUlZBTFM6ICdlcXVhbGludGVydmFscydcclxuICAgICAgICB9Oy8vZGVmYXVsdHNGaWxlLmF2YWlsYWJsZUNsYXNzc0JyZWFrTWV0aG9kczsgLy9bXCJxdWFudGlsZXNcIiwgXCJlcXVhbGludGVydmFsc1wiLCBcImstbWVhbnNcIl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgYmFja2dyb3VuZCBtYXAgcHJvdmlkZXJzLlxyXG4gICAgICogQHJldHVybnMgLSBBbGwgYXZhaWxhYmxlIGJhY2tncm91bmQgbWFwIHByb3ZpZGVycyB1bmRlciBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5T3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXZhaWxhYmxlQmFja2dyb3VuZFByb3ZpZGVycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBHT09HTEVfTUFQUzogJ0dNJyxcclxuICAgICAgICAgICAgTUFQQk9YOiAnTUInLFxyXG4gICAgICAgICAgICBNQVBCT1hHTDogJ01CR0wnLFxyXG4gICAgICAgICAgICBIRVJFX01BUFM6ICdITScsXHJcbiAgICAgICAgICAgIEJJTkdfTUFQUzogJ0JNJ1xyXG4gICAgICAgIH07IC8vIGRlZmF1bHRzRmlsZS5iZ21hcHNQcm92aWRlcnMgXHJcbiAgICAgICAgLypbJ0dvb2dsZSBNYXBzJywgJ0dNJywgLy9BbGwgdmFyaWFudHMgb2YgR29vZ2xlIE1hcHNcclxuICAgICAgICAgICAgJ01hcGJveCcsICdNQicsIC8vQWxsIHZhcmlhbnRzIG9mIE1hcGJveFxyXG4gICAgICAgICAgICAnSGVyZSBNYXBzJywgJ0hNJyxcclxuICAgICAgICAgICAgJ0JpbmcgTWFwcycsICdCTSddOyovXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBERUxFVEVcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY2xhc3MgbWV0aG9kIHRvIGNhbGN1bGF0ZSBjbGFzc2VzIGZvciBjb250aW51b3VzIHZhcmlhYmxlcy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUmV0dXJucyBxdWFudGlsZXMsIHRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgY2xhc3MgY2FsY3VsYXRpb24uXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xhc3NCcmVha01ldGhvZCgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLmRlZmF1bHRDbGFzc0JyZWFrTWV0aG9kOy8vJ2VxdWFsaW50ZXJ2YWxzJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGdyYW51bGFyaXRpZXMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEF2YWlsYWJsZUdyYW51bGFyaXRpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnbW9udGhPZlllYXInLCAnZGF5T2ZZZWFyJywgJ2RheU9mTW9udGgnLCAnaG91ck9mRGF5JywgJ21pbnV0ZU9mSG91cicsICd5ZWFyJywgJ21vbnRoJywgJ2RheScsICd2YWx1ZSddO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdmlzdWFsIHZhcmlhYmxlcyBpbiB0aGUgVGVtcG9yYWwgR2lzcGFseSBBUEkuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyAgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHZpc3VhbCB2YXJpYWJsZXMgaW4gdGhlIFRlbXBvcmFsIEdpc3BhbHkgQVBJLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXZhaWxhYmxlVmlzdWFsVmFyaWFibGVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIENPTE9SOiAnY29sb3InLFxyXG4gICAgICAgICAgICBTSEFQRTogJ3NoYXBlJyxcclxuICAgICAgICAgICAgU0laRTogJ3NpemUnLFxyXG4gICAgICAgICAgICBPUklFTlRBVElPTjogJ29yaWVudGF0aW9uJyxcclxuICAgICAgICAgICAgVEVYVFVSRTogJ3RleHR1cmUnLFxyXG4gICAgICAgICAgICBQT1NJVElPTjogJ3Bvc2l0aW9uJyxcclxuICAgICAgICAgICAgT1BBQ0lUWTogJ29wYWNpdHknXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBjb2xvciBicmV3ZXIgbWV0aG9kcy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIHRoZSBhdmFpbGFibGUgY29sb3IgYnJld2VyIG1ldGhvZHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBdmFpbGFibGVDb2xvckJyZXdlck1ldGhvZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2NvbG9yYnJld2VyLScgKyBHaXNwbGF5RGVmYXVsdHMuU0VRVUVOVElBTCgpLnRvTG9jYWxlTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICdjb2xvcmJyZXdlci0nICsgR2lzcGxheURlZmF1bHRzLkRJVkVSR0VOVCgpLnRvTG9jYWxlTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICdjb2xvcmJyZXdlci0nICsgR2lzcGxheURlZmF1bHRzLlFVQUxJVEFUSVZFKCkudG9Mb2NhbGVMb3dlckNhc2UoKVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIGNvbG9ycyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcGxhY2UgKGhpZGUpIHRoZSBiYWNrZ3JvdW5kIG1hcHMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSB0aGUgbGlzdCBvZiBjb2xvcnMgdGhhdCBjYW4gYmUgdXNlZCB0byByZXBsYWNlIChoaWRlKSB0aGUgYmFja2dyb3VuZCBtYXBzLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QmFja2dyb3VuZENvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4gWyd3aGl0ZScsICdibGFjaycsICd0b21hdG8nXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRpbWUgc3RyaW5nIHRvIHRoZSBncmFudWxhcml0eSB3ZSB3YW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVTdHJpbmcgLSBUaGUgdGltZSBhcyBpdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGdyYW51bFxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEdyYW51bGUodGltZVN0cmluZykge1xyXG4gICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4odGltZVN0cmluZywgdGhpcy50aW1lR3JhbnVsYXJpdHkpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIC8vaWYgY3ljbGljIHRoZW4gLi4uXHJcbiAgICAgICAgICAgIGRheSBvZiB5ZWFyIC0+IGRheU9mWWVhciAobiB0ZW1vcyApXHJcbiAgICAgICAgICAgIG1vbnRoIG9mIHllYXIgLT4gbW9udGhPZlllYXIgKHRlbW9zKVxyXG4gICAgICAgICAgICBkYXkgb2YgbW9udGggLT4gZGF5T2ZNb250aCAodGVtb3MpXHJcbiAgICAgICAgICAgIGhvdXIgb2YgZGF5IC0+IGhvdXJPZkRheSAodGVtb3MpXHJcbiAgICAgICAgICAgIG1pbnV0ZSBvZiBob3VyIC0+IG1pbnV0ZU9mSG91ciAodGVtb3MpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2Vsc2UgY29udGludW91c1xyXG4gICAgICAgICAgICB5ZWFyIC0+IDIwMTUsIDIwMTYgLi4uXHJcbiAgICAgICAgICAgIG1vbnRoIC0+IDIwMTVfMDEsIDIwMTVfMDIgLi4uIDIwMTZfMDEgZXRjXHJcbiAgICAgICAgICAgIGRheSAtPiAyMDE1XzAxXzAxLCAyMDE1XzAxXzAyIC4uLlxyXG4gICAgICAgICAgICBob3VyIC0+IDIwMTVfMDFfMDFfMDEsIDIwMTVfMDFfMDFfMDEgLi4uXHJcbiAgICAgICAgICAgIG1pbnV0ZVxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnRpbWVHcmFudWxhcml0eSkge1xyXG4gICAgICAgICAgICAvL0NZQ0xJQ1xyXG4gICAgICAgICAgICBjYXNlICdtb250aE9mWWVhcic6IC8vTWVzIGRvIGFub1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAobmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIDEpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXlPZlllYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTsgLy9DSEFOR0UgdG8gY2FsY3VsYXRlIGRheSBvZiB5ZWFyXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5T2ZNb250aCc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERhdGUoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaG91ck9mRGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0SG91cnMoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlT2ZIb3VyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0TWludXRlcygpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy9DT05USU5VT1VTXHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogLy9NZXMgZG8gYW5vXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIl9cIiArIChuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiX1wiICsgKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1vbnRoKCkgKyAxKSArIFwiX1wiICsgbmV3IERhdGUodGltZVN0cmluZykuZ2V0RGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgPSBOdW1iZXIobmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiXCIgKyBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgXCJcIiArIG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERheSgpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICt0aW1lU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgIFZJU1VBTCBWQVJJQUJMRVMgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb2xvciB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzdHJpbmcgJ2NvbG9yJy5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIENPTE9SKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudmlzdWFsVmFyaWFibGVzLkNPTE9SO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNhdHVyYXRpb24gdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpYyBcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHNhdHVyYXRpb24gdmlzdWFsIHZhcmlhYmxlIHN0cmluZy4gXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBPUEFDSVRZKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudmlzdWFsVmFyaWFibGVzLk9QQUNJVFk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2hhcGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgc2hhcGUgdmlzdWFsICB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFNIQVBFKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudmlzdWFsVmFyaWFibGVzLlNIQVBFO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHBvc2l0aW9uIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFBPU0lUSU9OKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudmlzdWFsVmFyaWFibGVzLlBPU0lUSU9OO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBob2xkIHRoZSBtYXRyaXggcHJvamVjdGlvbiBcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHByb2plY3Rpb24gbWF0cml4IHZhcmlhYmxlIG5hbWUgb24gYWxsIHNoYWRlcnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBNUFJPSigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLmRlZmF1bHRTaGFkZXJzVmFyaWFibGVzLnByb2plY3Rpb25NYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dHVyZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB0ZXh0dXJlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFRFWFRVUkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS52aXN1YWxWYXJpYWJsZXMuVEVYVFVSRTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXplIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHNpemUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgU0laRSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5TSVpFO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWVudGF0aW9uIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG9yaWVudGF0aW9uIHZpc3VhbCAgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBPUklFTlRBVElPTigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5PUklFTlRBVElPTjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzaGFwZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFwZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZ2l2ZW4gc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc2hhcGUuXHJcbiAgICAgKiBAdGhyb3dzIHtHaXNwbGF5RXJyb3J9IC0gSWYgdGhlIGdpdmVuIHNoYXBlIGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmluZFNoYXBlSW5kZXgoc2hhcGVOYW1lKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKHNoYXBlVGV4dHVyZU5hbWUpO1xyXG4gICAgICAgIGxldCBzaGFwZUluZGV4ID0gZGVmYXVsdHNGaWxlLnNoYXBlc1tzaGFwZU5hbWVdO1xyXG4gICAgICAgIGlmIChzaGFwZUluZGV4ID49IDApXHJcbiAgICAgICAgICAgIHJldHVybiBzaGFwZUluZGV4O1xyXG4gICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoYFNoYXBlIHdpdGggbmFtZTogJHtzaGFwZU5hbWV9LCBub3QgZm91bmQuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcGF0dGVybi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBnaXZlbiBwYXR0ZXJuLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBhdHRlcm4uXHJcbiAgICAgKiBAdGhyb3dzIHtHaXNwbGF5RXJyb3J9IC0gSWYgdGhlIGdpdmVuIHBhdHRlcm4gZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmaW5kUGF0dGVybkluZGV4KHBhdHRlcm5OYW1lKSB7XHJcbiAgICAgICAgbGV0IHBhdHRlcm5JbmRleCA9IGRlZmF1bHRzRmlsZS5wYXR0ZXJuc1twYXR0ZXJuTmFtZV07XHJcbiAgICAgICAgaWYgKHBhdHRlcm5JbmRleCA+PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybkluZGV4O1xyXG4gICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoYFBhdHRlcm4gd2l0aCBuYW1lOiAke3BhdHRlcm5OYW1lfSwgbm90IGZvdW5kLmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGZpZ3VyZSBuYW1lLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZ3VyZU5hbWUgLSBUaGUgZmlndXJlIG5hbWUuIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGZpZ3VyZSBuYW1lLlxyXG4gICAgICogQHRocm93cyB7R2lzcGxheUVycm9yfSAtIElmIHRoZSBnaXZlbiBmaWd1cmUgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmaW5kRmlndXJlSW5kZXgoZmlndXJlTmFtZSkge1xyXG4gICAgICAgIGxldCBmaWd1cmVJbmRleCA9IGRlZmF1bHRzRmlsZS5maWd1cmVzW2ZpZ3VyZU5hbWVdO1xyXG4gICAgICAgIGlmIChmaWd1cmVJbmRleCA+PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmlndXJlSW5kZXg7XHJcbiAgICAgICAgdGhyb3cgbmV3IEdpc3BsYXlFcnJvcihgRmlndXJlIHdpdGggbmFtZTogJHtmaWd1cmVOYW1lfSwgbm90IGZvdW5kLmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBjb2xvci5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAgLSB0aGUgZGVmYXVsdCBjb2xvci4gXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0Q29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCBzaGFwZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBkZWZhdWx0IHNoYXBlIC5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRTaGFwZUluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTaGFwZUluZGV4KGRlZmF1bHRzRmlsZS5kZWZhdWx0U2hhcGUpOyAvL0dpc3BsYXlEZWZhdWx0cy5DSVJDTEVfRlVMTC5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBkZWZhdWx0IHRleHR1cmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCB0ZXh0dXJlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFRleHR1cmVJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kU2hhcGVJbmRleChkZWZhdWx0c0ZpbGUuZGVmYXVsdFRleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGRlZmF1bHQgZmlndXJlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGRlZmF1bHQgZmlndXJlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEZpZ3VyZUluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGaWd1cmVJbmRleChkZWZhdWx0c0ZpbGUuZGVmYXVsdEZpZ3VyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHNpemUgb2YgYSBwb2ludCBmb3IgdGhlIEdpc3BsYXkgQVBJLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcj0xNX0gLSB0aGUgZGVmYXVsdCBzaXplIG9mIGEgcG9pbnQgZm9yIHRoZSBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRTaXplVmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0U2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gc2l6ZSBmb3IgcG9pbnRzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSAgdGhlIG1pbmltdW0gc2l6ZSBmb3IgcG9pbnRzLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TWluU2l6ZVZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUubWluU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gc2l6ZSBmb3IgcG9pbnRzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSAgdGhlIG1heGltdW0gc2l6ZSBmb3IgcG9pbnRzLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TWF4U2l6ZVZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUubWF4U2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgb3JpZW50YXRpb24gb2YgYSBmaWd1cmUgb3Igc2hhcGUgaW4gdGhlIEdpc3BsYXkgQVBJLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcj0wfSAtIHRoZSBkZWZhdWx0IG9yaWVudGF0aW9uIG9mIGEgZmlndXJlIG9yIHNoYXBlIGluIHRoZSBHaXNwbGF5IEFQSS4gXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0T3JpZW50YXRpb25WYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLmRlZmF1bHRPcmllbnRhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgSU1BR0UgREVGQVVUTFMgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgYW55IHNoYXBlIGltYWdlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgc2l6ZSBvZiB0aGUgYW55IHNoYXBlIGltYWdlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U2hhcGVJbWFnZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5zaGFwZXNJbWFnZVNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBhbnkgcGF0dGVybiBpbWFnZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgb2YgdGhlIGFueSBwYXR0ZXJuIGltYWdlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0UGF0dGVybkltYWdlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnBhdHRlcm5zSW1hZ2VTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgYW55IGZpZ3VyZSBpbWFnZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgb2YgdGhlIGFueSBmaWd1cmUgaW1hZ2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRGaWd1cmVJbWFnZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5maWd1cmVzSW1hZ2VTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBXRUJHTCBERUZBVVRMUyAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBhbHBoYSB2YWx1ZSBmb3IgdGhlIFxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0QWxwaGFWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLmRlZmF1bHRBbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyBmb3IgZWFjaCBlbGVtZW50IG9mIGEgRmxvYXQzMkFycmF5LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIGVsZW1lbnQgb2YgYSBGbG9hdDMyQXJyYXkuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRGbG9hdDMyQnl0ZXNQZXJFbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIGVsZW1lbnQgb2YgYSBVaW50OEFycmF5IChVbnNpZ25lZCBpbnQpLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIGVsZW1lbnQgb2YgYSBVaW50OEFycmF5IChVbnNpZ25lZCBpbnQpLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0VWludDhCeXRlc1BlckVsZW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlRNO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGJvcmRlcnMgZmlsZXMgKHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycykuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7e2JvcmRlclZlcnRleEZpbGVOYW1lOiBzdHJpbmcsIGJvcmRlckZyYWdtZW50RmlsZU5hbWU6c3RyaW5nfX1cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEJvcmRlcnNTaGFkZXJzRmlsZU5hbWVzKCkge1xyXG4gICAgICAgIHJldHVybiB7IGJvcmRlclZlcnRleEZpbGVOYW1lOiAnYm9yZGVycy52ZXJ0JywgYm9yZGVyRnJhZ21lbnRGaWxlTmFtZTogJ2JvcmRlcnMuZnJhZycgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY29sb3IgZm9yIHRoZSBib3JkZXJzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gdGhlIGRlZmF1bHQgY29sb3IgZm9yIHRoZSBib3JkZXJzLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEJvcmRlcnNDb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBXRUJHTCBTSVpFICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtaW4gZGF0YSBuYW1lIHRvIGJlIHVzZWQgaW4gYWxsIHNoYWRlcnMgdGhhdCB1c2Ugc2l6ZSBhcyBhIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbWluIGRhdGEgbmFtZSB0byBiZSB1c2VkIGluIGFsbCBzaGFkZXJzIHRoYXQgdXNlIHNpemUgYXMgYSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRNaW5TaXplRGF0YU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtaW5EYXRhJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXggZGF0YSBuYW1lIHRvIGJlIHVzZWQgaW4gYWxsIHNoYWRlcnMgdGhhdCB1c2Ugc2l6ZSBhcyBhIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbWF4IGRhdGEgbmFtZSB0byBiZSB1c2VkIGluIGFsbCBzaGFkZXJzIHRoYXQgdXNlIHNpemUgYXMgYSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRNYXhTaXplRGF0YU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtYXhEYXRhJztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0TWluU2l6ZVBpeGVscygpIHtcclxuICAgICAgICByZXR1cm4geyBuYW1lOiAnbWluUGl4ZWxzJywgdmFsdWU6IGRlZmF1bHRzRmlsZS5taW5TaXplIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldE1heFNpemVQaXhlbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogJ21heFBpeGVscycsIHZhbHVlOiBkZWZhdWx0c0ZpbGUubWF4U2l6ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgIFBBUlNFUlMgUFJJTUlUSVZFICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHByaW1pdGl2ZSB3ZSB3YW50LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQcmltaXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgUE9JTlQ6IDAsXHJcbiAgICAgICAgICAgIFBPTFlHT046IDEsXHJcbiAgICAgICAgICAgIExJTkU6IDIsXHJcbiAgICAgICAgICAgIENTVlBPSU5UOiAzLFxyXG4gICAgICAgICAgICBDU1ZJRFM6IDRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnZW9tZXRyeSBwcmltaXRpdmVzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMgdGhlIGxpc3Qgb2YgZ2VvbWV0cnkgcHJpbWl0aXZlcy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEdlb21ldHJ5UHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBQT0lOVDogJ1BvaW50JyxcclxuICAgICAgICAgICAgUE9MWUdPTjogJ1BvbHlnb24nLFxyXG4gICAgICAgICAgICBNVUxUSVBPTFlHT046ICdNdWx0aVBvbHlnb24nLFxyXG4gICAgICAgICAgICBMSU5FU1RSSU5HOiAnTGluZVN0cmluZycsXHJcbiAgICAgICAgICAgIE1VTFRJTElORVNUUklORzogJ011bHRpTGluZVN0cmluZydcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgcG9seWdvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnZW9QcmltaXRpdmUgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJpbWl0aXZlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIGdpdmVuIHByaW1pdGl2ZSBpcyBwb2x5Z29uLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzUG9seWdvbnMoZ2VvUHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb1ByaW1pdGl2ZSA9PT0gdGhpcy5nZXRQcmltaXRpdmUoKS5QT0xZR09OO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgbGluZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnZW9QcmltaXRpdmUgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJpbWl0aXZlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIGdpdmVuIHByaW1pdGl2ZSBpcyBsaW5lLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzTGluZXMoZ2VvUHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb1ByaW1pdGl2ZSA9PT0gdGhpcy5nZXRQcmltaXRpdmUoKS5MSU5FO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgbGluZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnZW9QcmltaXRpdmUgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJpbWl0aXZlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIGdpdmVuIHByaW1pdGl2ZSBpcyBsaW5lLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzUG9pbnRzKGdlb1ByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBnZW9QcmltaXRpdmUgPT09IHRoaXMuZ2V0UHJpbWl0aXZlKCkuUE9JTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHByaW1pdGl2ZSBpcyBwb2ludHMgY29taW5nIGZyb20gdGhlIENTViBQYXJzZXIuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VvUHJpbWl0aXZlIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByaW1pdGl2ZS4gXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgcG9pbnRzIGNvbWluZyBmcm9tIHRoZSBDU1YgUGFyc2VyLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzQ1NWUG9pbnRzKGdlb1ByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBnZW9QcmltaXRpdmUgPT09IHRoaXMuZ2V0UHJpbWl0aXZlKCkuQ1NWUE9JTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgICBXRUJHTCBQSUNLSU5HICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGdpdmVuIFJHQkEgY29sb3IgY29sb3IgdG8gaXQncyByZXNwZWN0aXZlIGludGVnZXIgdmFsdWUuIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBUaGUgcmVkIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBUaGUgZ3JlZW4gdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBibHVlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBUaGUgYWxwaGEgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBpbnRlZ2VyIHZhbHVlIGNvbnZlcnRlZCBmcm9tIHRoZSBnaXZlbiBSR0JBIHZhbHVlLlxyXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWN3aGl0dGVtb3JlL3JnYi10by1pbnQvYmxvYi9tYXN0ZXIvaW5kZXguanNcclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFJHQkFUb051bWJlcihyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHIgKiBNYXRoLnBvdygyNTYsIDMpICsgZyAqIE1hdGgucG93KDI1NiwgMikgKyBiICogTWF0aC5wb3coMjU2LCAxKSArIGE7XHJcbiAgICAgICAgcmV0dXJuIHIgKiBNYXRoLnBvdygyNTYsIDMpICsgKGcgPDwgMTYgfCBiIDw8IDggfCBhKTsgLy8gZzw8MTYgPT09IGcgKiAyXjE2XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBudW1iZXIgdG8gaXQncyBSR0JBIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gYmUgY29udmVydGVkLiBcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBSR0JBIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzE2MzYwNTVcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcHQtUFQvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2VcclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG51bWJlclRvUkdCQShudW0pIHtcclxuICAgICAgICBsZXQgciA9IE1hdGguZmxvb3IobnVtIC8gTWF0aC5wb3coMjU2LCAzKSk7XHJcbiAgICAgICAgbGV0IGcgPSBNYXRoLmZsb29yKG51bSAvIE1hdGgucG93KDI1NiwgMikgJSAyNTYpO1xyXG4gICAgICAgIGxldCBiID0gTWF0aC5mbG9vcihudW0gLyAyNTYgJSAyNTYpO1xyXG4gICAgICAgIGxldCBhID0gbnVtIC0gKE1hdGgucG93KDI1NiwgMykgKiByICsgTWF0aC5wb3coMjU2LCAyKSAqIGcgKyAyNTYgKiBiKTtcclxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgZm9yIHRoZSBib29sZWFuIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCBvbiB0aGUgc2hhZGVyIHRvIGtub3cgaWYgd2Ugd2FudCB0byBkcmF3IHRvIHBpY2tpbmcgdGV4dHVyZSBvciBub3JtYWwgZHJhdy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gaGUgbmFtZSBmb3IgdGhlIGJvb2xlYW4gdmFyaWFibGUgdGhhdCBpcyB1c2VkIG9uIHRoZSBzaGFkZXIgdG8ga25vdyBpZiB3ZSB3YW50IHRvIGRyYXcgdG8gcGlja2luZyB0ZXh0dXJlIG9yIG5vcm1hbCBkcmF3LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNQaWNraW5nTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gJ2lzUGlja2luZyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdGhhdCBob2xkcyB0aGUgUkdCQSBjb2xvcnMgdXNlZCBmb3IgcGlja2luZy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRoYXQgaG9sZHMgdGhlIFJHQkEgY29sb3JzIHVzZWQgZm9yIHBpY2tpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwaWNraW5nQ29sb3JOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAncGlja2luZ0NvbG9yJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBpY2tpbmcgaWRlbnRpZmllciBmb3IgdGhlIE1WQy9URy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIG5hbWUgb2YgdGhlIHBpY2tpbmcgaWRlbnRpZmllciBmb3IgdGhlIE1WQy9URy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBpY2tpbmdNVkNUR0lkZW50aWZpZXJOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiBcIk1WQ1RHUGlja2luZ0NvbG9yXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgIFRJTUUgREVGQVVUTFMgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5zdGFudCB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaW5zdGFudCB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgSU5TVEFOVCgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnRpbWVWYXJpYWJsZXMuSU5TVEFOVDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludGVydmFsIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtICB0aGUgaW50ZXJ2YWwgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIElOVEVSVkFMKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudGltZVZhcmlhYmxlcy5JTlRFUlZBTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbmltYXRpb24gdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGFuaW1hdGlvbiB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgQU5JTUFUSU9OKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudGltZVZhcmlhYmxlcy5BTklNQVRJT047XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgIERBVEEgTkFUVVJFICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNlcXVlbnRpYWwgZGF0YSBuYXR1cmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzZXF1ZW50aWFsIGRhdGEgbmF0dXJlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgU0VRVUVOVElBTCgpIHtcclxuICAgICAgICByZXR1cm4gJ3NlcXVlbnRpYWwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGl2ZXJnZW50IGRhdGEgbmF0dXJlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgZGl2ZXJnZW50IGRhdGEgbmF0dXJlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgRElWRVJHRU5UKCkge1xyXG4gICAgICAgIHJldHVybiAnZGl2ZXJnZW50JztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHF1YWxpdGF0aXZlIGRhdGEgbmF0dXJlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgcXVhbGl0YXRpdmUgZGF0YSBuYXR1cmUuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBRVUFMSVRBVElWRSgpIHtcclxuICAgICAgICByZXR1cm4gJ3F1YWxpdGF0aXZlJztcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgRVNTRU5USUFMUyAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QgaWYgaXQgaGFzIHR5cGUgc3RyaW5nLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUsIGlmIHRoZSB0eXBlIG9mIHZhbHVlIGlzIG51bWJlci5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtICB0cnVlLCBpZiB0aGUgdHlwZSBvZiB2YWx1ZSBpcyBudW1iZXIsIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmUgYSBuZXN0ZWQgYXJyYXkgaW4gSmF2YXNjcmlwdC5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGdpdmVuIGFycmF5LiBcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fSAtIHRoZSBjbG9uZWQgbmVzdGVkIGFycmF5LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xvbmVOZXN0ZWRBcnJheShhcnIpIHtcclxuICAgICAgICBsZXQgaSwgY29weTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XHJcbiAgICAgICAgICAgIGNvcHkgPSBhcnIuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29weS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB0aGlzLmNsb25lTmVzdGVkQXJyYXkoY29weVtpXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IScpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aHJlYWRzIG9uIHRoZSB1c2VyIGNvbXB1dGVyLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIHRoZSBudW1iZXIgb2YgbG9naWNhbCBwcm9jZXNzb3JzIHBvdGVudGlhbGx5IGF2YWlsYWJsZSB0byB0aGUgdXNlciBhZ2VudFxyXG4gICAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93b3JrZXJzLmh0bWwjbmF2aWdhdG9yLmhhcmR3YXJlY29uY3VycmVuY3lcclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE51bWJlclRocmVhZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBNYXAgVmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQ2F0ZWdvcmljYWxWYXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBtYXBWYXJpYWJsZSAtIFRoZSB2YWx1ZSBnaXZlbi4gXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlLCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgQ2F0ZWdvcmljYWxWYXJpYWJsZSwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQ2F0ZWdvcmljYWxNYXBWYXJpYWJsZShtYXBWYXJpYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBtYXBWYXJpYWJsZSBpbnN0YW5jZW9mIENhdGVnb3JpY2FsVmFyaWFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IGEgcmFuZ2Ugb2YgYnl0ZXMgZnJvbSB0aGUgZ2l2ZW4gdXJsLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgLVRoZSB1cmwgdG8gcmVxdWVzdCB0aGUgYnl0ZXMgZnJvbS5cclxuICAgICAqIEBzZWUgXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBzdHJpbmcgb2YgdGV4dCBmcm9tIHN0YXJ0Qnl0ZSB0byBlbmRCeXRlLlxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ldFdvcmtQYXJzZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlcXVlc3RSYW5nZU9mQnl0ZXModXJsLCBzdGFydEJ5dGUsIGVuZEJ5dGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh1cmwpO1xyXG4gICAgICAgIGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnUmFuZ2UnOiBgYnl0ZXM9JHtzdGFydEJ5dGV9LSR7ZW5kQnl0ZX1gXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vZGU6ICdjb3JzJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiByZXMocmVzcG9uc2UudGV4dCgpKSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKCdFcnJvciBtYWtpbmcgcmVxdWVzdCB0byB0aGUgcmVtb3RlIFVSTCB0byBnZXQgcmFuZ2Ugb2YgYnl0ZXMuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgcmVtb3RlIGZpbGUgaW4gYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybCAtVGhlIHVybCB0byByZXF1ZXN0IGl0J3Mgc2l6ZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgb2YgdGhlIHJlbW90ZSBmaWxlIGluIGJ5dGVzLlxyXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgyNjY5NDUgLSBHZXQgY29udGVudCBsZW5ndGggZnJvbSB0aGUgcmVzcG9uc2VcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW5sdWNhcy9yZW1vdGUtZmlsZS1zaXplL2Jsb2IvbWFzdGVyL2luZGV4LmpzIC0gUmVtb3RlIGZpbGUgc2l6ZSBpbiBOb2RlLmpzXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvTWV0aG9kcy9IRUFEIC0gSEVBRCBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBDU1ZOZXRXb3JrUGFyc2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZXF1ZXN0RmlsZVNpemUodXJsKSB7XHJcbiAgICAgICAgZmV0Y2godXJsLCB7IG1ldGhvZDogJ0hFQUQnIH0pIC8vSEVBRCByZXF1ZXN0XHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVTaXplID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiByZXMoZmlsZVNpemUpKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoJ0Nhbm5vdCBnZXQgdGhlIHNpemUgb2YgdGhlIHJlbW90ZSBmaWxlLicpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoJ0Vycm9yIG1ha2luZyByZXF1ZXN0IHRvIHRoZSByZW1vdGUgVVJMIHNpemUuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICAgICAgIExFR0VORCAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGluaXRpYWwgcG9zaXRpb25zIGZvciB0aGUgTGVnZW5kIGRpdiBlbGVtZW50LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRMZWdlbmRQb3NpdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgVE9QX0xFRlQ6ICd0bCcsXHJcbiAgICAgICAgICAgIFRPUF9SSUdIVDogJ3RyJyxcclxuICAgICAgICAgICAgQk9UVE9NX0xFRlQ6ICdibCcsXHJcbiAgICAgICAgICAgIEJPVFRPTV9SSUdIVDogJ2JyJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgICAgICAgRVZFTlRTICAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbWVzc2FnZXMgZm9yIHRoZSBDU1YgcGFyc2VyLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMgLSB0aGUgbGlzdCBvZiBtZXNzYWdlcyBmb3IgdGhlIENTViBwYXJzZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBNRVNTQUdFU19DU1YoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgVE9fU1RBUlQ6ICdzdGFydCcsIC8vRnJvbSBUUCB0byBXcyB0byBzdGFydCBwcm9jZXNzaW5nIHRoZWlyIHBhcnRcclxuICAgICAgICAgICAgRU5EX1NUQVJUOiAnZW5kX3N0YXJ0JywgLy9GUk9NIGVhY2ggVyB0byBUUCBmbGFnIHRoYXQgdGhlIFcgYXMgdGVybWluYXRlZCBpdHMgcGFydFxyXG5cclxuICAgICAgICAgICAgVE9fTElNSVRTX0NBVDogJ2xpbWl0c19jYXRlZ29yaWVzJywgLy9GUk9NIFRQIHRvIFdzIHRvIGdldCB0aGUgbWluIGFuZCBtYXggYW5kIGNhdGVnb3JpZXMgZm9yIGVhY2ggY2F0IGFuZCBjb250IHZhcnMgXHJcbiAgICAgICAgICAgIEVORF9MSU1JVFNfQ0FUOiAnZW5kX2xpbWl0c19jYXRlZ29yaWVzJywgLy9GUk9NIGVhY2ggVyB0byBUUCB3aXRoIG1pbi9tYXggYW5kIGNhdGVnb3JpZXNcclxuXHJcbiAgICAgICAgICAgIFRPX0xJTUlUU19DQVRfUkVTOiAnbGltaXRzX2NhdGVnb3JpZXNfcmVzJywgLy9GUk9NIFRQIHRvIFdzIHdpdGggdGhlIHJlc3VsdGluZyBjbGFzc2VzL2NhdGVnb3JpZXMgYW5kIHRpbWUgZ3JhbnVsZXNcclxuICAgICAgICAgICAgRU5EX0xJTUlUU19DQVRfUkVTOiAnZW5kX2xpbWl0c19jYXRlZ29yaWVzX3JlcycsIC8vRlJPTSBlYWNoIFcgdG8gVFAgbWVhbmluZyB0aGUgVyBoYXMgYWxsIHRoZSBNVkNzIGFuZCBUR3MgaW4gcGxhY2VcclxuXHJcbiAgICAgICAgICAgIFRPX0pPSU5fREFUQTogJ2pvaW5fZGF0YScsIC8vRlJPTSBUUCBUbyBXcyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IE1WQ3MgYW5kIFRHcyBpbiBvcmRlciB0byBqb2luIHRoZSBmaW5hbCByb3dzXHJcbiAgICAgICAgICAgIEVORF9KT0lOX0RBVEE6ICdlbmRfam9pbl9kYXRhJywgLy9GUk9NIFdzIFRvIFRQIGFzIGEgZmxhZyB0byByZWNlaXZlIGRhdGFcclxuXHJcbiAgICAgICAgICAgIFRPX0dFTkVSQVRFX1JHQkE6ICdnZW5lcmF0ZV9yZ2JhJywvL0ZST00gVFAgVG8gV3MgdG8gZ2VuZXJhdGUgUkdCQSBpbmZvcm1hdGlvbiBmb3IgZWFjaCByb3dcclxuICAgICAgICAgICAgRU5EX0dFTkVSQVRFX1JHQkE6ICdlbmRfZ2VuZXJhdGVfcmdiYScsIC8vRlJPTSBlYWNoIFcgdG8gVFAgbWVhbmluZyB0aGUgVyBnZW5lcmF0ZWQgYWxsIFJHQkEgdmFsdWVzXHJcblxyXG4gICAgICAgICAgICBUT19TRU5EX0RBVEE6ICdzZW5kX2RhdGEnLCAvL0ZST00gVFAgdG8gb25lIFcgYXQgYSB0aW1lIHRvIHJlY2VpdmUgaXRzIGRhdGFcclxuICAgICAgICAgICAgRU5EX1NFTkRfREFUQTogJ2VuZF9zZW5kX2RhdGEnIC8vRlJPTSBXIHRvIFRQIHdpdGggdGhlIE1WQ3MgYW5kIFRHcyBjcmVhdGVkIFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IGV4aXN0IGluIHRoZSBUZW1wb3JhbCBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RXZlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBsaWJyYXJ5IGxvYWRlZCBldmVudC5cclxuICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMSUJSQVJZX0xPQURFRF9FVkVOVDogJ2xpYnJhcnlMb2FkZWQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHBhcnNlciBlbmRlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBBUlNFUl9FTkRFRF9FVkVOVDogJ3BhcnNlckVuZCcsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZm9yIGdlb21ldHJ5IGlkcy5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEdFT01FVFJZX0lEU19FVkVOVDogJ2dlb21ldHJ5SWRzRW5kJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzaGFwZXMgaW1hZ2UgbG9hZGVkIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBOZWVkZWQsIG90aGVyd2lzZSBjb3VsZCBjYXVzZSB0aGUgZXJyb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9qeXdhcnJlbi93ZWJnbC1kaXN0b3J0L2lzc3Vlcy80XHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTSEFQRVNfSU1BR0VfTE9BREVEX0VWRU5UOiAnc2hhcGVzSW1hZ2VMb2FkZWQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHBhdHRlcm5zIGltYWdlIGxvYWRlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBBVFRFUk5TX0lNQUdFX0xPQURFRF9FVkVOVDogJ3BhdHRlcm5zSW1hZ2VMb2FkZWQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZpZ3VyZXMgaW1hZ2UgbG9hZGVkIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRklHVVJFU19JTUFHRV9MT0FERURfRVZFTlQ6ICdmaWd1cmVzSW1hZ2VMb2FkZWQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHRpbWUgcmFuZ2UgY2hhbmdlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRJTUVfUkFOR0VfQ0hBTkdFRDogJ1RpbWVSYW5nZUNoYW5nZWQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGxlZ2VuZCBjaGFuZ2VkIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTEVHRU5EX0NIQU5HRUQ6ICdMZWdlbmRDaGFuZ2VkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBleHRlbmRlZCB0ZW1wb3JhbCBuYXZpZ2F0b3IgbGVnZW5kIGNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFWFRFTkRFRF9URU1QT1JBTF9OQVZJR0FUT1JfTEVHRU5EX0NIQU5HRUQ6ICdleHRlbmRlZF90ZW1wb3JhbF9uYXZpZ2F0b3JfbGVnZW5kJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBleHRlbmRlZCB0ZW1wb3JhbCBuYXZpZ2F0b3IgdGltZSBheGlzIGNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFWFRFTkRFRF9URU1QT1JBTF9OQVZJR0FUT1JfVElNRV9DSEFOR0VEOiAnZXh0ZW5kZWRfdGVtcG9yYWxfbmF2aWdhdG9yX3RpbWUnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGV2ZW50IGZvciB0aGUgcmVzaXplIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSRVNJWkU6ICdyZXNpemUnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBhbmQgdGhlaXIga2V5IGNvZGVzIHRvIGJlIHVzZWQgYnkgVGltZUNvbnRyb2wgYW5kIEVUTi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHt7TEVGVF9BUlJPVzogbnVtYmVyLCBBX0tFWTpudW1iZXIsIFJJR0hUX0FSUk9XOiBudW1iZXIsIERfS0VZOiBudW1iZXIsIERPV05fQVJST1c6IG51bWJlciwgU19LRVk6IG51bWJlciwgVVBfQVJST1c6IG51bWJlciwgV19LRVk6IG51bWJlcn19IC0gdGhlIGxpc3Qgb2Yga2V5cyBhbmQgdGhlaXIga2V5IGNvZGVzIHRvIGJlIHVzZWQgYnkgVGltZUNvbnRyb2wgYW5kIEVUTi5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cuY2FtYmlhcmVzZWFyY2guY29tL2FydGljbGVzLzE1L2phdmFzY3JpcHQtY2hhci1jb2Rlcy1rZXktY29kZXMgLSBLZXkgY29kZXNcclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEtleWJvYXJkS2V5Q29kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgTEVGVF9BUlJPVzogMzcsXHJcbiAgICAgICAgICAgIEFfS0VZOiA2NSxcclxuICAgICAgICAgICAgUklHSFRfQVJST1c6IDM5LFxyXG4gICAgICAgICAgICBEX0tFWTogNjgsXHJcbiAgICAgICAgICAgIERPV05fQVJST1c6IDQwLFxyXG4gICAgICAgICAgICBTX0tFWTogODMsXHJcbiAgICAgICAgICAgIFVQX0FSUk9XOiAzOCxcclxuICAgICAgICAgICAgV19LRVk6IDg3XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9HaXNwbGF5RGVmYXVsdHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUF4REE7QUEwREE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/Gisplay/VVs/DataVariable.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Represents a variable. This variable has an external and an internal Name.\r\n * External name is the name of the variable on the dataset.\r\n * Internal name is the name the programmer gave to this variable.\r\n * @export\r\n * @class DataVariable\r\n */\nvar DataVariable = exports.DataVariable = function () {\n\n  /**\r\n   * Creates an instance of a Variable.\r\n   * @param {string} externalName - The external name for this variable.\r\n   * @param {string} internalName - The internal name for this variable.\r\n   * @memberof DataVariable\r\n   */\n  function DataVariable(externalName, internalName) {\n    _classCallCheck(this, DataVariable);\n\n    /**\r\n     * It's the external name of this variable\r\n     * @type {string}\r\n     */\n    this.externalName = externalName;\n    /**\r\n     * The internal name for this variable.\r\n     * @type {string}\r\n     */\n    this.internalName = internalName;\n  }\n\n  /**\r\n   * Returns the external name for this visual variable.\r\n   * @returns {string} - the external name of the visual variable.\r\n   * @memberof DataVariable\r\n   */\n\n\n  _createClass(DataVariable, [{\n    key: \"getExternalName\",\n    value: function getExternalName() {\n      return this.externalName;\n    }\n\n    /**\r\n     * Returns the internal name for this visual variable.\r\n     * @returns {string} - the internal name of the visual variable.\r\n     * @memberof DataVariable\r\n     */\n\n  }, {\n    key: \"getInternalName\",\n    value: function getInternalName() {\n      return this.internalName;\n    }\n  }]);\n\n  return DataVariable;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvRGF0YVZhcmlhYmxlLmpzPzgzNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlcHJlc2VudHMgYSB2YXJpYWJsZS4gVGhpcyB2YXJpYWJsZSBoYXMgYW4gZXh0ZXJuYWwgYW5kIGFuIGludGVybmFsIE5hbWUuXHJcbiAqIEV4dGVybmFsIG5hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIG9uIHRoZSBkYXRhc2V0LlxyXG4gKiBJbnRlcm5hbCBuYW1lIGlzIHRoZSBuYW1lIHRoZSBwcm9ncmFtbWVyIGdhdmUgdG8gdGhpcyB2YXJpYWJsZS5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgRGF0YVZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGF0YVZhcmlhYmxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBEYXRhVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdCdzIHRoZSBleHRlcm5hbCBuYW1lIG9mIHRoaXMgdmFyaWFibGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZXh0ZXJuYWxOYW1lID0gZXh0ZXJuYWxOYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnRlcm5hbCBuYW1lIGZvciB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbE5hbWUgPSBpbnRlcm5hbE5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBleHRlcm5hbCBuYW1lIGZvciB0aGlzIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGV4dGVybmFsIG5hbWUgb2YgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBEYXRhVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0RXh0ZXJuYWxOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIG5hbWUgZm9yIHRoaXMgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIERhdGFWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRJbnRlcm5hbE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxOYW1lO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L1ZWcy9EYXRhVmFyaWFibGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!*************************************!*\
  !*** ./src/Gisplay/GisplayError.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Custom Error to create a popup message to inform the user about a particular problem.\r\n * @export\r\n * @class GisplayError\r\n * @extends {Error}\r\n * @see https://medium.com/@xjamundx/custom-javascript-errors-in-es6-aa891b173f87\r\n */\nvar GisplayError = exports.GisplayError = function (_Error) {\n        _inherits(GisplayError, _Error);\n\n        /**\r\n         * Creates an instance of GisplayError.\r\n         * @param {string} message - The message to provide to the user.\r\n         * @see https://github.com/codrops/ModalWindowEffects\r\n         * @see https://codepen.io/SMLMRKHLMS/pen/rVYRLQ \r\n         * @memberof GisplayError\r\n         */\n        function GisplayError(message) {\n                _classCallCheck(this, GisplayError);\n\n                // Error.captureStackTrace(this, GisplayError);\n                var _this = _possibleConstructorReturn(this, (GisplayError.__proto__ || Object.getPrototypeOf(GisplayError)).call(this, message));\n\n                console.error(\"GisplayError\");\n                // document.getElementById('head').innerHTML = '';\n\n                // this.createErrorDialog(message);\n                /*  let modal = document.createElement('div');\r\n                 modal.className = 'modal';\r\n                 let content = document.createElement('div');\r\n                 content.className = 'content';\r\n                 content.innerHTML = message;\r\n                    modal.appendChild(content);\r\n                 document.body.appendChild(modal); */\n\n                var modal = document.createElement('div');\n                modal.className = 'gisplayModal';\n\n                var overlay = document.createElement('div');\n                overlay.className = 'gisplayModalOverlay';\n\n                var content = document.createElement('div');\n                content.className = 'gisplayModalContent';\n\n                var contentTitle = document.createElement('div'); //Title\n                var errorFoundParagraph = document.createElement('p'); //Paragraph in title\n                errorFoundParagraph.innerHTML = 'Error found:';\n                contentTitle.appendChild(errorFoundParagraph);\n                var contentMessage = document.createElement('p'); //Content message\n                contentMessage.innerHTML = message;\n                var checkDevTools = document.createElement('button'); //Open devtools button\n                checkDevTools.innerHTML = 'Open Developer tools for more information';\n\n                content.appendChild(contentTitle);\n                content.appendChild(contentMessage);\n                content.appendChild(checkDevTools);\n\n                modal.appendChild(overlay);\n                modal.appendChild(content);\n                document.body.appendChild(modal);\n                return _this;\n        }\n\n        _createClass(GisplayError, [{\n                key: 'createErrorDialog',\n                value: function createErrorDialog(message) {\n                        console.log(\"wut\");\n                        var modal = document.createElement('div');\n                        modal.className = 'modal';\n                        var content = document.createElement('div');\n                        content.className = 'content';\n                        content.innerHTML = message;\n\n                        modal.appendChild(content);\n                        document.body.appendChild(modal);\n                }\n        }]);\n\n        return GisplayError;\n}(Error);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5RXJyb3IuanM/NzNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIEN1c3RvbSBFcnJvciB0byBjcmVhdGUgYSBwb3B1cCBtZXNzYWdlIHRvIGluZm9ybSB0aGUgdXNlciBhYm91dCBhIHBhcnRpY3VsYXIgcHJvYmxlbS5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgR2lzcGxheUVycm9yXHJcbiAqIEBleHRlbmRzIHtFcnJvcn1cclxuICogQHNlZSBodHRwczovL21lZGl1bS5jb20vQHhqYW11bmR4L2N1c3RvbS1qYXZhc2NyaXB0LWVycm9ycy1pbi1lczYtYWE4OTFiMTczZjg3XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHaXNwbGF5RXJyb3IuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHByb3ZpZGUgdG8gdGhlIHVzZXIuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2Ryb3BzL01vZGFsV2luZG93RWZmZWN0c1xyXG4gICAgICogQHNlZSBodHRwczovL2NvZGVwZW4uaW8vU01MTVJLSExNUy9wZW4vclZZUkxRIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlFcnJvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgR2lzcGxheUVycm9yKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiR2lzcGxheUVycm9yXCIpO1xyXG4gICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFkJykuaW5uZXJIVE1MID0gJyc7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuY3JlYXRlRXJyb3JEaWFsb2cobWVzc2FnZSk7XHJcbiAgICAgICAgLyogIGxldCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICBtb2RhbC5jbGFzc05hbWUgPSAnbW9kYWwnO1xyXG4gICAgICAgICBsZXQgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcclxuICAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gXHJcbiAgICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTsgKi9cclxuXHJcbiAgICAgICAgbGV0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbW9kYWwuY2xhc3NOYW1lID0gJ2dpc3BsYXlNb2RhbCc7XHJcblxyXG4gICAgICAgIGxldCBvdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgb3ZlcmxheS5jbGFzc05hbWUgPSAnZ2lzcGxheU1vZGFsT3ZlcmxheSc7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnZ2lzcGxheU1vZGFsQ29udGVudCc7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50VGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy9UaXRsZVxyXG4gICAgICAgIGxldCBlcnJvckZvdW5kUGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpOyAvL1BhcmFncmFwaCBpbiB0aXRsZVxyXG4gICAgICAgIGVycm9yRm91bmRQYXJhZ3JhcGguaW5uZXJIVE1MID0gJ0Vycm9yIGZvdW5kOic7XHJcbiAgICAgICAgY29udGVudFRpdGxlLmFwcGVuZENoaWxkKGVycm9yRm91bmRQYXJhZ3JhcGgpO1xyXG4gICAgICAgIGxldCBjb250ZW50TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTsgLy9Db250ZW50IG1lc3NhZ2VcclxuICAgICAgICBjb250ZW50TWVzc2FnZS5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gICAgICAgIGxldCBjaGVja0RldlRvb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7IC8vT3BlbiBkZXZ0b29scyBidXR0b25cclxuICAgICAgICBjaGVja0RldlRvb2xzLmlubmVySFRNTCA9ICdPcGVuIERldmVsb3BlciB0b29scyBmb3IgbW9yZSBpbmZvcm1hdGlvbic7XHJcblxyXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudFRpdGxlKTtcclxuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnRNZXNzYWdlKTtcclxuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNoZWNrRGV2VG9vbHMpO1xyXG5cclxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChvdmVybGF5KTtcclxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY3JlYXRlRXJyb3JEaWFsb2cobWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwid3V0XCIpO1xyXG4gICAgICAgIGxldCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdtb2RhbCc7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcclxuICAgICAgICBjb250ZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcblxyXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWwpO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L0dpc3BsYXlFcnJvci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7Ozs7OztBQU9BOzs7QUFFQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4Q0E7QUF5Q0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQS9EQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!************************************************!*\
  !*** ./src/Gisplay/VVs/CategoricalVariable.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CategoricalVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapVariable2 = __webpack_require__(/*! ./MapVariable */ 4);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nvar _GisplayError = __webpack_require__(/*! ../GisplayError */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// import { GisplayMap } from '../Maps/GisplayMap';\n\n/**\r\n * Represents a categorical map variable.\r\n * Categorical data, is for those aspects of your data where you make a distinction between different groups, and where you typically can list a small number of categories. This includes product type, gender, age group, etc.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class CategoricalVariable\r\n */\nvar CategoricalVariable = exports.CategoricalVariable = function (_MapVariable) {\n    _inherits(CategoricalVariable, _MapVariable);\n\n    /**\r\n     * Creates an instance of CategoricalVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The name of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Map<string, string|number>} visualVariableMapping - The mapping for the given visual variable.\r\n     * @param {GisplayMap} gisplayMap - The GisplayMap. It's used when we need to get the colors for the variable.\r\n     * @memberof CategoricalVariable\r\n     */\n    function CategoricalVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, gisplayMap) {\n        _classCallCheck(this, CategoricalVariable);\n\n        /**\r\n         * The categories for this categorical variable.\r\n         * @type {Set<string>}\r\n         */\n        var _this = _possibleConstructorReturn(this, (CategoricalVariable.__proto__ || Object.getPrototypeOf(CategoricalVariable)).call(this, externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping));\n\n        _this.categories = new Set();\n        if (visualVariableMapping && visualVariableMapping.size > 0) {\n            //The mapping was given by the programmer (Map<\"ABC\"->\"red\", \"DEF\"->\"blue\" etc> )\n            /**\r\n             * Map containing the values for this categorical map variable and an integer to represent each of these values.\r\n             * @type {Map<string, number>} \r\n             */\n            _this.valueToIndexMap = _this._createCategoricalVarMap(visualVariableMapping.keys());\n            _this._setIndexToUsableValueMap();\n        }\n\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\n        _this.classCalculationRequiredBool = _this.visualVariableMapping.size === 0;\n        /**\r\n         * The GisplayMap object.\r\n         * @type {GisplayMap}\r\n         */\n        _this.gisplayMap = gisplayMap;\n        console.error(_this);\n        return _this;\n    }\n\n    /**\r\n     * For each category in this categorical variable, create one index which will be used as substitute.\r\n     * This replacement will save up a lot of space. \r\n     * @param {Array<string>} values - The categories that this visual variable holds. \r\n     * @returns {Map<string, number>} - the map which contains a sequential integer to represent each category.\r\n     * @memberof CategoricalVariable\r\n     */\n\n\n    _createClass(CategoricalVariable, [{\n        key: '_createCategoricalVarMap',\n        value: function _createCategoricalVarMap(values) {\n            var map = new Map();\n            var index = 0;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var value = _step.value;\n\n                    map.set(value, index++);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return map;\n        }\n\n        /**\r\n         * Returns the value to index map.\r\n         * @returns {Map<string, number>} - the map containing the values for this categorical visual variable and an integer to represent each of these values.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getValueIndexMapping',\n        value: function getValueIndexMapping() {\n            return this.valueToIndexMap;\n        }\n\n        /**\r\n         * Returns the index of the given category.\r\n         * @param {string} value - The category to find. \r\n         * @returns {number} - the index of the given category.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'findIndex',\n        value: function findIndex(value) {\n            return this.getValueIndexMapping().get(value);\n        }\n\n        /**\r\n         * Set each index (of each category) to it's respective value (color, or number in the shape/texture image).\r\n         * E.g. 0 -> [255,0,0] etc or 0 -> 14 (index in image).\r\n         * @private\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: '_setIndexToUsableValueMap',\n        value: function _setIndexToUsableValueMap() {\n            var VVS = _GisplayDefaults.GisplayDefaults.getAvailableVisualVariables();\n\n            var typeOfVisualVariable = this.getTypeOfVisualVariable();\n            var valueToIndexMapKeys = this.valueToIndexMap.keys();\n            console.warn(valueToIndexMapKeys);\n            console.warn(this.getVisualVariableMapping());\n\n            switch (typeOfVisualVariable) {\n                case VVS.COLOR:\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = valueToIndexMapKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var mapkey = _step2.value;\n\n                            var index = this.valueToIndexMap.get(mapkey); // 0, 1..\n                            var color = this.visualVariableMapping.get(mapkey); // [255, 0, 0], [122, 220, 85] ...\n                            this.indexToUsableValueMap.set(index, color);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n\n                    break;\n                case VVS.SHAPE:\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = valueToIndexMapKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var _mapkey = _step3.value;\n                            // \"Y\", \"N\"\n                            var _index = this.valueToIndexMap.get(_mapkey); // 0, 1..\n                            var shapeName = this.visualVariableMapping.get(_mapkey); // \"terrain\", \"bricks\", \"triangle\"\n                            var shapeIndex = _GisplayDefaults.GisplayDefaults.findShapeIndex(shapeName); // 6, 7, 12, 13\n                            // console.log(index, shapeName, textureIndex);\n                            this.indexToUsableValueMap.set(_index, shapeIndex);\n                        }\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    break;\n                case VVS.TEXTURE:\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = valueToIndexMapKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var _mapkey2 = _step4.value;\n                            // \"Y\", \"N\"\n                            var _index2 = this.valueToIndexMap.get(_mapkey2); // 0, 1..\n                            var patternName = this.visualVariableMapping.get(_mapkey2); // \"terrain\", \"bricks\", \"triangle\"\n                            var patternIndex = _GisplayDefaults.GisplayDefaults.findPatternIndex(patternName); // 6, 7, 12, 13\n                            console.log(_index2, patternName, patternIndex);\n                            this.indexToUsableValueMap.set(_index2, patternIndex);\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n\n                    break;\n                case VVS.SIZE:\n                    throw new _GisplayError.GisplayError(\"Visual variable: size, can't be used with a categorical variable.\");\n                case VVS.ORIENTATION:\n                    console.log(valueToIndexMapKeys, this.valueToIndexMap, this.visualVariableMapping);\n                    var _iteratorNormalCompletion5 = true;\n                    var _didIteratorError5 = false;\n                    var _iteratorError5 = undefined;\n\n                    try {\n                        for (var _iterator5 = valueToIndexMapKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                            var _mapkey3 = _step5.value;\n                            // \"Y\", \"N\"\n                            var _index3 = this.valueToIndexMap.get(_mapkey3); // 0, 1..\n                            var orientationValue = this.visualVariableMapping.get(_mapkey3); // 0, 28, 90 (degrees)\n                            console.log(_index3, orientationValue);\n                            this.indexToUsableValueMap.set(_index3, orientationValue);\n                        }\n                    } catch (err) {\n                        _didIteratorError5 = true;\n                        _iteratorError5 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                _iterator5.return();\n                            }\n                        } finally {\n                            if (_didIteratorError5) {\n                                throw _iteratorError5;\n                            }\n                        }\n                    }\n\n                // throw new Error(\"Index to orientation value not yet implemented in Categorical Variable. Should look like COLOR + SHAPE/TEXTURE combined\");\n            }\n            // console.log(\"CAT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\n        }\n\n        /**\r\n         * Add a categorie to the set of categories in this categorical variable.\r\n         * @param {string} category - The category to add to this categorical variable. \r\n         */\n\n    }, {\n        key: 'addCategory',\n        value: function addCategory(category) {\n            this.categories.add(category);\n        }\n\n        /**\r\n         * Add the given categories to the set of categories of this Categorical variable.\r\n         * @param {Set<string>} categories - The categories given. \r\n         */\n\n    }, {\n        key: 'addCategories',\n        value: function addCategories(categories) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = categories.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var category = _step6.value;\n\n                    this.addCategory(category);\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Returns the set of categories for this Categorical variable.\r\n         * @returns {Set<string>} - the set of categories for this Categorical variable.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getCategories',\n        value: function getCategories() {\n            return this.categories;\n        }\n\n        /**\r\n         * Returns the number of categories for this categorical variable.\r\n         * @returns {number} - the number of categories for this categorical variable.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getNumCategories',\n        value: function getNumCategories() {\n            return this.categories.size !== 0 ? this.categories.size : this.getVisualVariableMapping().size;\n        }\n\n        /**\r\n         * Update the information when all categories are on the Set. \r\n         * Used when the categories weren't given by the programmer.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'updateCategoricalInformation',\n        value: function updateCategoricalInformation() {\n            this.valueToIndexMap = this._createCategoricalVarMap(this.categories.keys());\n\n            var categories = Array.from(this.categories);\n            console.error(this.valueToIndexMap.size);\n            if (this.valueToIndexMap.size < 2) throw new _GisplayError.GisplayError('Only one category (' + Array.from(this.valueToIndexMap.keys()) + ') in the dataset. ');\n            var colors = this.gisplayMap.getDefaultColors(this.valueToIndexMap.size, _GisplayDefaults.GisplayDefaults.QUALITATIVE());\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = categories.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var _step7$value = _slicedToArray(_step7.value, 2),\n                        i = _step7$value[0],\n                        category = _step7$value[1];\n\n                    this.visualVariableMapping.set(category, colors[i]);\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n\n            this._setIndexToUsableValueMap();\n        }\n\n        /**\r\n         * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n         * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return this.classCalculationRequiredBool; // the map has no K->V pairs\n        }\n    }]);\n\n    return CategoricalVariable;\n}(_MapVariable2.MapVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvQ2F0ZWdvcmljYWxWYXJpYWJsZS5qcz8yZGJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcFZhcmlhYmxlIH0gZnJvbSAnLi9NYXBWYXJpYWJsZSc7XHJcbmltcG9ydCB7IEdpc3BsYXlEZWZhdWx0cyB9IGZyb20gJy4uL0dpc3BsYXlEZWZhdWx0cyc7XHJcbmltcG9ydCB7IEdpc3BsYXlFcnJvciB9IGZyb20gJy4uL0dpc3BsYXlFcnJvcic7XHJcbi8vIGltcG9ydCB7IEdpc3BsYXlNYXAgfSBmcm9tICcuLi9NYXBzL0dpc3BsYXlNYXAnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjYXRlZ29yaWNhbCBtYXAgdmFyaWFibGUuXHJcbiAqIENhdGVnb3JpY2FsIGRhdGEsIGlzIGZvciB0aG9zZSBhc3BlY3RzIG9mIHlvdXIgZGF0YSB3aGVyZSB5b3UgbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gZGlmZmVyZW50IGdyb3VwcywgYW5kIHdoZXJlIHlvdSB0eXBpY2FsbHkgY2FuIGxpc3QgYSBzbWFsbCBudW1iZXIgb2YgY2F0ZWdvcmllcy4gVGhpcyBpbmNsdWRlcyBwcm9kdWN0IHR5cGUsIGdlbmRlciwgYWdlIGdyb3VwLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQ2F0ZWdvcmljYWxWYXJpYWJsZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhdGVnb3JpY2FsVmFyaWFibGUgZXh0ZW5kcyBNYXBWYXJpYWJsZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENhdGVnb3JpY2FsVmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZXJuYWxOYW1lIC0gVGhlIGV4dGVybmFsIG5hbWUgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJuYWxOYW1lIC0gVGhlIGludGVybmFsIG5hbWUgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU9mVmlzdWFsVmFyaWFibGUgLSBUaGUgbmFtZSBvZiB2aXN1YWwgdmFyaWFibGUgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJWYXJpYWJsZVF1YWxpZmllciAtIFRoZSBzaGFkZXIgdmFyaWFibGUgcXVhbGlmaWVyLiBcclxuICAgICAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nfG51bWJlcj59IHZpc3VhbFZhcmlhYmxlTWFwcGluZyAtIFRoZSBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHBhcmFtIHtHaXNwbGF5TWFwfSBnaXNwbGF5TWFwIC0gVGhlIEdpc3BsYXlNYXAuIEl0J3MgdXNlZCB3aGVuIHdlIG5lZWQgdG8gZ2V0IHRoZSBjb2xvcnMgZm9yIHRoZSB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZywgZ2lzcGxheU1hcCkge1xyXG4gICAgICAgIHN1cGVyKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhdGVnb3JpZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBpZiAodmlzdWFsVmFyaWFibGVNYXBwaW5nICYmIHZpc3VhbFZhcmlhYmxlTWFwcGluZy5zaXplID4gMCkgeyAvL1RoZSBtYXBwaW5nIHdhcyBnaXZlbiBieSB0aGUgcHJvZ3JhbW1lciAoTWFwPFwiQUJDXCItPlwicmVkXCIsIFwiREVGXCItPlwiYmx1ZVwiIGV0Yz4gKVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFwIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBmb3IgdGhpcyBjYXRlZ29yaWNhbCBtYXAgdmFyaWFibGUgYW5kIGFuIGludGVnZXIgdG8gcmVwcmVzZW50IGVhY2ggb2YgdGhlc2UgdmFsdWVzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlVG9JbmRleE1hcCA9IHRoaXMuX2NyZWF0ZUNhdGVnb3JpY2FsVmFyTWFwKHZpc3VhbFZhcmlhYmxlTWFwcGluZy5rZXlzKCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiAgXHJcbiAgICAgICAgICogQm9vbGVhbiB0aGF0IHN0b3JlcyB0cnVlIGlmIGNsYXNzIGNhbGN1dGF0aW9uIGlzIHJlcXVpcmVkLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3NDYWxjdWxhdGlvblJlcXVpcmVkQm9vbCA9IHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nLnNpemUgPT09IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEdpc3BsYXlNYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEB0eXBlIHtHaXNwbGF5TWFwfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2lzcGxheU1hcCA9IGdpc3BsYXlNYXA7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGNhdGVnb3J5IGluIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUsIGNyZWF0ZSBvbmUgaW5kZXggd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHN1YnN0aXR1dGUuXHJcbiAgICAgKiBUaGlzIHJlcGxhY2VtZW50IHdpbGwgc2F2ZSB1cCBhIGxvdCBvZiBzcGFjZS4gXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZhbHVlcyAtIFRoZSBjYXRlZ29yaWVzIHRoYXQgdGhpcyB2aXN1YWwgdmFyaWFibGUgaG9sZHMuIFxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcj59IC0gdGhlIG1hcCB3aGljaCBjb250YWlucyBhIHNlcXVlbnRpYWwgaW50ZWdlciB0byByZXByZXNlbnQgZWFjaCBjYXRlZ29yeS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9jcmVhdGVDYXRlZ29yaWNhbFZhck1hcCh2YWx1ZXMpIHtcclxuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKVxyXG4gICAgICAgICAgICBtYXAuc2V0KHZhbHVlLCBpbmRleCsrKTtcclxuICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgdG8gaW5kZXggbWFwLlxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcj59IC0gdGhlIG1hcCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmlzdWFsIHZhcmlhYmxlIGFuZCBhbiBpbnRlZ2VyIHRvIHJlcHJlc2VudCBlYWNoIG9mIHRoZXNlIHZhbHVlcy5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFZhbHVlSW5kZXhNYXBwaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVG9JbmRleE1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBjYXRlZ29yeS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjYXRlZ29yeSB0byBmaW5kLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBjYXRlZ29yeS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRJbmRleCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlSW5kZXhNYXBwaW5nKCkuZ2V0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBlYWNoIGluZGV4IChvZiBlYWNoIGNhdGVnb3J5KSB0byBpdCdzIHJlc3BlY3RpdmUgdmFsdWUgKGNvbG9yLCBvciBudW1iZXIgaW4gdGhlIHNoYXBlL3RleHR1cmUgaW1hZ2UpLlxyXG4gICAgICogRS5nLiAwIC0+IFsyNTUsMCwwXSBldGMgb3IgMCAtPiAxNCAoaW5kZXggaW4gaW1hZ2UpLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKSB7XHJcbiAgICAgICAgbGV0IFZWUyA9IEdpc3BsYXlEZWZhdWx0cy5nZXRBdmFpbGFibGVWaXN1YWxWYXJpYWJsZXMoKTtcclxuXHJcbiAgICAgICAgbGV0IHR5cGVPZlZpc3VhbFZhcmlhYmxlID0gdGhpcy5nZXRUeXBlT2ZWaXN1YWxWYXJpYWJsZSgpO1xyXG4gICAgICAgIGxldCB2YWx1ZVRvSW5kZXhNYXBLZXlzID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAua2V5cygpO1xyXG4gICAgICAgIGNvbnNvbGUud2Fybih2YWx1ZVRvSW5kZXhNYXBLZXlzKTtcclxuICAgICAgICBjb25zb2xlLndhcm4odGhpcy5nZXRWaXN1YWxWYXJpYWJsZU1hcHBpbmcoKSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZU9mVmlzdWFsVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgY2FzZSBWVlMuQ09MT1I6XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtYXBrZXkgb2YgdmFsdWVUb0luZGV4TWFwS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMudmFsdWVUb0luZGV4TWFwLmdldChtYXBrZXkpOyAvLyAwLCAxLi5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZy5nZXQobWFwa2V5KTsgLy8gWzI1NSwgMCwgMF0sIFsxMjIsIDIyMCwgODVdIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVlZTLlNIQVBFOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwa2V5IG9mIHZhbHVlVG9JbmRleE1hcEtleXMpIHsgLy8gXCJZXCIsIFwiTlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAuZ2V0KG1hcGtleSk7IC8vIDAsIDEuLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaGFwZU5hbWUgPSB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZy5nZXQobWFwa2V5KTsgLy8gXCJ0ZXJyYWluXCIsIFwiYnJpY2tzXCIsIFwidHJpYW5nbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaGFwZUluZGV4ID0gR2lzcGxheURlZmF1bHRzLmZpbmRTaGFwZUluZGV4KHNoYXBlTmFtZSk7IC8vIDYsIDcsIDEyLCAxM1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGV4LCBzaGFwZU5hbWUsIHRleHR1cmVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXAuc2V0KGluZGV4LCBzaGFwZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFZWUy5URVhUVVJFOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwa2V5IG9mIHZhbHVlVG9JbmRleE1hcEtleXMpIHsgLy8gXCJZXCIsIFwiTlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAuZ2V0KG1hcGtleSk7IC8vIDAsIDEuLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuTmFtZSA9IHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nLmdldChtYXBrZXkpOyAvLyBcInRlcnJhaW5cIiwgXCJicmlja3NcIiwgXCJ0cmlhbmdsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdHRlcm5JbmRleCA9IEdpc3BsYXlEZWZhdWx0cy5maW5kUGF0dGVybkluZGV4KHBhdHRlcm5OYW1lKTsgLy8gNiwgNywgMTIsIDEzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZXgsIHBhdHRlcm5OYW1lLCBwYXR0ZXJuSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgcGF0dGVybkluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFZWUy5TSVpFOlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdpc3BsYXlFcnJvcihcIlZpc3VhbCB2YXJpYWJsZTogc2l6ZSwgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgY2F0ZWdvcmljYWwgdmFyaWFibGUuXCIpO1xyXG4gICAgICAgICAgICBjYXNlIFZWUy5PUklFTlRBVElPTjpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHZhbHVlVG9JbmRleE1hcEtleXMsIHRoaXMudmFsdWVUb0luZGV4TWFwLCB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtYXBrZXkgb2YgdmFsdWVUb0luZGV4TWFwS2V5cykgeyAvLyBcIllcIiwgXCJOXCJcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnZhbHVlVG9JbmRleE1hcC5nZXQobWFwa2V5KTsgLy8gMCwgMS4uXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWVudGF0aW9uVmFsdWUgPSB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZy5nZXQobWFwa2V5KTsgLy8gMCwgMjgsIDkwIChkZWdyZWVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGV4LCBvcmllbnRhdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4VG9Vc2FibGVWYWx1ZU1hcC5zZXQoaW5kZXgsIG9yaWVudGF0aW9uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCB0byBvcmllbnRhdGlvbiB2YWx1ZSBub3QgeWV0IGltcGxlbWVudGVkIGluIENhdGVnb3JpY2FsIFZhcmlhYmxlLiBTaG91bGQgbG9vayBsaWtlIENPTE9SICsgU0hBUEUvVEVYVFVSRSBjb21iaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDQVQgVlZfVE9fSU5ERVhfTUFQID09PT09PT09PT09PT09PT09PT09PT09PT1cIiwgdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgY2F0ZWdvcmllIHRvIHRoZSBzZXQgb2YgY2F0ZWdvcmllcyBpbiB0aGlzIGNhdGVnb3JpY2FsIHZhcmlhYmxlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IC0gVGhlIGNhdGVnb3J5IHRvIGFkZCB0byB0aGlzIGNhdGVnb3JpY2FsIHZhcmlhYmxlLiBcclxuICAgICAqL1xyXG4gICAgYWRkQ2F0ZWdvcnkoY2F0ZWdvcnkpIHtcclxuICAgICAgICB0aGlzLmNhdGVnb3JpZXMuYWRkKGNhdGVnb3J5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgZ2l2ZW4gY2F0ZWdvcmllcyB0byB0aGUgc2V0IG9mIGNhdGVnb3JpZXMgb2YgdGhpcyBDYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7U2V0PHN0cmluZz59IGNhdGVnb3JpZXMgLSBUaGUgY2F0ZWdvcmllcyBnaXZlbi4gXHJcbiAgICAgKi9cclxuICAgIGFkZENhdGVnb3JpZXMoY2F0ZWdvcmllcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgY2F0ZWdvcmllcy5rZXlzKCkpXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2F0ZWdvcnkoY2F0ZWdvcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2V0IG9mIGNhdGVnb3JpZXMgZm9yIHRoaXMgQ2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7U2V0PHN0cmluZz59IC0gdGhlIHNldCBvZiBjYXRlZ29yaWVzIGZvciB0aGlzIENhdGVnb3JpY2FsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENhdGVnb3JpY2FsVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2F0ZWdvcmllcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNhdGVnb3JpZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgY2F0ZWdvcmllcyBmb3IgdGhpcyBjYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldE51bUNhdGVnb3JpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F0ZWdvcmllcy5zaXplICE9PSAwID8gdGhpcy5jYXRlZ29yaWVzLnNpemUgOiB0aGlzLmdldFZpc3VhbFZhcmlhYmxlTWFwcGluZygpLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIHdoZW4gYWxsIGNhdGVnb3JpZXMgYXJlIG9uIHRoZSBTZXQuIFxyXG4gICAgICogVXNlZCB3aGVuIHRoZSBjYXRlZ29yaWVzIHdlcmVuJ3QgZ2l2ZW4gYnkgdGhlIHByb2dyYW1tZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2F0ZWdvcmljYWxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDYXRlZ29yaWNhbEluZm9ybWF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudmFsdWVUb0luZGV4TWFwID0gdGhpcy5fY3JlYXRlQ2F0ZWdvcmljYWxWYXJNYXAodGhpcy5jYXRlZ29yaWVzLmtleXMoKSk7XHJcblxyXG4gICAgICAgIGxldCBjYXRlZ29yaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNhdGVnb3JpZXMpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy52YWx1ZVRvSW5kZXhNYXAuc2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVUb0luZGV4TWFwLnNpemUgPCAyKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGBPbmx5IG9uZSBjYXRlZ29yeSAoJHtBcnJheS5mcm9tKHRoaXMudmFsdWVUb0luZGV4TWFwLmtleXMoKSl9KSBpbiB0aGUgZGF0YXNldC4gYCk7XHJcbiAgICAgICAgbGV0IGNvbG9ycyA9IHRoaXMuZ2lzcGxheU1hcC5nZXREZWZhdWx0Q29sb3JzKHRoaXMudmFsdWVUb0luZGV4TWFwLnNpemUsIEdpc3BsYXlEZWZhdWx0cy5RVUFMSVRBVElWRSgpKTtcclxuICAgICAgICBmb3IgKGxldCBbaSwgY2F0ZWdvcnldIG9mIGNhdGVnb3JpZXMuZW50cmllcygpKVxyXG4gICAgICAgICAgICB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZy5zZXQoY2F0ZWdvcnksIGNvbG9yc1tpXSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NldEluZGV4VG9Vc2FibGVWYWx1ZU1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtYXAgdmFyaWFibGUgcmVxdWlyZXMgaXQncyBjbGFzc2VzIHRvIGJlIGNhbGN1bGF0ZWQgb3Igbm90LiBDYXRlZ29yaWNhbCB2YXJpYWJsZXMgYWx3YXlzIHJldHVybiBmYWxzZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIENhdGVnb3JpY2FsVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY2xhc3NDYWxjdWxhdGlvblJlcXVpcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZEJvb2w7IC8vIHRoZSBtYXAgaGFzIG5vIEstPlYgcGFpcnNcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9WVnMvQ2F0ZWdvcmljYWxWYXJpYWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQTFCQTtBQTJCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQXBDQTtBQXNDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFQQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/VVs/MapVariable.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MapVariable = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable2 = __webpack_require__(/*! ./DataVariable */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents a Map Variable.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @see http://leg.ufpr.br/~silvia/CE055/node8.html\r\n * @export\r\n * @class MapVariable\r\n */\nvar MapVariable = exports.MapVariable = function (_DataVariable) {\n    _inherits(MapVariable, _DataVariable);\n\n    /**\r\n     * Creates an instance of MapVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>|Map<string, string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @memberof MapVariable\r\n     */\n    function MapVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping) {\n        _classCallCheck(this, MapVariable);\n\n        /**\r\n         * The type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n         * @type {string}\r\n         */\n        var _this = _possibleConstructorReturn(this, (MapVariable.__proto__ || Object.getPrototypeOf(MapVariable)).call(this, externalName, internalName));\n\n        _this.typeOfVisualVariable = typeOfVisualVariable;\n        /**\r\n         * The access qualifier for the shader variable.\r\n         * @type {string}\r\n         */\n        _this.shaderQualifier = shaderVariableQualifier;\n        /**\r\n         * The shader qualifier is of type attribute or not.\r\n         * @type {boolean} \r\n         */\n        _this.qualifierIsAttributeBool = shaderVariableQualifier === 'attribute';\n        /**\r\n         * The mapping between the values and the type of visual variable availabe values.\r\n         * E.g. 'THEFT' => 'triangle'\r\n         * @type {Map<string, string>|Array<string|number>}\r\n         */\n        _this.visualVariableMapping = visualVariableMapping;\n        /**\r\n         * The mapping between each class/category index and it's visual variable usable value.\r\n         * Possible keys: 0 .... n-1\r\n         * Possible values: 1) Array of numbers for color\r\n         *                  2) Index number for shapes and textures\r\n         *                  3) Number for size and orientation\r\n         * E.g. 'THEFT' => 'triangle' => 8 (8 is the index of the triangle in the shapes map)\r\n         *      'NO THEFT' => 'square' => 4\r\n         * Then we would have Map( 0 -> 8, 1 -> 4)\r\n         * @type {Map<number,Array<number>|number>}\r\n         */\n        _this.indexToUsableValueMap = new Map();\n        return _this;\n    }\n\n    /**\r\n     * Returns the type of visual variable (e.g. color, shape, size, orientation or texture) that this map variable will be mapped to.\r\n     * @returns {string} - the type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n     * @memberof MapVariable\r\n     */\n\n\n    _createClass(MapVariable, [{\n        key: 'getTypeOfVisualVariable',\n        value: function getTypeOfVisualVariable() {\n            return this.typeOfVisualVariable;\n        }\n\n        /**\r\n         * Returns the mapping for the type of visual variable. \r\n         * It can be a Object<Key, Value> if it's categorical, an array of strings or array of numbers. \r\n         * @returns {Map<string, string>|Array<string|number>} - the mappings for this visual variable.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'getVisualVariableMapping',\n        value: function getVisualVariableMapping() {\n            return this.visualVariableMapping;\n            //Array number (Cont no size e orientation)\n            //Array string (Cont para color, size e orientation + Cat para color)\n            //Object K->V (Cat para shape, texture e orientation)\n        }\n\n        /**\r\n         * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n         * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return false;\n        }\n\n        /**\r\n         * Returns the mapping between each class/category and it's visual variable usable value.\r\n         * @returns {Map<number,Array<number>|number>} - the mapping between each class/category and it's visual variable usable value.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'getIndexToUSableValueMap',\n        value: function getIndexToUSableValueMap() {\n            return this.indexToUsableValueMap;\n        }\n\n        /**\r\n         * The value associated with the given index.\r\n         * E.g. [255,0,0] for color or 57 for size/orientation or 3 for shape/texture.\r\n         * @param {number} index - The index of the visual variable.\r\n         * @returns {Array<number>|number>}\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'findUsableValue',\n        value: function findUsableValue(index) {\n            return this.indexToUsableValueMap.get(index);\n        }\n\n        /**\r\n         * The access qualifier for the shader variable \r\n         * @returns {string} - the access qualifier for the shader variable \r\n         * @memberOf MapVariable\r\n         */\n\n    }, {\n        key: 'getShaderVariableQualifier',\n        value: function getShaderVariableQualifier() {\n            return this.shaderQualifier;\n        }\n\n        /**\r\n         * Returns true if the shader qualifier is equal to attribute, false, otherwise.\r\n         * @returns {boolean} - true if the shader qualifier is equal to attribute, false, otherwise.\r\n         * @memberOf MapVariable\r\n         */\n\n    }, {\n        key: 'qualifierIsAttribute',\n        value: function qualifierIsAttribute() {\n            return this.qualifierIsAttributeBool;\n        }\n    }]);\n\n    return MapVariable;\n}(_DataVariable2.DataVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvTWFwVmFyaWFibGUuanM/MzQ4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVmFyaWFibGUgfSBmcm9tICcuL0RhdGFWYXJpYWJsZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBNYXAgVmFyaWFibGUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQHNlZSBodHRwOi8vbGVnLnVmcHIuYnIvfnNpbHZpYS9DRTA1NS9ub2RlOC5odG1sXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIE1hcFZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWFwVmFyaWFibGUgZXh0ZW5kcyBEYXRhVmFyaWFibGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlT2ZWaXN1YWxWYXJpYWJsZSAtIFRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyIC0gVGhlIHNoYWRlciB2YXJpYWJsZSBxdWFsaWZpZXIuIFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPnxNYXA8c3RyaW5nLCBzdHJpbmd8bnVtYmVyPn0gdmlzdWFsVmFyaWFibGVNYXBwaW5nIC0gVGhlIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSwgdHlwZU9mVmlzdWFsVmFyaWFibGUsIHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyLCB2aXN1YWxWYXJpYWJsZU1hcHBpbmcpIHtcclxuICAgICAgICBzdXBlcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdmlzdWFsIHZhcmlhYmxlIG1hcHBpbmcgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZU9mVmlzdWFsVmFyaWFibGUgPSB0eXBlT2ZWaXN1YWxWYXJpYWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYWNjZXNzIHF1YWxpZmllciBmb3IgdGhlIHNoYWRlciB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hhZGVyUXVhbGlmaWVyID0gc2hhZGVyVmFyaWFibGVRdWFsaWZpZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYWRlciBxdWFsaWZpZXIgaXMgb2YgdHlwZSBhdHRyaWJ1dGUgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1YWxpZmllcklzQXR0cmlidXRlQm9vbCA9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyID09PSAnYXR0cmlidXRlJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFwcGluZyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYW5kIHRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSBhdmFpbGFiZSB2YWx1ZXMuXHJcbiAgICAgICAgICogRS5nLiAnVEhFRlQnID0+ICd0cmlhbmdsZSdcclxuICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPnxBcnJheTxzdHJpbmd8bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZyA9IHZpc3VhbFZhcmlhYmxlTWFwcGluZztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFwcGluZyBiZXR3ZWVuIGVhY2ggY2xhc3MvY2F0ZWdvcnkgaW5kZXggYW5kIGl0J3MgdmlzdWFsIHZhcmlhYmxlIHVzYWJsZSB2YWx1ZS5cclxuICAgICAgICAgKiBQb3NzaWJsZSBrZXlzOiAwIC4uLi4gbi0xXHJcbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzOiAxKSBBcnJheSBvZiBudW1iZXJzIGZvciBjb2xvclxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgMikgSW5kZXggbnVtYmVyIGZvciBzaGFwZXMgYW5kIHRleHR1cmVzXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAzKSBOdW1iZXIgZm9yIHNpemUgYW5kIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICogRS5nLiAnVEhFRlQnID0+ICd0cmlhbmdsZScgPT4gOCAoOCBpcyB0aGUgaW5kZXggb2YgdGhlIHRyaWFuZ2xlIGluIHRoZSBzaGFwZXMgbWFwKVxyXG4gICAgICAgICAqICAgICAgJ05PIFRIRUZUJyA9PiAnc3F1YXJlJyA9PiA0XHJcbiAgICAgICAgICogVGhlbiB3ZSB3b3VsZCBoYXZlIE1hcCggMCAtPiA4LCAxIC0+IDQpXHJcbiAgICAgICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8bnVtYmVyPnxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB2aXN1YWwgdmFyaWFibGUgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKSB0aGF0IHRoaXMgbWFwIHZhcmlhYmxlIHdpbGwgYmUgbWFwcGVkIHRvLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgdHlwZSBvZiB2aXN1YWwgdmFyaWFibGUgbWFwcGluZyAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFR5cGVPZlZpc3VhbFZhcmlhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVPZlZpc3VhbFZhcmlhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFwcGluZyBmb3IgdGhlIHR5cGUgb2YgdmlzdWFsIHZhcmlhYmxlLiBcclxuICAgICAqIEl0IGNhbiBiZSBhIE9iamVjdDxLZXksIFZhbHVlPiBpZiBpdCdzIGNhdGVnb3JpY2FsLCBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFycmF5IG9mIG51bWJlcnMuIFxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz58QXJyYXk8c3RyaW5nfG51bWJlcj59IC0gdGhlIG1hcHBpbmdzIGZvciB0aGlzIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRWaXN1YWxWYXJpYWJsZU1hcHBpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nO1xyXG4gICAgICAgIC8vQXJyYXkgbnVtYmVyIChDb250IG5vIHNpemUgZSBvcmllbnRhdGlvbilcclxuICAgICAgICAvL0FycmF5IHN0cmluZyAoQ29udCBwYXJhIGNvbG9yLCBzaXplIGUgb3JpZW50YXRpb24gKyBDYXQgcGFyYSBjb2xvcilcclxuICAgICAgICAvL09iamVjdCBLLT5WIChDYXQgcGFyYSBzaGFwZSwgdGV4dHVyZSBlIG9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtYXAgdmFyaWFibGUgcmVxdWlyZXMgaXQncyBjbGFzc2VzIHRvIGJlIGNhbGN1bGF0ZWQgb3Igbm90LiBDYXRlZ29yaWNhbCB2YXJpYWJsZXMgYWx3YXlzIHJldHVybiBmYWxzZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXBwaW5nIGJldHdlZW4gZWFjaCBjbGFzcy9jYXRlZ29yeSBhbmQgaXQncyB2aXN1YWwgdmFyaWFibGUgdXNhYmxlIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge01hcDxudW1iZXIsQXJyYXk8bnVtYmVyPnxudW1iZXI+fSAtIHRoZSBtYXBwaW5nIGJldHdlZW4gZWFjaCBjbGFzcy9jYXRlZ29yeSBhbmQgaXQncyB2aXN1YWwgdmFyaWFibGUgdXNhYmxlIHZhbHVlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4VG9VU2FibGVWYWx1ZU1hcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAqIEUuZy4gWzI1NSwwLDBdIGZvciBjb2xvciBvciA1NyBmb3Igc2l6ZS9vcmllbnRhdGlvbiBvciAzIGZvciBzaGFwZS90ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPnxudW1iZXI+fVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRVc2FibGVWYWx1ZShpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4VG9Vc2FibGVWYWx1ZU1hcC5nZXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFjY2VzcyBxdWFsaWZpZXIgZm9yIHRoZSBzaGFkZXIgdmFyaWFibGUgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBhY2Nlc3MgcXVhbGlmaWVyIGZvciB0aGUgc2hhZGVyIHZhcmlhYmxlIFxyXG4gICAgICogQG1lbWJlck9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFNoYWRlclZhcmlhYmxlUXVhbGlmaWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlclF1YWxpZmllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2hhZGVyIHF1YWxpZmllciBpcyBlcXVhbCB0byBhdHRyaWJ1dGUsIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzaGFkZXIgcXVhbGlmaWVyIGlzIGVxdWFsIHRvIGF0dHJpYnV0ZSwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJPZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBxdWFsaWZpZXJJc0F0dHJpYnV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWFsaWZpZXJJc0F0dHJpYnV0ZUJvb2w7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL01hcFZhcmlhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTs7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBRkE7QUFDQTtBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBbENBO0FBbUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/* no static exports found */
/* all exports used */
/*!***********************************************!*\
  !*** ./src/Gisplay/VVs/ContinuousVariable.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ContinuousVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapVariable2 = __webpack_require__(/*! ./MapVariable */ 4);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nvar _GisplayError = __webpack_require__(/*! ../GisplayError */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents a continuous variable.\r\n * Continous data, is data where the values can change continuously, and you cannot count the number of different values (e.g. weight, price, profits, counts, etc). \r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class ContinuousVariable\r\n */\nvar ContinuousVariable = exports.ContinuousVariable = function (_MapVariable) {\n    _inherits(ContinuousVariable, _MapVariable);\n\n    /**\r\n     * Creates an instance of ContinuousVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @param {Array<number>} classBreaks - The classes for this map variable.\r\n     * @param {string} numberOfClasses - The number of classes for this continuous variable.\r\n     * @param {string} classBreakMethod - The class breaks method to be used.\r\n     * @param {Array<number|string>} classBreakMethodParams - The parameters for the class break method.\r\n     * @memberof ContinuousVariable\r\n     */\n    function ContinuousVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, classBreaks, numberOfClasses, classBreakMethod, classBreakMethodParams) {\n        _classCallCheck(this, ContinuousVariable);\n\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<number>}\r\n         */\n        var _this = _possibleConstructorReturn(this, (ContinuousVariable.__proto__ || Object.getPrototypeOf(ContinuousVariable)).call(this, externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping));\n\n        _this.classBreaks = classBreaks;\n        /**\r\n         * The number of classes for the map variable.\r\n         * @type {number}\r\n         */\n        _this.numberOfClasses = visualVariableMapping ? visualVariableMapping.length : numberOfClasses;\n        /**\r\n         * The method to use to calculate classes for the map variable.\r\n         * @type {string}\r\n         */\n        _this.classBreakMethod = classBreakMethod;\n        /**\r\n         * Returns the array of params for the class break method.\r\n         *  @type{Array<number|string>} \r\n         */\n        _this.classBreakMethodParams = classBreakMethodParams;\n\n        /**\r\n         * Number of bins. This value is hardcoded to 100. But it should work even if changed to another integer value.\r\n         * @type {number}\r\n         */\n        _this.numBins = 100;\n        /**\r\n         * The minimum value.\r\n         * @type {number}\r\n         */\n        _this.min = Number.MAX_SAFE_INTEGER - 1;\n        /**\r\n         * The maximum value.\r\n         * @type {number}\r\n         */\n        _this.max = Number.MIN_SAFE_INTEGER + 1;\n\n        _this.newMin = Number.MAX_SAFE_INTEGER;\n        _this.newMax = Number.MIN_SAFE_INTEGER;\n\n        /**\r\n         * Amount between any two bins.\r\n         * @type {number}\r\n         */\n        _this.step = -1;\n        /**\r\n         * The bin limits.\r\n         * @type {Array<number>}\r\n         */\n        _this.bins = new Array(100).fill(-1);\n        /**\r\n         * Histogram with number of values by bin interval. \r\n         * @type {Array<number>}\r\n         */\n        _this.histogram = new Array(100).fill(0); //Array with 100 elements each filled with the value 0\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<Array<number>>}\r\n         */\n        _this.classIntervals;\n\n        if (_this.classBreaks) {\n            _this.min = _this.classBreaks[0];\n            _this.max = _this.classBreaks[_this.classBreaks.length - 1];\n            _this.step = (_this.getMax() - _this.getMin()) / _this.numBins;\n\n            _this.bins = _this.buildBinIntervals();\n            _this.classIntervals = _this.calculateClassIntervals(_this.classBreaks);\n        }\n        if (_this.getVisualVariableMapping()) _this._setIndexToUsableValueMap();\n\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\n        _this.classCalculationRequiredBool = _this.classBreaks === undefined;\n        console.log(_this);\n        return _this;\n    }\n\n    /**\r\n     * Returns the method to be used to calculate the classes for this map variable.\r\n     * @returns {string} - the method to be used to calculate the classes for this variable.\r\n     * @memberof ContinuousVariable\r\n     */\n\n\n    _createClass(ContinuousVariable, [{\n        key: 'getClassBreakMethod',\n        value: function getClassBreakMethod() {\n            return this.classBreakMethod;\n        }\n\n        /**\r\n         * Returns the class intervals for this map variable.\r\n         * @returns {Array<number>} - the class intervals for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getClassBreaks',\n        value: function getClassBreaks() {\n            return this.classBreaks;\n        }\n\n        /**\r\n         * Sets the class breaks to the calculated class breaks.\r\n         * @param {Array<number>} calculatedClassBreaks - The array of class intervals for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setClassBreaks',\n        value: function setClassBreaks(calculatedClassBreaks) {\n            this.classBreaks = calculatedClassBreaks;\n        }\n\n        /**\r\n         * Returns true, if the class breaks weren't given by the programmer for the map variable, false, otherwise. \r\n         * @returns {boolean} - true, if the class breaks weren't given by the programmer for the visual variable, false, otherwise.  \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return this.classCalculationRequiredBool;\n        }\n\n        /**\r\n         * Calculates class intervals for this variable.\r\n         * @param {Array<number>} classBreaks - The class breaks given by the programmer. \r\n         * @returns {Array<Array<number>>} - the start and end for each class of this variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'calculateClassIntervals',\n        value: function calculateClassIntervals(classBreaks) {\n            console.error(\"classBreaks = \", classBreaks, this);\n            var res = [];\n\n            /*     \r\n                [min, a[, [a, b[, [b,c[, [c,max] -> caso em que o min dos dados é !== do a\r\n                min - todos os valore menores que a\r\n                [a,b,c] ->  [min, a[, [a, b[, [b,c[, [c,max] \r\n                Se min for == a então n cabe \r\n                >= a && < a \r\n                  1º intervalos todos os inferiores a \"a\"\r\n                o ultimo intervalo é todos os >= a c \r\n            */\n            for (var i = 0; i < classBreaks.length - 1; i++) {\n                res.push([classBreaks[i], classBreaks[i + 1]]);\n            } /*   if (this.classBreaks !== undefined) {\r\n                    res.push([this.min, classBreaks[0]]);\r\n                    for (let i = 0; i < classBreaks.length - 1; i++)\r\n                        res.push([classBreaks[i], classBreaks[i + 1]]);\r\n                    res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n                } else {\r\n                    // res.push([this.min, classBreaks[0]]);\r\n                    for (let i = 0; i < classBreaks.length - 1; i++)\r\n                        res.push([classBreaks[i], classBreaks[i + 1]]);\r\n                    // res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n                } */\n            return res;\n            // return null;\n        }\n\n        /**\r\n         * Returns the class intervals for this class.\r\n         * @returns {Array<Array<number>>} - the class intervals for this class. \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getClassIntervals',\n        value: function getClassIntervals() {\n            return this.classIntervals;\n        }\n\n        /**\r\n         * Find the class index of the given value.\r\n         * It's inside a class if it's value is equal or higher than the starting point and less than the end point.\r\n         * @param {number} value - The value of the element.\r\n         * @returns {number} - The  index of the class.\r\n         * @memberof Parser\r\n         */\n\n    }, {\n        key: 'findClassIntervalIndex',\n        value: function findClassIntervalIndex(value) {\n            var classIntervals = this.getClassIntervals();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = classIntervals.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _step$value = _slicedToArray(_step.value, 2),\n                        index = _step$value[0],\n                        classInterval = _step$value[1];\n\n                    if (value >= classInterval[0] && value < classInterval[1]) return index;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            if (value < classIntervals[0][0]) return 0;\n            return classIntervals.length - 1;\n        }\n\n        /**\r\n         * Set the min and max values if the given value changes them.\r\n         * @param {number} value - The given vaue. \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setMinMax',\n        value: function setMinMax(value) {\n            if (value < this.min) this.min = value;\n            if (value > this.max) this.max = value;\n            /* if (value < this.newMin)\r\n                this.newMin = value;\r\n            if (value > this.newMax)\r\n                this.newMax = value; */\n        }\n\n        /*\r\n        #####################################################################\r\n        ######################     CLASS CALCULATION      ###################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the minimum value for the visual variable.\r\n         * @returns {number} - the minimum value for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getMin',\n        value: function getMin() {\n            return this.min;\n        }\n\n        /**\r\n         * Returns the maximum value for the visual variable.\r\n         * @returns {number} -  the maximum value for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getMax',\n        value: function getMax() {\n            return this.max;\n        }\n\n        /**\r\n         * Update the step vaue.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setStep',\n        value: function setStep() {\n            this.step = (this.getMax() - this.getMin()) / this.numBins;\n        }\n\n        /**\r\n         * Returns the step between each bin value.\r\n         * @returns {number} - the step between each bin value.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getStep',\n        value: function getStep() {\n            return this.step;\n        }\n\n        /**\r\n         * Returns the histogram for this continuous variable.\r\n         * @returns {Array<number>} - the histogram for this continuous variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getHistogram',\n        value: function getHistogram() {\n            return this.histogram;\n        }\n\n        /**\r\n         * Updates the histogram of this continuous variable with the histogram values\r\n         * @param {Array<number>} histogram - The given histogram\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'updateHistogram',\n        value: function updateHistogram(histogram) {\n            for (var i = 0; i < histogram.length; i++) {\n                this.histogram[i] += histogram[i];\n            }\n        }\n\n        /**\r\n         * Return the number of classes.\r\n         * @returns {numer} - the number of classes.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getNumberOfClasses',\n        value: function getNumberOfClasses() {\n            return this.numberOfClasses;\n        }\n\n        /**\r\n         * Create 100 bins with equal intervals between the minimum and maximum value.\r\n         * @param {number} min - The minimum for this continuous variable. \r\n         * @param {number} max - The maximum for this continuous variable.\r\n         * @returns {Array<number>} - The bins that will be used to calculate the classes.\r\n         * @memberof LegendClasses\r\n         */\n\n    }, {\n        key: 'buildBinIntervals',\n        value: function buildBinIntervals() {\n            // let step = (max - min) / this.numBins;\n            if (this.step === -1) this.setStep();\n            var resBins = [];\n            var min = this.min;\n            var max = this.max;\n            // resBins.push(min);\n            for (var i = min; i < max; i += this.step) {\n                resBins.push(i);\n            }if (Math.round(resBins[resBins.length - 1]) === max || max - resBins[resBins.length - 1] < 0.0001) //min = 0, max = 199.2 Math.round(199.19999999999976) = 199 <-- ERROR\n                resBins[resBins.length - 1] = max;else resBins.push(max);\n            return resBins;\n        }\n\n        /**\r\n         * Create the bins array with 101? values that represent the intervals.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'createBins',\n        value: function createBins() {\n            this.bins = this.buildBinIntervals();\n        }\n\n        /**\r\n         * Add the value to the respective bin index.\r\n         * This method works at O(1) instead of O(n), since it only needs to calculate the index and add one to it's bin.\r\n         * The alternative was to loop through all the bins and find where this value would fit.\r\n         * @param {number} value - The value to insert into one of the bins. \r\n         * @see http://prntscr.com/gdn1wu - Reason for if statement\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'addValueToBins',\n        value: function addValueToBins(value) {\n            var binIndex = Math.floor((value - this.min) / this.step);\n            if (value >= this.max) //The case it is equal to the max value then change index to the previous.\n                binIndex = this.numBins - 1;else if (value <= this.min) binIndex = 0;\n            this.histogram[binIndex]++;\n            // console.log(\"value\", value, \"binIndex\", binIndex);\n        }\n\n        /**\r\n         * Calculates the classes for the visual variable using the method specified by the programmer.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'calculateClasses',\n        value: function calculateClasses() {\n            //Usando os bins faz calculo de classes e alterar guardar nos classIntervals\n            var CBMETHODS = _GisplayDefaults.GisplayDefaults.getAvailableClassBreaksMethods();\n            switch (this.getClassBreakMethod()) {\n                case CBMETHODS.QUANTILES:\n                    this.classIntervals = this.calculateClassIntervals(this.quantiles());\n                    break;\n                case CBMETHODS.EQUAL_INTERVALS:\n                    // console.log('equalintervals');\n                    this.classIntervals = this.calculateClassIntervals(this.equalIntervals());\n                    break;\n                default:\n                    throw new _GisplayError.GisplayError('Continuous Variable: ' + this.getInternalName() + '. Given method for class calculation does not exist. ');\n            }\n\n            if (this.classIntervals.length !== this.numberOfClasses) throw new _GisplayError.GisplayError(\"The number of calculated class intervals is different from the number of classes\");\n        }\n\n        /**\r\n         * Calculate the intervals for each class using the quantiles method.\r\n         * @param {Array<number>} histogram - Histogram with quantity of values by bin interval. \r\n         * @param {number} binValues - The bin values between the minimum and the maximum.\r\n         * @param {number} numRows - Number of rows read from the file.\r\n         * @param {number} numClasses - Number of classes to calculate.\r\n         * @returns {Array<number>} -  The resulting classes using the quantiles method.\r\n         * @see https://en.wikipedia.org/wiki/Quantile\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'quantiles',\n        value: function quantiles() {\n            var numberOfClasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfClasses();\n\n            var numRows = 0;\n            for (var i = 0, length = this.histogram.length; i < length; i++) {\n                numRows += this.histogram[i];\n            }var numValsPerClass = numRows / numberOfClasses;\n            // console.log(numRows, this.getNumberOfClasses(), numValsPerClass);\n            var classes = [];\n            classes.push(this.bins[0]);\n            var sum = 0;\n            for (var _i = 0; _i < this.histogram.length - 1; _i++) {\n                sum += this.histogram[_i];\n                if (sum >= numValsPerClass) {\n                    classes.push(this.bins[_i + 1]);\n                    sum = 0;\n                }\n            }\n            classes.push(this.bins[this.bins.length - 1]);\n            // console.log(classes);\n            // console.log(this);\n            if (classes.length < numberOfClasses) console.warn('Quantiles method couldn\\'t create ' + numberOfClasses + ' classes, instead it created ' + (classes.length - 1) + ' classes. [' + classes + ']');else if (classes.length - 1 > numberOfClasses) throw new _GisplayError.GisplayError('Something went wrong with quantiles method. Number of classes calculated is: ' + (classes.length - 1) + ', the intended values was ' + this.getNumberOfClasses());\n            return classes;\n        }\n\n        /**\r\n         * Taking the calculated bins, this method will calculate the intervals for each class using the equal intervals method.\r\n         * @param {number} binValues - The bin values between the minimum and the maximum.\r\n         * @param {number} numClasses - Number of classes to calculate.\r\n         * @returns {Array<number>} - The resulting classes using the equal intervals method.\r\n         * @see http://wiki.gis.com/wiki/index.php/Equal_Interval_classification\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'equalIntervals',\n        value: function equalIntervals() {\n            var numberOfClasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfClasses();\n\n            var interval = Math.round((this.getMax() - this.getMin()) / numberOfClasses); //To give a integer (this.bins.length - 1) / this.numClasses;\n            // console.log(\"EquInt interval=\", interval);\n            // console.log(this.getMin(), this.getMax(), numberOfClasses);\n            var classes = [];\n            classes.push(this.bins[0]);\n            var currentValue = this.getMin(); // Current value\n            for (var i = 0; i < numberOfClasses - 1; i++) {\n                currentValue += interval;\n                classes.push(this._findBin(currentValue));\n            }\n            classes.push(this.bins[this.bins.length - 1]);\n\n            // console.log(\"equalIntervals = \", classes);\n            return classes;\n        }\n\n        /**\r\n         * Find the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first.\r\n         * @param {number} value - The value used to find the correct bin. \r\n         * @returns {number} - the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first. \r\n         * @private \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: '_findBin',\n        value: function _findBin(value) {\n            for (var i = 0; i < this.bins.length - 1; i++) {\n                var val1 = this.bins[i];\n                var val2 = this.bins[i + 1];\n                if (value >= val1 && value < val2) {\n                    var distToVal1 = value - val1;\n                    var distToVal2 = val2 - value;\n                    if (distToVal1 <= distToVal2) return val1;\n                    return val2;\n                }\n            }\n        }\n\n        /**\r\n         * Set each index (of each class) to it's respective value (color array, size or orientation value).\r\n         * E.g. 0 -> [255, 0, 0], 1 -> [0, 128, 0] etc\r\n         * @private\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: '_setIndexToUsableValueMap',\n        value: function _setIndexToUsableValueMap() {\n            var VVS = _GisplayDefaults.GisplayDefaults.getAvailableVisualVariables();\n            var typeOfVisualVariable = this.getTypeOfVisualVariable();\n            switch (typeOfVisualVariable) {\n                case VVS.COLOR:\n                case VVS.SIZE:\n                case VVS.ORIENTATION:\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = this.getVisualVariableMapping().entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _step2$value = _slicedToArray(_step2.value, 2),\n                                index = _step2$value[0],\n                                vvMapping = _step2$value[1];\n\n                            this.indexToUsableValueMap.set(index, vvMapping);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n\n                    break;\n                case VVS.SHAPE:\n                case VVS.TEXTURE:\n                    throw new _GisplayError.GisplayError(typeOfVisualVariable + ' shouldn\\'t be used with a continuous variable.');\n            }\n            // console.log(\"CONT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\n        }\n    }]);\n\n    return ContinuousVariable;\n}(_MapVariable2.MapVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvQ29udGludW91c1ZhcmlhYmxlLmpzP2E0MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwVmFyaWFibGUgfSBmcm9tICcuL01hcFZhcmlhYmxlJztcclxuaW1wb3J0IHsgR2lzcGxheURlZmF1bHRzIH0gZnJvbSAnLi4vR2lzcGxheURlZmF1bHRzJztcclxuaW1wb3J0IHsgR2lzcGxheUVycm9yIH0gZnJvbSAnLi4vR2lzcGxheUVycm9yJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29udGludW91cyB2YXJpYWJsZS5cclxuICogQ29udGlub3VzIGRhdGEsIGlzIGRhdGEgd2hlcmUgdGhlIHZhbHVlcyBjYW4gY2hhbmdlIGNvbnRpbnVvdXNseSwgYW5kIHlvdSBjYW5ub3QgY291bnQgdGhlIG51bWJlciBvZiBkaWZmZXJlbnQgdmFsdWVzIChlLmcuIHdlaWdodCwgcHJpY2UsIHByb2ZpdHMsIGNvdW50cywgZXRjKS4gXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQ29udGludW91c1ZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29udGludW91c1ZhcmlhYmxlIGV4dGVuZHMgTWFwVmFyaWFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbnRpbnVvdXNWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlT2ZWaXN1YWxWYXJpYWJsZSAtIFRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyIC0gVGhlIHNoYWRlciB2YXJpYWJsZSBxdWFsaWZpZXIuIFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gdmlzdWFsVmFyaWFibGVNYXBwaW5nIC0gVGhlIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xhc3NCcmVha3MgLSBUaGUgY2xhc3NlcyBmb3IgdGhpcyBtYXAgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyT2ZDbGFzc2VzIC0gVGhlIG51bWJlciBvZiBjbGFzc2VzIGZvciB0aGlzIGNvbnRpbnVvdXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NCcmVha01ldGhvZCAtIFRoZSBjbGFzcyBicmVha3MgbWV0aG9kIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcnxzdHJpbmc+fSBjbGFzc0JyZWFrTWV0aG9kUGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjbGFzcyBicmVhayBtZXRob2QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZywgY2xhc3NCcmVha3MsIG51bWJlck9mQ2xhc3NlcywgY2xhc3NCcmVha01ldGhvZCwgY2xhc3NCcmVha01ldGhvZFBhcmFtcykge1xyXG4gICAgICAgIHN1cGVyKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIG1hcCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtzID0gY2xhc3NCcmVha3M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgbWFwIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkNsYXNzZXMgPSB2aXN1YWxWYXJpYWJsZU1hcHBpbmcgPyB2aXN1YWxWYXJpYWJsZU1hcHBpbmcubGVuZ3RoIDogbnVtYmVyT2ZDbGFzc2VzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIGNhbGN1bGF0ZSBjbGFzc2VzIGZvciB0aGUgbWFwIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFzc0JyZWFrTWV0aG9kID0gY2xhc3NCcmVha01ldGhvZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJhbXMgZm9yIHRoZSBjbGFzcyBicmVhayBtZXRob2QuXHJcbiAgICAgICAgICogIEB0eXBle0FycmF5PG51bWJlcnxzdHJpbmc+fSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtNZXRob2RQYXJhbXMgPSBjbGFzc0JyZWFrTWV0aG9kUGFyYW1zO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgYmlucy4gVGhpcyB2YWx1ZSBpcyBoYXJkY29kZWQgdG8gMTAwLiBCdXQgaXQgc2hvdWxkIHdvcmsgZXZlbiBpZiBjaGFuZ2VkIHRvIGFub3RoZXIgaW50ZWdlciB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubnVtQmlucyA9IDEwMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDE7XHJcblxyXG4gICAgICAgIHRoaXMubmV3TWluID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgdGhpcy5uZXdNYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW1vdW50IGJldHdlZW4gYW55IHR3byBiaW5zLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGVwID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJpbiBsaW1pdHMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iaW5zID0gbmV3IEFycmF5KDEwMCkuZmlsbCgtMSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGlzdG9ncmFtIHdpdGggbnVtYmVyIG9mIHZhbHVlcyBieSBiaW4gaW50ZXJ2YWwuIFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGlzdG9ncmFtID0gbmV3IEFycmF5KDEwMCkuZmlsbCgwKTsgLy9BcnJheSB3aXRoIDEwMCBlbGVtZW50cyBlYWNoIGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSAwXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIG1hcCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFzc0ludGVydmFscztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NCcmVha3MpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSB0aGlzLmNsYXNzQnJlYWtzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMuY2xhc3NCcmVha3NbdGhpcy5jbGFzc0JyZWFrcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdGhpcy5zdGVwID0gKHRoaXMuZ2V0TWF4KCkgLSB0aGlzLmdldE1pbigpKSAvICh0aGlzLm51bUJpbnMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iaW5zID0gdGhpcy5idWlsZEJpbkludGVydmFscygpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzSW50ZXJ2YWxzID0gdGhpcy5jYWxjdWxhdGVDbGFzc0ludGVydmFscyh0aGlzLmNsYXNzQnJlYWtzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0VmlzdWFsVmFyaWFibGVNYXBwaW5nKCkpXHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluZGV4VG9Vc2FibGVWYWx1ZU1hcCgpO1xyXG5cclxuICAgICAgICAvKiogIFxyXG4gICAgICAgICAqIEJvb2xlYW4gdGhhdCBzdG9yZXMgdHJ1ZSBpZiBjbGFzcyBjYWxjdXRhdGlvbiBpcyByZXF1aXJlZCwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZEJvb2wgPSB0aGlzLmNsYXNzQnJlYWtzID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRob2QgdG8gYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGNsYXNzZXMgZm9yIHRoaXMgbWFwIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbWV0aG9kIHRvIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzIGZvciB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRDbGFzc0JyZWFrTWV0aG9kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzQnJlYWtNZXRob2Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgbWFwIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gdGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2xhc3NCcmVha3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NCcmVha3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjbGFzcyBicmVha3MgdG8gdGhlIGNhbGN1bGF0ZWQgY2xhc3MgYnJlYWtzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjYWxjdWxhdGVkQ2xhc3NCcmVha3MgLSBUaGUgYXJyYXkgb2YgY2xhc3MgaW50ZXJ2YWxzIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBzZXRDbGFzc0JyZWFrcyhjYWxjdWxhdGVkQ2xhc3NCcmVha3MpIHtcclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtzID0gY2FsY3VsYXRlZENsYXNzQnJlYWtzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlLCBpZiB0aGUgY2xhc3MgYnJlYWtzIHdlcmVuJ3QgZ2l2ZW4gYnkgdGhlIHByb2dyYW1tZXIgZm9yIHRoZSBtYXAgdmFyaWFibGUsIGZhbHNlLCBvdGhlcndpc2UuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwgaWYgdGhlIGNsYXNzIGJyZWFrcyB3ZXJlbid0IGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLCBmYWxzZSwgb3RoZXJ3aXNlLiAgXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0NhbGN1bGF0aW9uUmVxdWlyZWRCb29sO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsYXNzQnJlYWtzIC0gVGhlIGNsYXNzIGJyZWFrcyBnaXZlbiBieSB0aGUgcHJvZ3JhbW1lci4gXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IC0gdGhlIHN0YXJ0IGFuZCBlbmQgZm9yIGVhY2ggY2xhc3Mgb2YgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQ2xhc3NJbnRlcnZhbHMoY2xhc3NCcmVha3MpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiY2xhc3NCcmVha3MgPSBcIiwgY2xhc3NCcmVha3MsIHRoaXMpXHJcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xyXG5cclxuICAgICAgICAvKiAgICAgXHJcbiAgICAgICAgICAgIFttaW4sIGFbLCBbYSwgYlssIFtiLGNbLCBbYyxtYXhdIC0+IGNhc28gZW0gcXVlIG8gbWluIGRvcyBkYWRvcyDDqSAhPT0gZG8gYVxyXG4gICAgICAgICAgICBtaW4gLSB0b2RvcyBvcyB2YWxvcmUgbWVub3JlcyBxdWUgYVxyXG4gICAgICAgICAgICBbYSxiLGNdIC0+ICBbbWluLCBhWywgW2EsIGJbLCBbYixjWywgW2MsbWF4XSBcclxuICAgICAgICAgICAgU2UgbWluIGZvciA9PSBhIGVudMOjbyBuIGNhYmUgXHJcbiAgICAgICAgICAgID49IGEgJiYgPCBhIFxyXG5cclxuICAgICAgICAgICAgMcK6IGludGVydmFsb3MgdG9kb3Mgb3MgaW5mZXJpb3JlcyBhIFwiYVwiXHJcbiAgICAgICAgICAgIG8gdWx0aW1vIGludGVydmFsbyDDqSB0b2RvcyBvcyA+PSBhIGMgXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzQnJlYWtzLmxlbmd0aCAtIDE7IGkrKylcclxuICAgICAgICAgICAgcmVzLnB1c2goW2NsYXNzQnJlYWtzW2ldLCBjbGFzc0JyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAvKiAgIGlmICh0aGlzLmNsYXNzQnJlYWtzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICByZXMucHVzaChbdGhpcy5taW4sIGNsYXNzQnJlYWtzWzBdXSk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0JyZWFrcy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtjbGFzc0JyZWFrc1tpXSwgY2xhc3NCcmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgcmVzLnB1c2goW2NsYXNzQnJlYWtzW2NsYXNzQnJlYWtzLmxlbmd0aCAtIDFdLCB0aGlzLm1heF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyByZXMucHVzaChbdGhpcy5taW4sIGNsYXNzQnJlYWtzWzBdXSk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0JyZWFrcy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtjbGFzc0JyZWFrc1tpXSwgY2xhc3NCcmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgLy8gcmVzLnB1c2goW2NsYXNzQnJlYWtzW2NsYXNzQnJlYWtzLmxlbmd0aCAtIDFdLCB0aGlzLm1heF0pO1xyXG4gICAgICAgICAgfSAqL1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgLy8gcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgY2xhc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IC0gdGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhpcyBjbGFzcy4gXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldENsYXNzSW50ZXJ2YWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzSW50ZXJ2YWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgY2xhc3MgaW5kZXggb2YgdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICogSXQncyBpbnNpZGUgYSBjbGFzcyBpZiBpdCdzIHZhbHVlIGlzIGVxdWFsIG9yIGhpZ2hlciB0aGFuIHRoZSBzdGFydGluZyBwb2ludCBhbmQgbGVzcyB0aGFuIHRoZSBlbmQgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSAgaW5kZXggb2YgdGhlIGNsYXNzLlxyXG4gICAgICogQG1lbWJlcm9mIFBhcnNlclxyXG4gICAgICovXHJcbiAgICBmaW5kQ2xhc3NJbnRlcnZhbEluZGV4KHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzSW50ZXJ2YWxzID0gdGhpcy5nZXRDbGFzc0ludGVydmFscygpO1xyXG4gICAgICAgIGZvciAobGV0IFtpbmRleCwgY2xhc3NJbnRlcnZhbF0gb2YgY2xhc3NJbnRlcnZhbHMuZW50cmllcygpKVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gY2xhc3NJbnRlcnZhbFswXSAmJiB2YWx1ZSA8IGNsYXNzSW50ZXJ2YWxbMV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgY2xhc3NJbnRlcnZhbHNbMF1bMF0pXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiBjbGFzc0ludGVydmFscy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgaWYgdGhlIGdpdmVuIHZhbHVlIGNoYW5nZXMgdGhlbS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBnaXZlbiB2YXVlLiBcclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgc2V0TWluTWF4KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5taW4pXHJcbiAgICAgICAgICAgIHRoaXMubWluID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5tYXgpXHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdmFsdWU7XHJcbiAgICAgICAgLyogaWYgKHZhbHVlIDwgdGhpcy5uZXdNaW4pXHJcbiAgICAgICAgICAgIHRoaXMubmV3TWluID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5uZXdNYXgpXHJcbiAgICAgICAgICAgIHRoaXMubmV3TWF4ID0gdmFsdWU7ICovXHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgQ0xBU1MgQ0FMQ1VMQVRJT04gICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgZm9yIHRoZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBtaW5pbXVtIHZhbHVlIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRNaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gIHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRNYXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBzdGVwIHZhdWUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIHNldFN0ZXAoKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gKHRoaXMuZ2V0TWF4KCkgLSB0aGlzLmdldE1pbigpKSAvICh0aGlzLm51bUJpbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RlcCBiZXR3ZWVuIGVhY2ggYmluIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgc3RlcCBiZXR3ZWVuIGVhY2ggYmluIHZhbHVlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRTdGVwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoaXN0b2dyYW0gZm9yIHRoaXMgY29udGludW91cyB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBoaXN0b2dyYW0gZm9yIHRoaXMgY29udGludW91cyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0SGlzdG9ncmFtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpc3RvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGhpc3RvZ3JhbSBvZiB0aGlzIGNvbnRpbnVvdXMgdmFyaWFibGUgd2l0aCB0aGUgaGlzdG9ncmFtIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBoaXN0b2dyYW0gLSBUaGUgZ2l2ZW4gaGlzdG9ncmFtXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUhpc3RvZ3JhbShoaXN0b2dyYW0pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1baV0gKz0gaGlzdG9ncmFtW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgY2xhc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudW1lcn0gLSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldE51bWJlck9mQ2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgMTAwIGJpbnMgd2l0aCBlcXVhbCBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSBmb3IgdGhpcyBjb250aW51b3VzIHZhcmlhYmxlLiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSBmb3IgdGhpcyBjb250aW51b3VzIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gVGhlIGJpbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzLlxyXG4gICAgICogQG1lbWJlcm9mIExlZ2VuZENsYXNzZXNcclxuICAgICAqL1xyXG4gICAgYnVpbGRCaW5JbnRlcnZhbHMoKSB7XHJcbiAgICAgICAgLy8gbGV0IHN0ZXAgPSAobWF4IC0gbWluKSAvIHRoaXMubnVtQmlucztcclxuICAgICAgICBpZiAodGhpcy5zdGVwID09PSAtMSlcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGVwKCk7XHJcbiAgICAgICAgbGV0IHJlc0JpbnMgPSBbXTtcclxuICAgICAgICBsZXQgbWluID0gdGhpcy5taW47XHJcbiAgICAgICAgbGV0IG1heCA9IHRoaXMubWF4O1xyXG4gICAgICAgIC8vIHJlc0JpbnMucHVzaChtaW4pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBtYXg7IGkgKz0gdGhpcy5zdGVwKVxyXG4gICAgICAgICAgICByZXNCaW5zLnB1c2goaSk7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHJlc0JpbnNbcmVzQmlucy5sZW5ndGggLSAxXSkgPT09IG1heCB8fCBtYXggLSByZXNCaW5zW3Jlc0JpbnMubGVuZ3RoIC0gMV0gPCAwLjAwMDEpIC8vbWluID0gMCwgbWF4ID0gMTk5LjIgTWF0aC5yb3VuZCgxOTkuMTk5OTk5OTk5OTk5NzYpID0gMTk5IDwtLSBFUlJPUlxyXG4gICAgICAgICAgICByZXNCaW5zW3Jlc0JpbnMubGVuZ3RoIC0gMV0gPSBtYXg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXNCaW5zLnB1c2gobWF4KTtcclxuICAgICAgICByZXR1cm4gcmVzQmlucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgYmlucyBhcnJheSB3aXRoIDEwMT8gdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBpbnRlcnZhbHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUJpbnMoKSB7XHJcbiAgICAgICAgdGhpcy5iaW5zID0gdGhpcy5idWlsZEJpbkludGVydmFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSB2YWx1ZSB0byB0aGUgcmVzcGVjdGl2ZSBiaW4gaW5kZXguXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBhdCBPKDEpIGluc3RlYWQgb2YgTyhuKSwgc2luY2UgaXQgb25seSBuZWVkcyB0byBjYWxjdWxhdGUgdGhlIGluZGV4IGFuZCBhZGQgb25lIHRvIGl0J3MgYmluLlxyXG4gICAgICogVGhlIGFsdGVybmF0aXZlIHdhcyB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBiaW5zIGFuZCBmaW5kIHdoZXJlIHRoaXMgdmFsdWUgd291bGQgZml0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc2VydCBpbnRvIG9uZSBvZiB0aGUgYmlucy4gXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9wcm50c2NyLmNvbS9nZG4xd3UgLSBSZWFzb24gZm9yIGlmIHN0YXRlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBhZGRWYWx1ZVRvQmlucyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBiaW5JbmRleCA9IE1hdGguZmxvb3IoKHZhbHVlIC0gdGhpcy5taW4pIC8gdGhpcy5zdGVwKTtcclxuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5tYXgpIC8vVGhlIGNhc2UgaXQgaXMgZXF1YWwgdG8gdGhlIG1heCB2YWx1ZSB0aGVuIGNoYW5nZSBpbmRleCB0byB0aGUgcHJldmlvdXMuXHJcbiAgICAgICAgICAgIGJpbkluZGV4ID0gdGhpcy5udW1CaW5zIC0gMTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8PSB0aGlzLm1pbilcclxuICAgICAgICAgICAgYmluSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuaGlzdG9ncmFtW2JpbkluZGV4XSsrO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFsdWVcIiwgdmFsdWUsIFwiYmluSW5kZXhcIiwgYmluSW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY2xhc3NlcyBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZSB1c2luZyB0aGUgbWV0aG9kIHNwZWNpZmllZCBieSB0aGUgcHJvZ3JhbW1lci5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQ2xhc3NlcygpIHtcclxuICAgICAgICAvL1VzYW5kbyBvcyBiaW5zIGZheiBjYWxjdWxvIGRlIGNsYXNzZXMgZSBhbHRlcmFyIGd1YXJkYXIgbm9zIGNsYXNzSW50ZXJ2YWxzXHJcbiAgICAgICAgbGV0IENCTUVUSE9EUyA9IEdpc3BsYXlEZWZhdWx0cy5nZXRBdmFpbGFibGVDbGFzc0JyZWFrc01ldGhvZHMoKTtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0Q2xhc3NCcmVha01ldGhvZCgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQ0JNRVRIT0RTLlFVQU5USUxFUzpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NJbnRlcnZhbHMgPSB0aGlzLmNhbGN1bGF0ZUNsYXNzSW50ZXJ2YWxzKHRoaXMucXVhbnRpbGVzKCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ0JNRVRIT0RTLkVRVUFMX0lOVEVSVkFMUzpcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlcXVhbGludGVydmFscycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0ludGVydmFscyA9IHRoaXMuY2FsY3VsYXRlQ2xhc3NJbnRlcnZhbHModGhpcy5lcXVhbEludGVydmFscygpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdpc3BsYXlFcnJvcihgQ29udGludW91cyBWYXJpYWJsZTogJHt0aGlzLmdldEludGVybmFsTmFtZSgpfS4gR2l2ZW4gbWV0aG9kIGZvciBjbGFzcyBjYWxjdWxhdGlvbiBkb2VzIG5vdCBleGlzdC4gYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jbGFzc0ludGVydmFscy5sZW5ndGggIT09IHRoaXMubnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKFwiVGhlIG51bWJlciBvZiBjYWxjdWxhdGVkIGNsYXNzIGludGVydmFscyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbnVtYmVyIG9mIGNsYXNzZXNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGludGVydmFscyBmb3IgZWFjaCBjbGFzcyB1c2luZyB0aGUgcXVhbnRpbGVzIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaGlzdG9ncmFtIC0gSGlzdG9ncmFtIHdpdGggcXVhbnRpdHkgb2YgdmFsdWVzIGJ5IGJpbiBpbnRlcnZhbC4gXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmluVmFsdWVzIC0gVGhlIGJpbiB2YWx1ZXMgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgdGhlIG1heGltdW0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtUm93cyAtIE51bWJlciBvZiByb3dzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1DbGFzc2VzIC0gTnVtYmVyIG9mIGNsYXNzZXMgdG8gY2FsY3VsYXRlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gIFRoZSByZXN1bHRpbmcgY2xhc3NlcyB1c2luZyB0aGUgcXVhbnRpbGVzIG1ldGhvZC5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGVcclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgcXVhbnRpbGVzKG51bWJlck9mQ2xhc3NlcyA9IHRoaXMuZ2V0TnVtYmVyT2ZDbGFzc2VzKCkpIHtcclxuICAgICAgICBsZXQgbnVtUm93cyA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHRoaXMuaGlzdG9ncmFtLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBudW1Sb3dzICs9IHRoaXMuaGlzdG9ncmFtW2ldO1xyXG5cclxuICAgICAgICBsZXQgbnVtVmFsc1BlckNsYXNzID0gbnVtUm93cyAvIG51bWJlck9mQ2xhc3NlcztcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhudW1Sb3dzLCB0aGlzLmdldE51bWJlck9mQ2xhc3NlcygpLCBudW1WYWxzUGVyQ2xhc3MpO1xyXG4gICAgICAgIGxldCBjbGFzc2VzID0gW107XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMuYmluc1swXSk7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhpc3RvZ3JhbS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IHRoaXMuaGlzdG9ncmFtW2ldO1xyXG4gICAgICAgICAgICBpZiAoc3VtID49IG51bVZhbHNQZXJDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMuYmluc1tpICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5iaW5zW3RoaXMuYmlucy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2xhc3Nlcyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcyk7XHJcbiAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoIDwgbnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFF1YW50aWxlcyBtZXRob2QgY291bGRuJ3QgY3JlYXRlICR7bnVtYmVyT2ZDbGFzc2VzfSBjbGFzc2VzLCBpbnN0ZWFkIGl0IGNyZWF0ZWQgJHtjbGFzc2VzLmxlbmd0aCAtIDF9IGNsYXNzZXMuIFske2NsYXNzZXN9XWApO1xyXG4gICAgICAgIGVsc2UgaWYgKGNsYXNzZXMubGVuZ3RoIC0gMSA+IG51bWJlck9mQ2xhc3NlcylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEdpc3BsYXlFcnJvcihgU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBxdWFudGlsZXMgbWV0aG9kLiBOdW1iZXIgb2YgY2xhc3NlcyBjYWxjdWxhdGVkIGlzOiAke2NsYXNzZXMubGVuZ3RoIC0gMX0sIHRoZSBpbnRlbmRlZCB2YWx1ZXMgd2FzICR7dGhpcy5nZXROdW1iZXJPZkNsYXNzZXMoKX1gKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2luZyB0aGUgY2FsY3VsYXRlZCBiaW5zLCB0aGlzIG1ldGhvZCB3aWxsIGNhbGN1bGF0ZSB0aGUgaW50ZXJ2YWxzIGZvciBlYWNoIGNsYXNzIHVzaW5nIHRoZSBlcXVhbCBpbnRlcnZhbHMgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpblZhbHVlcyAtIFRoZSBiaW4gdmFsdWVzIGJldHdlZW4gdGhlIG1pbmltdW0gYW5kIHRoZSBtYXhpbXVtLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUNsYXNzZXMgLSBOdW1iZXIgb2YgY2xhc3NlcyB0byBjYWxjdWxhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gLSBUaGUgcmVzdWx0aW5nIGNsYXNzZXMgdXNpbmcgdGhlIGVxdWFsIGludGVydmFscyBtZXRob2QuXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly93aWtpLmdpcy5jb20vd2lraS9pbmRleC5waHAvRXF1YWxfSW50ZXJ2YWxfY2xhc3NpZmljYXRpb25cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZXF1YWxJbnRlcnZhbHMobnVtYmVyT2ZDbGFzc2VzID0gdGhpcy5nZXROdW1iZXJPZkNsYXNzZXMoKSkge1xyXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IE1hdGgucm91bmQoKHRoaXMuZ2V0TWF4KCkgLSB0aGlzLmdldE1pbigpKSAvIG51bWJlck9mQ2xhc3Nlcyk7IC8vVG8gZ2l2ZSBhIGludGVnZXIgKHRoaXMuYmlucy5sZW5ndGggLSAxKSAvIHRoaXMubnVtQ2xhc3NlcztcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVxdUludCBpbnRlcnZhbD1cIiwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2V0TWluKCksIHRoaXMuZ2V0TWF4KCksIG51bWJlck9mQ2xhc3Nlcyk7XHJcbiAgICAgICAgbGV0IGNsYXNzZXMgPSBbXTtcclxuICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5iaW5zWzBdKTtcclxuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGhpcy5nZXRNaW4oKTsgLy8gQ3VycmVudCB2YWx1ZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSArPSBpbnRlcnZhbDtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMuX2ZpbmRCaW4oY3VycmVudFZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLmJpbnNbdGhpcy5iaW5zLmxlbmd0aCAtIDFdKTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJlcXVhbEludGVydmFscyA9IFwiLCBjbGFzc2VzKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGJpbiB0aGF0IGlzIGhpZ2hlciBvciBlcXVhbCB0aGFuIHRoZSB2YWx1ZSBhbmQgdGhlIGRpc3RhbmNlIHRvIG5leHQgYmluIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0byB0aGUgZmlyc3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IGJpbi4gXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBiaW4gdGhhdCBpcyBoaWdoZXIgb3IgZXF1YWwgdGhhbiB0aGUgdmFsdWUgYW5kIHRoZSBkaXN0YW5jZSB0byBuZXh0IGJpbiB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gdG8gdGhlIGZpcnN0LiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBfZmluZEJpbih2YWx1ZSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iaW5zLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsMSA9IHRoaXMuYmluc1tpXTtcclxuICAgICAgICAgICAgbGV0IHZhbDIgPSB0aGlzLmJpbnNbaSArIDFdO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsMSAmJiB2YWx1ZSA8IHZhbDIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0VG9WYWwxID0gdmFsdWUgLSB2YWwxO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RUb1ZhbDIgPSB2YWwyIC0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdFRvVmFsMSA8PSBkaXN0VG9WYWwyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZWFjaCBpbmRleCAob2YgZWFjaCBjbGFzcykgdG8gaXQncyByZXNwZWN0aXZlIHZhbHVlIChjb2xvciBhcnJheSwgc2l6ZSBvciBvcmllbnRhdGlvbiB2YWx1ZSkuXHJcbiAgICAgKiBFLmcuIDAgLT4gWzI1NSwgMCwgMF0sIDEgLT4gWzAsIDEyOCwgMF0gZXRjXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBfc2V0SW5kZXhUb1VzYWJsZVZhbHVlTWFwKCkge1xyXG4gICAgICAgIGxldCBWVlMgPSBHaXNwbGF5RGVmYXVsdHMuZ2V0QXZhaWxhYmxlVmlzdWFsVmFyaWFibGVzKCk7XHJcbiAgICAgICAgbGV0IHR5cGVPZlZpc3VhbFZhcmlhYmxlID0gdGhpcy5nZXRUeXBlT2ZWaXN1YWxWYXJpYWJsZSgpO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZU9mVmlzdWFsVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgY2FzZSBWVlMuQ09MT1I6XHJcbiAgICAgICAgICAgIGNhc2UgVlZTLlNJWkU6XHJcbiAgICAgICAgICAgIGNhc2UgVlZTLk9SSUVOVEFUSU9OOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2luZGV4LCB2dk1hcHBpbmddIG9mIHRoaXMuZ2V0VmlzdWFsVmFyaWFibGVNYXBwaW5nKCkuZW50cmllcygpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgdnZNYXBwaW5nKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFZWUy5TSEFQRTpcclxuICAgICAgICAgICAgY2FzZSBWVlMuVEVYVFVSRTpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoYCR7dHlwZU9mVmlzdWFsVmFyaWFibGV9IHNob3VsZG4ndCBiZSB1c2VkIHdpdGggYSBjb250aW51b3VzIHZhcmlhYmxlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNPTlQgVlZfVE9fSU5ERVhfTUFQID09PT09PT09PT09PT09PT09PT09PT09PT1cIiwgdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXApO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L1ZWcy9Db250aW51b3VzVmFyaWFibGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7Ozs7Ozs7QUFPQTs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUZBO0FBQ0E7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQS9FQTtBQWdGQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/Gisplay/VVs/TimeVariable.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TimeVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable2 = __webpack_require__(/*! ./DataVariable */ 1);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents the time information.\r\n * @export\r\n * @class TimeVariable\r\n */\nvar TimeVariable = exports.TimeVariable = function (_DataVariable) {\n    _inherits(TimeVariable, _DataVariable);\n\n    /**\r\n     * Creates an instance of TimeVariable.\r\n     * @param {string} externalName - The external name of the time variable.\r\n     * @param {string} internalName - The internal name of the time variable.\r\n     * @param {string} granularity - The granularity of the time variable.\r\n     * @param {string} timeControl - The time control for the time variable.\r\n     * @memberof TimeVariable\r\n     */\n    function TimeVariable(externalName, internalName, granularity, timeControl) {\n        _classCallCheck(this, TimeVariable);\n\n        /**\r\n         * The time granularity.\r\n         * @type {string}\r\n         */\n        var _this = _possibleConstructorReturn(this, (TimeVariable.__proto__ || Object.getPrototypeOf(TimeVariable)).call(this, externalName, internalName));\n\n        _this.granularity = granularity;\n        /**\r\n         * The granules for this time variable that were processed from the file.\r\n         * @type {Set<string|number>}\r\n         */\n        _this.granules = new Set();\n        /**\r\n         * A map with each temporal granule and it's index.\r\n         * @type {Map<number|string, number>}\r\n         */\n        _this.temporalGranulesMap = new Map();\n        /**\r\n         * The current granule index. This is used to give each granule it's specific index.\r\n         * @type {number}\r\n         */\n        _this.granuleIndex = 0;\n        /**\r\n         * The temporal granules sorted by Date. If its a number (year or day or value etc) then sorted by number.\r\n         * @type {Array<number|string>}\r\n         */\n        _this.sortedTemporalGranulesArr = [];\n        /** \r\n         * The map that contains the string that represents the date and the respective date (e.g. 2016_1_1 => 1 January 2016 OR 2016 => 2016)\r\n         * If the date is a number (e.g. year, monthOfYear, value etc) then the key and the value are equal (2016 => 2016).\r\n         * A value here will be a key in the temporalGranulesMap.\r\n         * @type {Map<string|number, string|number>}\r\n         */\n        _this.strToTemporalGranuleMap = new Map();\n        /** \r\n         * The map with the string temporal granules and their respective index inm the sorted temporal granules array.\r\n         * E.g. Map (3)  {\"1 January 2016\" => 0, \"2 January 2016\" => 1, \"3 January 2016\" => 2, \"4 January 2016\" => 3 }.\r\n         * Used to quickly search for the index of the start and end point of the time control.\r\n         * A value here is an index in the sortedTemporalGranulesArr.\r\n         * @type {Map<string|number, number>}\r\n         */\n        _this.sortedTGsToIndexMap = new Map();\n        /**\r\n         * The time control to use.\r\n         * @type {string}\r\n         */\n        _this.timeControl = timeControl;\n        return _this;\n    }\n\n    /**\r\n     * The granularity\r\n     * @returns {string} - The granularity. \r\n     * @memberof TimeVariable\r\n     */\n\n\n    _createClass(TimeVariable, [{\n        key: 'getGranularity',\n        value: function getGranularity() {\n            return this.granularity;\n        }\n\n        /**\r\n         * Returns the type of time control that should be used.\r\n         * @returns \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTypeOfTimeControl',\n        value: function getTypeOfTimeControl() {\n            return this.timeControl ? this.timeControl : _GisplayDefaults.GisplayDefaults.INSTANT();\n        }\n\n        /**\r\n         * Available granularities for the time value.\r\n         * @returns {Array<string>} - the set of available granularities.  \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getAvailableGranularities',\n        value: function _getAvailableGranularities() {\n            return ['year', 'month', 'day', 'value', //Continuous\n            'monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour' // Cyclic\n            ];\n        }\n\n        //GRANULES ETC\n        /**\r\n         * Add all values to the temporal granules map.\r\n         * @param {Array<number>} values - The array of values to add to the granules map.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'createTemporalGranulesMap',\n        value: function createTemporalGranulesMap(values) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var val = _step.value;\n\n                    this.temporalGranulesMap.set(val, this.granuleIndex++);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Add temporal granule to the temporal granules set and return it's index if it does not exist.\r\n         * @param {number} temporalGranule - The temporal granule to be added. \r\n         * @returns {number} - the index of the given temporal granule.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'addTemporalGranule',\n        value: function addTemporalGranule(temporalGranule) {\n            if (this.temporalGranulesMap.has(temporalGranule)) return this.temporalGranulesMap.get(temporalGranule);else {\n                this.temporalGranulesMap.set(temporalGranule, this.granuleIndex);\n                return this.granuleIndex++;\n            }\n        }\n\n        /**\r\n         * Add the given temporal granule to the set of existing temporal granules.\r\n         * @param {string|number} temporalGranule - The temporal granule to add to the set of temporal granules.\r\n         */\n\n    }, {\n        key: 'addTemporalGranuleToSet',\n        value: function addTemporalGranuleToSet(temporalGranule) {\n            this.granules.add(temporalGranule);\n        }\n\n        /**\r\n         * Add temporal granules to the set of temporal granules.\r\n         * @param {Set<string>} temporalGranules - The temporal granules. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'addTemporalGranulesToSet',\n        value: function addTemporalGranulesToSet(temporalGranules) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = temporalGranules.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var temporalGranule = _step2.value;\n\n                    this.addTemporalGranuleToSet(temporalGranule);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Returns the Set of temporal granules.\r\n         * @returns {Set<string>} - the Set of temporal granules. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTemporalGranulesSet',\n        value: function getTemporalGranulesSet() {\n            return this.granules;\n        }\n\n        /**\r\n         * Returns the temporal granules that exist on the dataset. E.g. 2016, 2017 etc\r\n         * @returns {Map<number, number>} - the temporal granules that exist on the dataset.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTemporalGranules',\n        value: function getTemporalGranules() {\n            return this.temporalGranulesMap; //Array.from(this.temporalGranulesMap.keys());\n        }\n\n        /**\r\n         * Returns true if the temporal granule values were given, false, otherwise.\r\n         * @returns {booelan} - true if the temporal granule values were given, false, otherwise.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return true;\n        }\n\n        /**\r\n         * Sort the temporal granules creating an array with those sorted elements.\r\n         * If the elements are dates then order by date, if they are numbers order by number.\r\n         * @returns {Array<string|number>} - the sorted temporal granules, sorted by date/number.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'sortTemporalGranules',\n        value: function sortTemporalGranules() {\n            var availableGranularites = this._getAvailableGranularities();\n            var tgs = this.getTemporalGranules().keys();\n            var granularitiesArray = []; // \n            var strToTGMap = new Map(); // 26_1_0 => 1 January 2016\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = tgs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var tg = _step3.value;\n\n                    var strGranularity = void 0;\n                    switch (this.granularity) {\n                        case availableGranularites[1]:\n                            //Month\n                            strGranularity = this._getMonth(tg);\n                            break;\n                        case availableGranularites[2]:\n                            //Day\n                            strGranularity = this._getDay(tg);\n                            break;\n                        default:\n                            strGranularity = tg;\n                            break;\n                    }\n                    granularitiesArray.push(strGranularity);\n                    strToTGMap.set(strGranularity, tg);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            this.strToTemporalGranuleMap = strToTGMap;\n            this.sortedTemporalGranulesArr = granularitiesArray.sort(function (a, b) {\n                return new Date(a) - new Date(b);\n            });\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.sortedTemporalGranulesArr.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var _step4$value = _slicedToArray(_step4.value, 2),\n                        i = _step4$value[0],\n                        sortedTG = _step4$value[1];\n\n                    this.sortedTGsToIndexMap.set(sortedTG, i);\n                } /*   console.warn(this.sortedTemporalGranulesArr);\r\n                    console.warn(this.strToTemporalGranuleMap);\r\n                    console.warn(this.sortedTGsToIndexMap); */\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            this._sortTemporalGranulesMap();\n            return this.sortedTemporalGranulesArr;\n        }\n\n        /**\r\n         * Sort the temporal granules strings (read from file) to the indices of the sorted\r\n         * temporal granules.\r\n         * @private\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_sortTemporalGranulesMap',\n        value: function _sortTemporalGranulesMap() {\n            var sortedIndexMap = new Map();\n            var sortedTGsToIndexMap = this.sortedTGsToIndexMap; //January 2017 -> 0, February 2017 -> 1\n            var strToTGMap = this.strToTemporalGranuleMap; //January 2017 -> 2017_1, February 2017 -> 2017_2\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = sortedTGsToIndexMap.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var key = _step5.value;\n\n                    sortedIndexMap.set(strToTGMap.get(key), sortedTGsToIndexMap.get(key));\n                } //2017_1 -> 0\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            this.temporalGranulesMap = sortedIndexMap;\n        }\n\n        /**\r\n         * Returns the locale month string. \r\n         * In portugal will return 'janeiro', 'fevereiro' etc... \r\n         * @param {string} dateString - The date string read from the file.\r\n         * @returns {string} - the locale month string.\r\n         * @private\r\n         * @see https://stackoverflow.com/a/18648314/\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getLocaleMonth',\n        value: function _getLocaleMonth(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            return date.toLocaleString(\"en-us\", { month: \"long\" });\n        }\n\n        /**\r\n         * Returns the month name plus the year.\r\n         * @param {string} dateString \r\n         * @returns {string} - the month name plus the year.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getMonth',\n        value: function _getMonth(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            var monthName = this._getLocaleMonth(dateString);\n            var year = date.getFullYear();\n            return monthName + \" \" + year;\n        }\n\n        /**\r\n         * Get the date including the day (day month year).\r\n         * @param {string} dateString - The date string read from the file.\r\n         * @returns {string} - the date including the day.\r\n         * @see https://stackoverflow.com/a/18648314/\r\n         * @private\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getDay',\n        value: function _getDay(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            var monthName = this._getLocaleMonth(dateString);\n            var day = date.getDate();\n            var year = date.getFullYear();\n            return day + \" \" + monthName + \" \" + year;\n        }\n\n        /**\r\n         * Returns the index of the temporal granule given by the string. \r\n         * @param {string|number} temporalgranuleStr - The temporal granule string representation.\r\n         * @returns {number} - the index of the temporal granule given by the string.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getGranuleIndexFromStr',\n        value: function getGranuleIndexFromStr(temporalgranuleStr) {\n            var key = this.strToTemporalGranuleMap.get(temporalgranuleStr);\n            return this.temporalGranulesMap.get(key);\n        }\n\n        /**\r\n         * Returns the index of the temporal granule read from the file.\r\n         * @param {string} str - The given string \r\n         * @returns {number} - the index of the temporal granule read from the file.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTGMapIndex',\n        value: function getTGMapIndex(str) {\n            return this.temporalGranulesMap.get(str);\n        }\n\n        /**\r\n         * Returns the sorted temporal granules. \r\n         * @returns {Array<string|number>} - the sorted temporal granules.  \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getSortedTemporalGranules',\n        value: function getSortedTemporalGranules() {\n            return this.sortedTemporalGranulesArr;\n        }\n\n        /**\r\n         * Returns the first temporal granule from the sorted list of temporal granules.\r\n         * @returns {string|number} - the first temporal granule from the sorted list of temporal granules.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getFirstTemporalGranule',\n        value: function getFirstTemporalGranule() {\n            return this.sortedTemporalGranulesArr[0];\n        }\n\n        /**\r\n         * Returns the indices of the temporal granules between the start and end temporal granules string representations.\r\n         * @param {any} startTGStr - The string representation of the range start temporal granule. \r\n         * @param {any} endTGStr - The string representation of the range end temporal granule. \r\n         * @returns {Array<number>} - the indices of the temporal granules between the given start and end temporal granules.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getRangeIndices',\n        value: function getRangeIndices(startTGStr, endTGStr) {\n            var _ref = [this.sortedTGsToIndexMap.get(startTGStr), this.sortedTGsToIndexMap.get(endTGStr)],\n                sortedStartIndex = _ref[0],\n                sortedEndIndex = _ref[1];\n\n            var sortedTGsArrSliced = this.sortedTemporalGranulesArr.slice(sortedStartIndex, sortedEndIndex + 1);\n            var rangeIndices = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = sortedTGsArrSliced[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var sortedTG = _step6.value;\n\n                    rangeIndices.push(this.getGranuleIndexFromStr(sortedTG));\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            return rangeIndices;\n        }\n\n        /**\r\n         * Returns the index of the given temporal granule string/number. \r\n         * The index is the value associated with  the given key.\r\n         * @param {string|number} sortedTemporalGranule - The temporal granule string/number.\r\n         * @returns {number} - the index of the given temporal granule string/number. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getSortedIndexFromStr',\n        value: function getSortedIndexFromStr(sortedTemporalGranule) {\n            return this.sortedTGsToIndexMap.get(sortedTemporalGranule);\n        }\n\n        /**\r\n         * Returns the index of the next temporal granule on the \"timeline\".\r\n         * @param {string|number} currentTG - The current temporal granule.\r\n         * @returns {number} - the index of the next temporal granule on the \"timeline\".\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'findNextTGIndex',\n        value: function findNextTGIndex(currentTG) {\n            var indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\n            var lastTG = this.sortedTemporalGranulesArr.length - 1;\n            var nextSortedTG = this.sortedTemporalGranulesArr[indexSortedTG < lastTG ? indexSortedTG + 1 : indexSortedTG]; //Avoid it going over the last index\n            return this.getSortedIndexFromStr(nextSortedTG);\n        }\n\n        /**\r\n         * Returns the index of the previous temporal granule on the \"timeline\".\r\n         * @param {string|number} currentTG - The current temporal granule.\r\n         * @returns {number} - the index of the previous temporal granule on the \"timeline\".\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'findPreviousTGIndex',\n        value: function findPreviousTGIndex(currentTG) {\n            var indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\n            var previousTG = this.sortedTemporalGranulesArr[indexSortedTG >= 1 ? indexSortedTG - 1 : indexSortedTG]; //Avoid it going bellow 0\n            return this.getSortedIndexFromStr(previousTG);\n        }\n\n        /**\r\n         * Returns true if the temporal granules are numbers.\r\n         * @returns {boolean} - true if the temporal granules are numbers, false, otherwise.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'temporalGranulesAreNumbers',\n        value: function temporalGranulesAreNumbers() {\n            return _GisplayDefaults.GisplayDefaults.isNumber(this.getFirstTemporalGranule()); //typeof this.getFirstTemporalGranule() === 'number';\n        }\n    }]);\n\n    return TimeVariable;\n}(_DataVariable2.DataVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvVGltZVZhcmlhYmxlLmpzP2Y0MTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVZhcmlhYmxlIH0gZnJvbSAnLi9EYXRhVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBHaXNwbGF5RGVmYXVsdHMgfSBmcm9tICcuLi9HaXNwbGF5RGVmYXVsdHMnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHRpbWUgaW5mb3JtYXRpb24uXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFRpbWVWYXJpYWJsZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRpbWVWYXJpYWJsZSBleHRlbmRzIERhdGFWYXJpYWJsZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRpbWVWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncmFudWxhcml0eSAtIFRoZSBncmFudWxhcml0eSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lQ29udHJvbCAtIFRoZSB0aW1lIGNvbnRyb2wgZm9yIHRoZSB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSwgZ3JhbnVsYXJpdHksIHRpbWVDb250cm9sKSB7XHJcbiAgICAgICAgc3VwZXIoZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0aW1lIGdyYW51bGFyaXR5LlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBncmFudWxlcyBmb3IgdGhpcyB0aW1lIHZhcmlhYmxlIHRoYXQgd2VyZSBwcm9jZXNzZWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAgICAgKiBAdHlwZSB7U2V0PHN0cmluZ3xudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgd2l0aCBlYWNoIHRlbXBvcmFsIGdyYW51bGUgYW5kIGl0J3MgaW5kZXguXHJcbiAgICAgICAgICogQHR5cGUge01hcDxudW1iZXJ8c3RyaW5nLCBudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGVtcG9yYWxHcmFudWxlc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBncmFudWxlIGluZGV4LiBUaGlzIGlzIHVzZWQgdG8gZ2l2ZSBlYWNoIGdyYW51bGUgaXQncyBzcGVjaWZpYyBpbmRleC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZUluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGVtcG9yYWwgZ3JhbnVsZXMgc29ydGVkIGJ5IERhdGUuIElmIGl0cyBhIG51bWJlciAoeWVhciBvciBkYXkgb3IgdmFsdWUgZXRjKSB0aGVuIHNvcnRlZCBieSBudW1iZXIuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcnxzdHJpbmc+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0FyciA9IFtdO1xyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBUaGUgbWFwIHRoYXQgY29udGFpbnMgdGhlIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGUgYW5kIHRoZSByZXNwZWN0aXZlIGRhdGUgKGUuZy4gMjAxNl8xXzEgPT4gMSBKYW51YXJ5IDIwMTYgT1IgMjAxNiA9PiAyMDE2KVxyXG4gICAgICAgICAqIElmIHRoZSBkYXRlIGlzIGEgbnVtYmVyIChlLmcuIHllYXIsIG1vbnRoT2ZZZWFyLCB2YWx1ZSBldGMpIHRoZW4gdGhlIGtleSBhbmQgdGhlIHZhbHVlIGFyZSBlcXVhbCAoMjAxNiA9PiAyMDE2KS5cclxuICAgICAgICAgKiBBIHZhbHVlIGhlcmUgd2lsbCBiZSBhIGtleSBpbiB0aGUgdGVtcG9yYWxHcmFudWxlc01hcC5cclxuICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZ3xudW1iZXIsIHN0cmluZ3xudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RyVG9UZW1wb3JhbEdyYW51bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFRoZSBtYXAgd2l0aCB0aGUgc3RyaW5nIHRlbXBvcmFsIGdyYW51bGVzIGFuZCB0aGVpciByZXNwZWN0aXZlIGluZGV4IGlubSB0aGUgc29ydGVkIHRlbXBvcmFsIGdyYW51bGVzIGFycmF5LlxyXG4gICAgICAgICAqIEUuZy4gTWFwICgzKSAge1wiMSBKYW51YXJ5IDIwMTZcIiA9PiAwLCBcIjIgSmFudWFyeSAyMDE2XCIgPT4gMSwgXCIzIEphbnVhcnkgMjAxNlwiID0+IDIsIFwiNCBKYW51YXJ5IDIwMTZcIiA9PiAzIH0uXHJcbiAgICAgICAgICogVXNlZCB0byBxdWlja2x5IHNlYXJjaCBmb3IgdGhlIGluZGV4IG9mIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50IG9mIHRoZSB0aW1lIGNvbnRyb2wuXHJcbiAgICAgICAgICogQSB2YWx1ZSBoZXJlIGlzIGFuIGluZGV4IGluIHRoZSBzb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyLlxyXG4gICAgICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nfG51bWJlciwgbnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRpbWUgY29udHJvbCB0byB1c2UuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVDb250cm9sID0gdGltZUNvbnRyb2w7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JhbnVsYXJpdHlcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGdyYW51bGFyaXR5LiBcclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0R3JhbnVsYXJpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnVsYXJpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRpbWUgY29udHJvbCB0aGF0IHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFR5cGVPZlRpbWVDb250cm9sKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVDb250cm9sID8gdGhpcy50aW1lQ29udHJvbCA6IEdpc3BsYXlEZWZhdWx0cy5JTlNUQU5UKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdmFpbGFibGUgZ3JhbnVsYXJpdGllcyBmb3IgdGhlIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSB0aGUgc2V0IG9mIGF2YWlsYWJsZSBncmFudWxhcml0aWVzLiAgXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXRBdmFpbGFibGVHcmFudWxhcml0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ3ZhbHVlJywgLy9Db250aW51b3VzXHJcbiAgICAgICAgICAgICdtb250aE9mWWVhcicsICdkYXlPZlllYXInLCAnZGF5T2ZNb250aCcsICdob3VyT2ZEYXknLCAnbWludXRlT2ZIb3VyJyAvLyBDeWNsaWNcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vR1JBTlVMRVMgRVRDXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbGwgdmFsdWVzIHRvIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBtYXAuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBncmFudWxlcyBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVRlbXBvcmFsR3JhbnVsZXNNYXAodmFsdWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlcylcclxuICAgICAgICAgICAgdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLnNldCh2YWwsIHRoaXMuZ3JhbnVsZUluZGV4KyspO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRlbXBvcmFsIGdyYW51bGUgdG8gdGhlIHRlbXBvcmFsIGdyYW51bGVzIHNldCBhbmQgcmV0dXJuIGl0J3MgaW5kZXggaWYgaXQgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGVtcG9yYWxHcmFudWxlIC0gVGhlIHRlbXBvcmFsIGdyYW51bGUgdG8gYmUgYWRkZWQuIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGFkZFRlbXBvcmFsR3JhbnVsZSh0ZW1wb3JhbEdyYW51bGUpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLmhhcyh0ZW1wb3JhbEdyYW51bGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLmdldCh0ZW1wb3JhbEdyYW51bGUpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAuc2V0KHRlbXBvcmFsR3JhbnVsZSwgdGhpcy5ncmFudWxlSW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFudWxlSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUgdG8gdGhlIHNldCBvZiBleGlzdGluZyB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdGVtcG9yYWxHcmFudWxlIC0gVGhlIHRlbXBvcmFsIGdyYW51bGUgdG8gYWRkIHRvIHRoZSBzZXQgb2YgdGVtcG9yYWwgZ3JhbnVsZXMuXHJcbiAgICAgKi9cclxuICAgIGFkZFRlbXBvcmFsR3JhbnVsZVRvU2V0KHRlbXBvcmFsR3JhbnVsZSkge1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZXMuYWRkKHRlbXBvcmFsR3JhbnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGVtcG9yYWwgZ3JhbnVsZXMgdG8gdGhlIHNldCBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwYXJhbSB7U2V0PHN0cmluZz59IHRlbXBvcmFsR3JhbnVsZXMgLSBUaGUgdGVtcG9yYWwgZ3JhbnVsZXMuIFxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBhZGRUZW1wb3JhbEdyYW51bGVzVG9TZXQodGVtcG9yYWxHcmFudWxlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGVtcG9yYWxHcmFudWxlIG9mIHRlbXBvcmFsR3JhbnVsZXMua2V5cygpKVxyXG4gICAgICAgICAgICB0aGlzLmFkZFRlbXBvcmFsR3JhbnVsZVRvU2V0KHRlbXBvcmFsR3JhbnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBTZXQgb2YgdGVtcG9yYWwgZ3JhbnVsZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7U2V0PHN0cmluZz59IC0gdGhlIFNldCBvZiB0ZW1wb3JhbCBncmFudWxlcy4gXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFRlbXBvcmFsR3JhbnVsZXNTZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnVsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wb3JhbCBncmFudWxlcyB0aGF0IGV4aXN0IG9uIHRoZSBkYXRhc2V0LiBFLmcuIDIwMTYsIDIwMTcgZXRjXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwPG51bWJlciwgbnVtYmVyPn0gLSB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgdGhhdCBleGlzdCBvbiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGVtcG9yYWxHcmFudWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwOy8vQXJyYXkuZnJvbSh0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAua2V5cygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZSB2YWx1ZXMgd2VyZSBnaXZlbiwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEByZXR1cm5zIHtib29lbGFufSAtIHRydWUgaWYgdGhlIHRlbXBvcmFsIGdyYW51bGUgdmFsdWVzIHdlcmUgZ2l2ZW4sIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIHRlbXBvcmFsIGdyYW51bGVzIGNyZWF0aW5nIGFuIGFycmF5IHdpdGggdGhvc2Ugc29ydGVkIGVsZW1lbnRzLlxyXG4gICAgICogSWYgdGhlIGVsZW1lbnRzIGFyZSBkYXRlcyB0aGVuIG9yZGVyIGJ5IGRhdGUsIGlmIHRoZXkgYXJlIG51bWJlcnMgb3JkZXIgYnkgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3xudW1iZXI+fSAtIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMsIHNvcnRlZCBieSBkYXRlL251bWJlci5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgc29ydFRlbXBvcmFsR3JhbnVsZXMoKSB7XHJcbiAgICAgICAgbGV0IGF2YWlsYWJsZUdyYW51bGFyaXRlcyA9IHRoaXMuX2dldEF2YWlsYWJsZUdyYW51bGFyaXRpZXMoKTtcclxuICAgICAgICBsZXQgdGdzID0gdGhpcy5nZXRUZW1wb3JhbEdyYW51bGVzKCkua2V5cygpO1xyXG4gICAgICAgIGxldCBncmFudWxhcml0aWVzQXJyYXkgPSBbXTsgLy8gXHJcbiAgICAgICAgbGV0IHN0clRvVEdNYXAgPSBuZXcgTWFwKCk7IC8vIDI2XzFfMCA9PiAxIEphbnVhcnkgMjAxNlxyXG4gICAgICAgIGZvciAoY29uc3QgdGcgb2YgdGdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHJHcmFudWxhcml0eTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdyYW51bGFyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGF2YWlsYWJsZUdyYW51bGFyaXRlc1sxXTogLy9Nb250aFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ckdyYW51bGFyaXR5ID0gdGhpcy5fZ2V0TW9udGgodGcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBhdmFpbGFibGVHcmFudWxhcml0ZXNbMl06IC8vRGF5XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyR3JhbnVsYXJpdHkgPSB0aGlzLl9nZXREYXkodGcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBzdHJHcmFudWxhcml0eSA9IHRnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyYW51bGFyaXRpZXNBcnJheS5wdXNoKHN0ckdyYW51bGFyaXR5KTtcclxuICAgICAgICAgICAgc3RyVG9UR01hcC5zZXQoc3RyR3JhbnVsYXJpdHksIHRnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdHJUb1RlbXBvcmFsR3JhbnVsZU1hcCA9IHN0clRvVEdNYXA7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyID0gZ3JhbnVsYXJpdGllc0FycmF5LnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIG5ldyBEYXRlKGEpIC0gbmV3IERhdGUoYik7IH0pO1xyXG4gICAgICAgIGZvciAobGV0IFtpLCBzb3J0ZWRUR10gb2YgdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgdGhpcy5zb3J0ZWRUR3NUb0luZGV4TWFwLnNldChzb3J0ZWRURywgaSk7XHJcbiAgICAgICAgLyogICBjb25zb2xlLndhcm4odGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyKTtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnN0clRvVGVtcG9yYWxHcmFudWxlTWFwKTtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXApOyAqL1xyXG4gICAgICAgIHRoaXMuX3NvcnRUZW1wb3JhbEdyYW51bGVzTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0FycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIHRlbXBvcmFsIGdyYW51bGVzIHN0cmluZ3MgKHJlYWQgZnJvbSBmaWxlKSB0byB0aGUgaW5kaWNlcyBvZiB0aGUgc29ydGVkXHJcbiAgICAgKiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9zb3J0VGVtcG9yYWxHcmFudWxlc01hcCgpIHtcclxuICAgICAgICBsZXQgc29ydGVkSW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbGV0IHNvcnRlZFRHc1RvSW5kZXhNYXAgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXA7IC8vSmFudWFyeSAyMDE3IC0+IDAsIEZlYnJ1YXJ5IDIwMTcgLT4gMVxyXG4gICAgICAgIGxldCBzdHJUb1RHTWFwID0gdGhpcy5zdHJUb1RlbXBvcmFsR3JhbnVsZU1hcDsgLy9KYW51YXJ5IDIwMTcgLT4gMjAxN18xLCBGZWJydWFyeSAyMDE3IC0+IDIwMTdfMlxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzb3J0ZWRUR3NUb0luZGV4TWFwLmtleXMoKSlcclxuICAgICAgICAgICAgc29ydGVkSW5kZXhNYXAuc2V0KHN0clRvVEdNYXAuZ2V0KGtleSksIHNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGtleSkpOyAvLzIwMTdfMSAtPiAwXHJcbiAgICAgICAgdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwID0gc29ydGVkSW5kZXhNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbGUgbW9udGggc3RyaW5nLiBcclxuICAgICAqIEluIHBvcnR1Z2FsIHdpbGwgcmV0dXJuICdqYW5laXJvJywgJ2ZldmVyZWlybycgZXRjLi4uIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHJpbmcgLSBUaGUgZGF0ZSBzdHJpbmcgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbG9jYWxlIG1vbnRoIHN0cmluZy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODY0ODMxNC9cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgX2dldExvY2FsZU1vbnRoKGRhdGVTdHJpbmcpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcucmVwbGFjZSgvXy9nLCAnLScpKTtcclxuICAgICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLXVzXCIsIHsgbW9udGg6IFwibG9uZ1wiIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW9udGggbmFtZSBwbHVzIHRoZSB5ZWFyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHJpbmcgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBtb250aCBuYW1lIHBsdXMgdGhlIHllYXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXRNb250aChkYXRlU3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nLnJlcGxhY2UoL18vZywgJy0nKSk7XHJcbiAgICAgICAgbGV0IG1vbnRoTmFtZSA9IHRoaXMuX2dldExvY2FsZU1vbnRoKGRhdGVTdHJpbmcpO1xyXG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIHJldHVybiBtb250aE5hbWUgKyBcIiBcIiArIHllYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRhdGUgaW5jbHVkaW5nIHRoZSBkYXkgKGRheSBtb250aCB5ZWFyKS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyaW5nIC0gVGhlIGRhdGUgc3RyaW5nIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGRhdGUgaW5jbHVkaW5nIHRoZSBkYXkuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODY0ODMxNC9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXREYXkoZGF0ZVN0cmluZykge1xyXG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZy5yZXBsYWNlKC9fL2csICctJykpO1xyXG4gICAgICAgIGxldCBtb250aE5hbWUgPSB0aGlzLl9nZXRMb2NhbGVNb250aChkYXRlU3RyaW5nKTtcclxuICAgICAgICBsZXQgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICAgICAgbGV0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGRheSArIFwiIFwiICsgbW9udGhOYW1lICsgXCIgXCIgKyB5ZWFyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHRlbXBvcmFsIGdyYW51bGUgZ2l2ZW4gYnkgdGhlIHN0cmluZy4gXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRlbXBvcmFsZ3JhbnVsZVN0ciAtIFRoZSB0ZW1wb3JhbCBncmFudWxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlIGdpdmVuIGJ5IHRoZSBzdHJpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdyYW51bGVJbmRleEZyb21TdHIodGVtcG9yYWxncmFudWxlU3RyKSB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuc3RyVG9UZW1wb3JhbEdyYW51bGVNYXAuZ2V0KHRlbXBvcmFsZ3JhbnVsZVN0cik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcG9yYWxHcmFudWxlc01hcC5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgZ2l2ZW4gc3RyaW5nIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIHRlbXBvcmFsIGdyYW51bGUgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRUR01hcEluZGV4KHN0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAuZ2V0KHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMuIFxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3xudW1iZXI+fSAtIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMuICBcclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0U29ydGVkVGVtcG9yYWxHcmFudWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdGVtcG9yYWwgZ3JhbnVsZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdCBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSAtIHRoZSBmaXJzdCB0ZW1wb3JhbCBncmFudWxlIGZyb20gdGhlIHNvcnRlZCBsaXN0IG9mIHRlbXBvcmFsIGdyYW51bGVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRGaXJzdFRlbXBvcmFsR3JhbnVsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kaWNlcyBvZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB0ZW1wb3JhbCBncmFudWxlcyBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxyXG4gICAgICogQHBhcmFtIHthbnl9IHN0YXJ0VEdTdHIgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZSBzdGFydCB0ZW1wb3JhbCBncmFudWxlLiBcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbmRUR1N0ciAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJhbmdlIGVuZCB0ZW1wb3JhbCBncmFudWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBpbmRpY2VzIG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBiZXR3ZWVuIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIHRlbXBvcmFsIGdyYW51bGVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRSYW5nZUluZGljZXMoc3RhcnRUR1N0ciwgZW5kVEdTdHIpIHtcclxuICAgICAgICBsZXQgW3NvcnRlZFN0YXJ0SW5kZXgsIHNvcnRlZEVuZEluZGV4XSA9IFt0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KHN0YXJ0VEdTdHIpLCB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGVuZFRHU3RyKV07XHJcbiAgICAgICAgbGV0IHNvcnRlZFRHc0FyclNsaWNlZCA9IHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0Fyci5zbGljZShzb3J0ZWRTdGFydEluZGV4LCBzb3J0ZWRFbmRJbmRleCArIDEpO1xyXG4gICAgICAgIGxldCByYW5nZUluZGljZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBzb3J0ZWRURyBvZiBzb3J0ZWRUR3NBcnJTbGljZWQpXHJcbiAgICAgICAgICAgIHJhbmdlSW5kaWNlcy5wdXNoKHRoaXMuZ2V0R3JhbnVsZUluZGV4RnJvbVN0cihzb3J0ZWRURykpO1xyXG4gICAgICAgIHJldHVybiByYW5nZUluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gdGVtcG9yYWwgZ3JhbnVsZSBzdHJpbmcvbnVtYmVyLiBcclxuICAgICAqIFRoZSBpbmRleCBpcyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoICB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzb3J0ZWRUZW1wb3JhbEdyYW51bGUgLSBUaGUgdGVtcG9yYWwgZ3JhbnVsZSBzdHJpbmcvbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUgc3RyaW5nL251bWJlci4gXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFNvcnRlZEluZGV4RnJvbVN0cihzb3J0ZWRUZW1wb3JhbEdyYW51bGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUR3NUb0luZGV4TWFwLmdldChzb3J0ZWRUZW1wb3JhbEdyYW51bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5leHQgdGVtcG9yYWwgZ3JhbnVsZSBvbiB0aGUgXCJ0aW1lbGluZVwiLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjdXJyZW50VEcgLSBUaGUgY3VycmVudCB0ZW1wb3JhbCBncmFudWxlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIG5leHQgdGVtcG9yYWwgZ3JhbnVsZSBvbiB0aGUgXCJ0aW1lbGluZVwiLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBmaW5kTmV4dFRHSW5kZXgoY3VycmVudFRHKSB7XHJcbiAgICAgICAgbGV0IGluZGV4U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGN1cnJlbnRURyk7XHJcbiAgICAgICAgbGV0IGxhc3RURyA9IHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0Fyci5sZW5ndGggLSAxO1xyXG4gICAgICAgIGxldCBuZXh0U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRlbXBvcmFsR3JhbnVsZXNBcnJbaW5kZXhTb3J0ZWRURyA8IGxhc3RURyA/IGluZGV4U29ydGVkVEcgKyAxIDogaW5kZXhTb3J0ZWRUR107IC8vQXZvaWQgaXQgZ29pbmcgb3ZlciB0aGUgbGFzdCBpbmRleFxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlZEluZGV4RnJvbVN0cihuZXh0U29ydGVkVEcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRlbXBvcmFsIGdyYW51bGUgb24gdGhlIFwidGltZWxpbmVcIi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY3VycmVudFRHIC0gVGhlIGN1cnJlbnQgdGVtcG9yYWwgZ3JhbnVsZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBwcmV2aW91cyB0ZW1wb3JhbCBncmFudWxlIG9uIHRoZSBcInRpbWVsaW5lXCIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRQcmV2aW91c1RHSW5kZXgoY3VycmVudFRHKSB7XHJcbiAgICAgICAgbGV0IGluZGV4U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGN1cnJlbnRURyk7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzVEcgPSB0aGlzLnNvcnRlZFRlbXBvcmFsR3JhbnVsZXNBcnJbaW5kZXhTb3J0ZWRURyA+PSAxID8gaW5kZXhTb3J0ZWRURyAtIDEgOiBpbmRleFNvcnRlZFRHXTsgLy9Bdm9pZCBpdCBnb2luZyBiZWxsb3cgMFxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlZEluZGV4RnJvbVN0cihwcmV2aW91c1RHKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgYXJlIG51bWJlcnMuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBhcmUgbnVtYmVycywgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgdGVtcG9yYWxHcmFudWxlc0FyZU51bWJlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEdpc3BsYXlEZWZhdWx0cy5pc051bWJlcih0aGlzLmdldEZpcnN0VGVtcG9yYWxHcmFudWxlKCkpOy8vdHlwZW9mIHRoaXMuZ2V0Rmlyc3RUZW1wb3JhbEdyYW51bGUoKSA9PT0gJ251bWJlcic7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL1RpbWVWYXJpYWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7OztBQUtBOzs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUZBO0FBQ0E7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7QUFJQTtBQTlDQTtBQStDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQUE7QUFBQTtBQXRCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBOzs7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7OztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/VVs/URLVariable.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Represents the url variable that is given by the programmer in the parsing options.\r\n * @export\r\n * @class URLVariable\r\n */\nvar URLVariable = exports.URLVariable = function () {\n    /**\r\n     * Creates an instance of URLVariable.\r\n     * @param {File|string} dataURL - URL of the data to read.  \r\n     * @param {File|string} geoSpatialURL - URL of the geometry and identifiers to read.\r\n     * @param {string} idOnDataURL - The id of the geometry in the data URL.\r\n     * @param {string} idOnGeoSpatialURL - The id of the geometry in the geospatial URL.\r\n     * @memberof URLVariable\r\n     */\n    function URLVariable(dataURL, geoSpatialURL, idOnDataURL, idOnGeoSpatialURL) {\n        _classCallCheck(this, URLVariable);\n\n        /**\r\n         * The data url file handler.\r\n         * @type {File|URL}\r\n         */\n        this.dataURL = dataURL;\n        /**\r\n         * The geospatial url file handler.\r\n         * @type {File|URL}\r\n         */\n        this.geoSpatialURL = geoSpatialURL;\n        /**\r\n         * The id of the geometry on the data url.\r\n         * @type {string}\r\n         */\n        this.idOnDataURL = idOnDataURL;\n        /**\r\n         * The id of the geometry on the geospatial url. \r\n         * @type {string}\r\n         */\n        this.idOnGeoSpatialURL = idOnGeoSpatialURL;\n    }\n\n    /**\r\n     * Returns the data URL.\r\n     * @returns {File|URL} - The data URL.\r\n     * @memberof URLVariable\r\n     */\n\n\n    _createClass(URLVariable, [{\n        key: 'getDataURL',\n        value: function getDataURL() {\n            return this.dataURL;\n        }\n\n        /**\r\n         * Returns the name of the data URL.\r\n         * @returns {string} - the name of the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getDataName',\n        value: function getDataName() {\n            return this.dataURL instanceof URL ? this.dataURL.href : this.dataURL.name;\n        }\n\n        /**\r\n         * Returns the size in bytes of the data URL.\r\n         * @returns {number} - the size in bytes of the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getDataSize',\n        value: function getDataSize() {\n            return this.dataURL instanceof URL ? 0 : this.dataURL.size;\n        }\n\n        /**\r\n         * Returns the geoSpatial URL.\r\n         * @returns {File|URL} - the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeoSpatialURL',\n        value: function getGeoSpatialURL() {\n            return this.geoSpatialURL;\n        }\n\n        /**\r\n         * Returns the name of the geospatial URL.\r\n         * @returns {string} - the name of the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeospatialName',\n        value: function getGeospatialName() {\n            return this.geoSpatialURL instanceof URL ? this.geoSpatialURL.href : this.geoSpatialURL.name;\n        }\n\n        /**\r\n         * Returns the size in bytes of the geospatial URL.\r\n         * @returns {number} - the size in bytes of the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeospatialSize',\n        value: function getGeospatialSize() {\n            return this.geoSpatialURL instanceof URL ? 0 : this.geoSpatialURL.size;\n        }\n\n        /**\r\n         * Returns the id of the geometry in the data URL.\r\n         * @returns {string} - the id of the geometry in the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getIdOnDataURL',\n        value: function getIdOnDataURL() {\n            return this.idOnDataURL;\n        }\n\n        /**\r\n         * Returns the id of the geometry in the geospatial URL.\r\n         * @returns {string} - the id of the geometry in the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getIdOnGeoSpatialURL',\n        value: function getIdOnGeoSpatialURL() {\n            return this.idOnGeoSpatialURL;\n        }\n\n        /**\r\n         * Returns true if the data file is a geojson file. \r\n         * @returns {boolean} - true, if the data file is a geojson file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'dataURLisGeoJSON',\n        value: function dataURLisGeoJSON() {\n            return this._isGeoJSON(this.getDataName());\n        }\n\n        /**\r\n         * Returns true if the dataURL is an instance of URL.\r\n         * @returns {boolean} - true if the dataURL is an instance of URL, false, otherwise\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'dataURLisRemote',\n        value: function dataURLisRemote() {\n            return this.dataURL instanceof URL;\n        }\n\n        /**\r\n         * Returns true if the data URL is a remote file. \r\n         * @returns {boolean} - true, if the data URL is a remote file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'geoSpatialURLisGeoJSON',\n        value: function geoSpatialURLisGeoJSON() {\n            return this.geoSpatialURL !== undefined && this._isGeoJSON(this.getGeospatialName());\n        }\n\n        /**\r\n         * Returns true if the geospatial URL is a remote file. \r\n         * @returns {boolean} - true, if the geospatial URL is a remote file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'geoSpatialURLisRemote',\n        value: function geoSpatialURLisRemote() {\n            return this.geoSpatialURL instanceof URL;\n        }\n\n        /**\r\n         * Verifies if the given name is a GeoJSON file.\r\n         * @param {string} name - The name of the file. \r\n         * @returns {boolean} - true, if it's a geojson file, false, otherwise.\r\n         * @private\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: '_isGeoJSON',\n        value: function _isGeoJSON(name) {\n            return name.endsWith('.json') || name.endsWith('.geojson');\n        }\n\n        /**\r\n         * Returns true, if both ids exist, false otherwise.\r\n         * @returns {boolean} - true, if both ids exist, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'hasIds',\n        value: function hasIds() {\n            return this.idOnDataURL !== undefined && this.idOnGeoSpatialURL !== undefined;\n        }\n    }]);\n\n    return URLVariable;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvVVJMVmFyaWFibGUuanM/YmJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHVybCB2YXJpYWJsZSB0aGF0IGlzIGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyIGluIHRoZSBwYXJzaW5nIG9wdGlvbnMuXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFVSTFZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVVJMVmFyaWFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFVSTFZhcmlhYmxlLlxyXG4gICAgICogQHBhcmFtIHtGaWxlfHN0cmluZ30gZGF0YVVSTCAtIFVSTCBvZiB0aGUgZGF0YSB0byByZWFkLiAgXHJcbiAgICAgKiBAcGFyYW0ge0ZpbGV8c3RyaW5nfSBnZW9TcGF0aWFsVVJMIC0gVVJMIG9mIHRoZSBnZW9tZXRyeSBhbmQgaWRlbnRpZmllcnMgdG8gcmVhZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZE9uRGF0YVVSTCAtIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkT25HZW9TcGF0aWFsVVJMIC0gVGhlIGlkIG9mIHRoZSBnZW9tZXRyeSBpbiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAbWVtYmVyb2YgVVJMVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YVVSTCwgZ2VvU3BhdGlhbFVSTCwgaWRPbkRhdGFVUkwsIGlkT25HZW9TcGF0aWFsVVJMKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRhdGEgdXJsIGZpbGUgaGFuZGxlci5cclxuICAgICAgICAgKiBAdHlwZSB7RmlsZXxVUkx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhVVJMID0gZGF0YVVSTDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZ2Vvc3BhdGlhbCB1cmwgZmlsZSBoYW5kbGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtGaWxlfFVSTH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdlb1NwYXRpYWxVUkwgPSBnZW9TcGF0aWFsVVJMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgb24gdGhlIGRhdGEgdXJsLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZE9uRGF0YVVSTCA9IGlkT25EYXRhVVJMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgb24gdGhlIGdlb3NwYXRpYWwgdXJsLiBcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWRPbkdlb1NwYXRpYWxVUkwgPSBpZE9uR2VvU3BhdGlhbFVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHJldHVybnMge0ZpbGV8VVJMfSAtIFRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhVVJMKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFVUkw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFVUkwgaW5zdGFuY2VvZiBVUkwgPyB0aGlzLmRhdGFVUkwuaHJlZiA6IHRoaXMuZGF0YVVSTC5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBpbiBieXRlcyBvZiB0aGUgZGF0YSBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBzaXplIGluIGJ5dGVzIG9mIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVVJMIGluc3RhbmNlb2YgVVJMID8gMCA6IHRoaXMuZGF0YVVSTC5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2VvU3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7RmlsZXxVUkx9IC0gdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdlb1NwYXRpYWxVUkwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbmFtZSBvZiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAbWVtYmVyb2YgVVJMVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0R2Vvc3BhdGlhbE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTCBpbnN0YW5jZW9mIFVSTCA/IHRoaXMuZ2VvU3BhdGlhbFVSTC5ocmVmIDogdGhpcy5nZW9TcGF0aWFsVVJMLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIGluIGJ5dGVzIG9mIHRoZSBnZW9zcGF0aWFsIFVSTC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgaW4gYnl0ZXMgb2YgdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdlb3NwYXRpYWxTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb1NwYXRpYWxVUkwgaW5zdGFuY2VvZiBVUkwgPyAwIDogdGhpcy5nZW9TcGF0aWFsVVJMLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaWQgb2YgdGhlIGdlb21ldHJ5IGluIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRJZE9uRGF0YVVSTCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE9uRGF0YVVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBnZW9tZXRyeSBpbiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldElkT25HZW9TcGF0aWFsVVJMKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkT25HZW9TcGF0aWFsVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRhIGZpbGUgaXMgYSBnZW9qc29uIGZpbGUuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwgaWYgdGhlIGRhdGEgZmlsZSBpcyBhIGdlb2pzb24gZmlsZSwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBkYXRhVVJMaXNHZW9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0dlb0pTT04odGhpcy5nZXREYXRhTmFtZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0YVVSTCBpcyBhbiBpbnN0YW5jZSBvZiBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBkYXRhVVJMIGlzIGFuIGluc3RhbmNlIG9mIFVSTCwgZmFsc2UsIG90aGVyd2lzZVxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGRhdGFVUkxpc1JlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVVJMIGluc3RhbmNlb2YgVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRhIFVSTCBpcyBhIHJlbW90ZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBkYXRhIFVSTCBpcyBhIHJlbW90ZSBmaWxlLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdlb1NwYXRpYWxVUkxpc0dlb0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzR2VvSlNPTih0aGlzLmdldEdlb3NwYXRpYWxOYW1lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnZW9zcGF0aWFsIFVSTCBpcyBhIHJlbW90ZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBnZW9zcGF0aWFsIFVSTCBpcyBhIHJlbW90ZSBmaWxlLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdlb1NwYXRpYWxVUkxpc1JlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9TcGF0aWFsVVJMIGluc3RhbmNlb2YgVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIG5hbWUgaXMgYSBHZW9KU09OIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIGl0J3MgYSBnZW9qc29uIGZpbGUsIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9pc0dlb0pTT04obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lLmVuZHNXaXRoKCcuanNvbicpIHx8IG5hbWUuZW5kc1dpdGgoJy5nZW9qc29uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUsIGlmIGJvdGggaWRzIGV4aXN0LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlLCBpZiBib3RoIGlkcyBleGlzdCwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBoYXNJZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPbkRhdGFVUkwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlkT25HZW9TcGF0aWFsVVJMICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL1VSTFZhcmlhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/* no static exports found */
/* all exports used */
/*!**************************************************************************************************!*\
  !*** ./~/babel-loader/lib?{"presets":["es2015"]}!./src/Gisplay/Parser/CSV/File/CSVFileWorker.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable = __webpack_require__(/*! ../../../VVs/DataVariable */ 1);\n\nvar _URLVariable = __webpack_require__(/*! ../../../VVs/URLVariable */ 7);\n\nvar _TimeVariable = __webpack_require__(/*! ../../../VVs/TimeVariable */ 6);\n\nvar _CategoricalVariable = __webpack_require__(/*! ../../../VVs/CategoricalVariable */ 3);\n\nvar _ContinuousVariable = __webpack_require__(/*! ../../../VVs/ContinuousVariable */ 5);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../../../GisplayDefaults */ 0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar worker = self;\n\nvar CSVFileWorker = function () {\n    function CSVFileWorker() {\n        var _this = this;\n\n        _classCallCheck(this, CSVFileWorker);\n\n        // console.log(\"-------------------CSV Data Worker-------------------\");\n        /**\r\n         * The first row read by this data worker.\r\n         * @type {string}\r\n         */\n        this.firstWorkerRow = '';\n        /**\r\n         * The last row of the last chunk read by the parser.\r\n         * @type {string}\r\n         */\n        this.lastWorkerRow = '';\n        /**\r\n         * Save the remaining of the last row from the chunk that was read.\r\n         * It's used when a chunk didn't end in a row delimitir character.\r\n         * @type {string}\r\n         */\n        this.remainingChunkRow = '';\n\n        /**\r\n         * The data file.\r\n         * @type {File}\r\n         */\n        this.dataFile = null;\n        /**\r\n         * The start byte for this worker.\r\n         * @type {number}\r\n         */\n        this.startByte = 0;\n        /**\r\n         * The end byte for this worker.\r\n         * @type {number}\r\n         */\n        this.endByte = 0;\n        /**\r\n         * The size of each chunk to read from the file.\r\n         * @type {number}\r\n         */\n        this.chunkSize = 0;\n        /**\r\n         * The index of this worker. DELETE?\r\n         * @type {number}\r\n         */\n        this.workerIndex = -1;\n        /**\r\n         * Number of columns for each row. DELETE?\r\n         * @type {number}\r\n         */\n        this.numColumnsPerRow = -1; //NOT USED ATM\n\n        /**\r\n         * The row delimiter.\r\n         * @type {string}\r\n         */\n        this.rowDelimiter = '';\n        /**\r\n         * The column delimiter.\r\n         * @type {string}\r\n         */\n        this.columnDelimiter = '';\n\n        /**\r\n         * The header indices. \r\n         * The array is split into 5 positions: [0]categorical, [1]continuous, [2]geometry, [3]time and [4]optional variables. \r\n         * @type {Array<Array<number>>}\r\n         */\n        this.headerIndices = [];\n\n        //TIME \n        /**\r\n         * The time variable.\r\n         * @type {TimeVariable}\r\n         */\n        this.timeVariable = null;\n        /**\r\n         * The granularity of the time variable.\r\n         * @type {string}\r\n         */\n        this.timeGranularity = '';\n\n        //CATEGORICAL\n        /**\r\n         * The categorical variables present in the user options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\n        this.categoricalVariables = [];\n        /**\r\n         * If the options contain any categorical variable.\r\n         * @type {boolean}\r\n         */\n        this.hasCategoricalVariables = false;\n\n        //CONTINUOUS\n        /**\r\n         * The continuous variables.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\n        this.continuousVariables = [];\n\n        //OPTIONAL\n        /**\r\n         * The optional variables.\r\n         * @type {Array<DataVariable>}\r\n         */\n        this.optionalVariables = [];\n\n        /**\r\n         * The FileReader used to read a portion of the file.\r\n         * @type {FileReader}\r\n         */\n        this.reader = this.createFileReader();\n        worker.onmessage = function (e) {\n            _this.onMessage(e.data);\n        };\n\n        //SAVE INFORMATION\n        /**\r\n         * Used to save the rows directly read from the file\r\n         * @type {Array<Array<string|number>>}\r\n         */\n        this.dataRowsSaved = []; //Save rows read by this Worker\n        /**\r\n         * The final data rows which contain all information to be sent to the main thread.\r\n         * @type {Array<Array<{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}>>}\r\n         */\n        this.finalDataRows = [];\n        // this.numRowsRead = 0;\n\n        /** \r\n         * Will be true when we want to process the last line.\r\n         * @type {boolean}\r\n         */\n        this.isLastLine = false;\n    }\n\n    /**\r\n     * Create file reader.\r\n     * @returns {FileReader} - the FileReader used to read a portion of the file.\r\n     * @memberof CSVDataWorker\r\n     */\n\n\n    _createClass(CSVFileWorker, [{\n        key: \"createFileReader\",\n        value: function createFileReader() {\n            var _this2 = this;\n\n            var reader = new FileReader();\n            reader.onload = function (e) {\n                _this2.chunkReadFromFile(e);\n            };\n            reader.onerror = function (e) {\n                console.error(e);\n            };\n            return reader;\n        }\n\n        /**\r\n         * When the worker receives a message. \r\n         * @param {{protocolMessage: string, messageData:Object}} dataMessage - The data message that was sent by the main Thread.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"onMessage\",\n        value: function onMessage(dataMessage) {\n            // console.log(\"-------------------CSV Data Worker-------------------\");\n            // console.log(dataMessage);\n            var protocolMessages = _GisplayDefaults.GisplayDefaults.MESSAGES_CSV();\n            switch (dataMessage.protocolMessage) {\n                case protocolMessages.TO_START:\n                    {\n                        //Worker processed it's part\n                        //File and chunk information\n                        var workerOptions = dataMessage.messageData.workerOptions;\n                        this.dataFile = workerOptions.dataFile;\n                        this.startByte = workerOptions.startByte;\n                        this.endByte = workerOptions.endByte;\n                        this.chunkSize = workerOptions.chunkSize;\n                        this.workerIndex = workerOptions.workerIndex;\n                        this.numColumnsPerRow = workerOptions.numColumnsPerRow;\n                        this.rowDelimiter = workerOptions.rowDelimiter;\n                        this.columnDelimiter = workerOptions.columnDelimiter;\n                        //Indices and class calc\n                        this.headerIndices = workerOptions.headerIndices;\n                        //Save Categorical/Continuous and time Vars\n                        this._saveVariables(dataMessage.messageData.workerOptions);\n                        //Start reading file\n                        this.readNextChunk();\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT:\n                    {\n                        console.log(\"TO_LIMIT_CAT\");\n                        var catVarsCategoriesMap = new Map();\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = this.categoricalVariables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var catVar = _step.value;\n\n                                catVarsCategoriesMap.set(catVar.getInternalName(), catVar.getCategories());\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        var contVarsMinMaxMap = new Map();\n                        var _iteratorNormalCompletion2 = true;\n                        var _didIteratorError2 = false;\n                        var _iteratorError2 = undefined;\n\n                        try {\n                            for (var _iterator2 = this.continuousVariables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                var contVar = _step2.value;\n\n                                contVarsMinMaxMap.set(contVar.getInternalName(), [contVar.getMin(), contVar.getMax()]);\n                            } // console.log(this.workerIndex, catVarsCategoriesMap, contVarsMinMaxMap, this.timeVariable, this.timeVariable.getTemporalGranulesSet())\n                        } catch (err) {\n                            _didIteratorError2 = true;\n                            _iteratorError2 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                    _iterator2.return();\n                                }\n                            } finally {\n                                if (_didIteratorError2) {\n                                    throw _iteratorError2;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT,\n                            messageData: {\n                                categoricalVariables: catVarsCategoriesMap,\n                                continousVariables: contVarsMinMaxMap,\n                                timeVariable: this.timeVariable ? this.timeVariable.getTemporalGranulesSet() : this.timeVariable\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT_RES:\n                    {\n                        var continousVarsMinMax = dataMessage.messageData;\n                        var _iteratorNormalCompletion3 = true;\n                        var _didIteratorError3 = false;\n                        var _iteratorError3 = undefined;\n\n                        try {\n                            for (var _iterator3 = this.continuousVariables.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                                var _step3$value = _slicedToArray(_step3.value, 2),\n                                    i = _step3$value[0],\n                                    _contVar = _step3$value[1];\n\n                                _contVar.setMinMax(continousVarsMinMax[i][0]);\n                                _contVar.setMinMax(continousVarsMinMax[i][1]);\n                                _contVar.setStep(); //Update step value\n                            }\n\n                            //Loop through data and calculate bins for each continuous variable\n                        } catch (err) {\n                            _didIteratorError3 = true;\n                            _iteratorError3 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                    _iterator3.return();\n                                }\n                            } finally {\n                                if (_didIteratorError3) {\n                                    throw _iteratorError3;\n                                }\n                            }\n                        }\n\n                        var contPosStart = this.categoricalVariables.length;\n                        var contPosEnd = contPosStart + this.continuousVariables.length;\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = undefined;\n\n                        try {\n                            for (var _iterator4 = this.dataRowsSaved[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                                var data = _step4.value;\n\n                                for (var i = contPosStart; i < contPosEnd; i++) {\n                                    this.continuousVariables[i - contPosStart].addValueToBins(data[i]);\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError4 = true;\n                            _iteratorError4 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                    _iterator4.return();\n                                }\n                            } finally {\n                                if (_didIteratorError4) {\n                                    throw _iteratorError4;\n                                }\n                            }\n                        }\n\n                        var histograms = [];\n                        var _iteratorNormalCompletion5 = true;\n                        var _didIteratorError5 = false;\n                        var _iteratorError5 = undefined;\n\n                        try {\n                            for (var _iterator5 = this.continuousVariables[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                                var _contVar2 = _step5.value;\n\n                                histograms.push(_contVar2.getHistogram());\n                            } // console.log(this.continuousVariables[0].getHistogram());\n                        } catch (err) {\n                            _didIteratorError5 = true;\n                            _iteratorError5 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                    _iterator5.return();\n                                }\n                            } finally {\n                                if (_didIteratorError5) {\n                                    throw _iteratorError5;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT_RES,\n                            messageData: {\n                                histograms: histograms\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_JOIN_DATA:\n                    {\n                        //Process data and then send the res data\n                        if (this.workerIndex === 0) {\n                            console.log(\"I will process the data....NOT\");\n                            console.log(dataMessage.messageData);\n                        }\n\n                        var catVars = dataMessage.messageData.categoricalVariables;\n                        var _iteratorNormalCompletion6 = true;\n                        var _didIteratorError6 = false;\n                        var _iteratorError6 = undefined;\n\n                        try {\n                            for (var _iterator6 = catVars.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                                var _step6$value = _slicedToArray(_step6.value, 2),\n                                    _i2 = _step6$value[0],\n                                    _catVar = _step6$value[1];\n\n                                this.categoricalVariables[_i2].valueToIndexMap = _catVar.valueToIndexMap;\n                            }\n                        } catch (err) {\n                            _didIteratorError6 = true;\n                            _iteratorError6 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                    _iterator6.return();\n                                }\n                            } finally {\n                                if (_didIteratorError6) {\n                                    throw _iteratorError6;\n                                }\n                            }\n                        }\n\n                        var contVars = dataMessage.messageData.continuousVariables;\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = undefined;\n\n                        try {\n                            for (var _iterator7 = contVars.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                var _step7$value = _slicedToArray(_step7.value, 2),\n                                    _i3 = _step7$value[0],\n                                    _contVar3 = _step7$value[1];\n\n                                this.continuousVariables[_i3].classIntervals = _contVar3.classIntervals;\n                            }\n                        } catch (err) {\n                            _didIteratorError7 = true;\n                            _iteratorError7 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                    _iterator7.return();\n                                }\n                            } finally {\n                                if (_didIteratorError7) {\n                                    throw _iteratorError7;\n                                }\n                            }\n                        }\n\n                        var tVar = dataMessage.messageData.timeVariable;\n                        if (tVar) this.timeVariable.temporalGranulesMap = tVar.temporalGranulesMap;\n\n                        var msgData = dataMessage.messageData;\n                        var mvcs = msgData.mvcs,\n                            numberMVCs = mvcs.size,\n                            numberTGs = msgData.numberTGs;\n                        this._joinData(mvcs, numberTGs);\n\n                        var numTotalElements = 0; //Create array to send information about this worker\n                        console.error(this.finalDataRows);\n                        /*    if (this.continuousVariables.length > 0) {\r\n                               for (let i = 0; i < numberMVCs; i++)\r\n                                   for (let j = 0; j < numberTGs; j++)\r\n                                       numTotalElements += this.finalDataRows[i][j].continuousData[0].length;\r\n                           } else {\r\n                               // throw new Error(\"\"); */\n                        for (var _i = 0; _i < numberMVCs; _i++) {\n                            for (var j = 0; j < numberTGs; j++) {\n                                if (this.headerIndices[2].length) numTotalElements += this.finalDataRows[_i][j].spatialData.length / 2; //Lat/Lng\n                                else numTotalElements += this.finalDataRows[_i][j].spatialData.length; //Ids\n                            }\n                        }\n                        // }\n                        console.warn(numTotalElements);\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_JOIN_DATA,\n                            messageData: {\n                                numTotalElements: numTotalElements,\n                                workerIndex: this.workerIndex\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_GENERATE_RGBA:\n                    {\n                        // Should Generate RGBAs for all MVCs/TGs \n                        this._generateRGBACodes(dataMessage.messageData);\n                        worker.postMessage({ protocolMessage: protocolMessages.END_GENERATE_RGBA });\n                        break;\n                    }\n                case protocolMessages.TO_SEND_DATA:\n                    {\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_SEND_DATA,\n                            messageData: {\n                                finalDataRows: this.finalDataRows\n                            }\n                        });\n                        break;\n                    }\n            }\n        }\n\n        /**\r\n         * Generate RGBA codes for each element in each MVC/TG.\r\n         * @param {Array<Array<number>} startRGBANum - The start RGBA number for this worker.. \r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: \"_generateRGBACodes\",\n        value: function _generateRGBACodes(startRGBANum) {\n            var numMVCs = this.finalDataRows.length,\n                numTGs = this.finalDataRows[0].length;\n            for (var i = 0; i < numMVCs; i++) {\n                // let startRGBA = startingRGBANumber[i],\n                // let startRGBANum = GisplayDefaults.RGBAToNumber(...startRGBA);\n                for (var j = 0; j < numTGs; j++) {\n                    var numberOfElements = 0;\n                    if (this.headerIndices[2].length) numberOfElements = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else numberOfElements = this.finalDataRows[i][j].spatialData.length; //Ids\n                    // let continuousDataLength = this.finalDataRows[i][j].continuousData[0].length; //Using continuous data that might not exist\n                    if (numberOfElements > 0) {\n                        for (var k = 0; k < numberOfElements; k++) {\n                            var _finalDataRows$i$j$RG;\n\n                            var RGBA = _GisplayDefaults.GisplayDefaults.numberToRGBA(startRGBANum);\n                            (_finalDataRows$i$j$RG = this.finalDataRows[i][j].RGBA).push.apply(_finalDataRows$i$j$RG, _toConsumableArray(RGBA));\n                            this.finalDataRows[i][j].numberRGBA.push(startRGBANum++);\n                        }\n                    }\n                }\n            }\n            this.verifyIntegrityRGBA(numMVCs, numTGs);\n        }\n    }, {\n        key: \"verifyIntegrityRGBA\",\n        value: function verifyIntegrityRGBA(numMVCs, numTGs) {\n            // console.warn(\"VERIFY INTEGRITY\")\n            for (var i = 0; i < numMVCs; i++) {\n                for (var j = 0; j < numTGs; j++) {\n                    var continuousDataLength = 0;\n                    if (this.headerIndices[2].length) continuousDataLength = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else continuousDataLength = this.finalDataRows[i][j].spatialData.length; //Ids\n                    if (continuousDataLength > 0) for (var k = 0; k < continuousDataLength - 1; k++) {\n                        console.assert(this.finalDataRows[i][j].numberRGBA[k] + 1 === this.finalDataRows[i][j].numberRGBA[k + 1]);\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Join the data into MVCs and TGs.\r\n         * @param {Map<string, number>} mvcs - The generated MVCs map and respective index.\r\n         * @param {number} numberTGs - The number of temporal granules.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: \"_joinData\",\n        value: function _joinData(mvcs, numberTGs) {\n            //Loop through rows and copy them to the final array\n            //categorical vars and time var can be ignored (they are known by the arrays indices)\n            //Save cont vars, geometry, opt vars and RGBA value\n\n            var hasIds = this.headerIndices[2].length ? false : true;\n            var geoPositions = hasIds ? 1 : 2;\n\n            // console.warn(this.timeVariable, mvcs);\n            var numberMVCs = mvcs.size,\n                numCatVars = this.categoricalVariables.length,\n                numContVars = this.continuousVariables.length,\n                geoStartPos = numCatVars + numContVars,\n                geoEndPos = geoStartPos + geoPositions,\n                timePos = geoEndPos;\n\n            this.finalDataRows = this._createFinalRows(numberMVCs, numberTGs);\n            //For each row saved then split it to its place\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = this.dataRowsSaved[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var rowSaved = _step8.value;\n\n                    var finalRow = [];\n                    var combination = '';\n\n                    var _iteratorNormalCompletion9 = true;\n                    var _didIteratorError9 = false;\n                    var _iteratorError9 = undefined;\n\n                    try {\n                        for (var _iterator9 = this.categoricalVariables.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                            var _step9$value = _slicedToArray(_step9.value, 2),\n                                _i6 = _step9$value[0],\n                                catVar = _step9$value[1];\n\n                            combination += catVar.findIndex(rowSaved[_i6]);\n                        }\n                    } catch (err) {\n                        _didIteratorError9 = true;\n                        _iteratorError9 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                _iterator9.return();\n                            }\n                        } finally {\n                            if (_didIteratorError9) {\n                                throw _iteratorError9;\n                            }\n                        }\n                    }\n\n                    var contValues = [];\n                    var _iteratorNormalCompletion10 = true;\n                    var _didIteratorError10 = false;\n                    var _iteratorError10 = undefined;\n\n                    try {\n                        for (var _iterator10 = this.continuousVariables.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                            var _step10$value = _slicedToArray(_step10.value, 2),\n                                j = _step10$value[0],\n                                contVar = _step10$value[1];\n\n                            var contValue = rowSaved[j + numCatVars];\n                            combination += contVar.findClassIntervalIndex(contValue);\n                            contValues.push(contValue);\n                        }\n                    } catch (err) {\n                        _didIteratorError10 = true;\n                        _iteratorError10 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                                _iterator10.return();\n                            }\n                        } finally {\n                            if (_didIteratorError10) {\n                                throw _iteratorError10;\n                            }\n                        }\n                    }\n\n                    var mvcIndex = mvcs.get(combination);\n                    var tgIndex = this.timeVariable !== undefined ? this.timeVariable.getTGMapIndex(rowSaved[timePos]) : 0;\n                    if (tgIndex === undefined) console.error(\"HERE\");\n                    for (var i = 0; i < contValues.length; i++) {\n                        this.finalDataRows[mvcIndex][tgIndex].continuousData[i].push(contValues[i]);\n                    }for (var _i4 = geoStartPos; _i4 < geoEndPos; _i4++) {\n                        this.finalDataRows[mvcIndex][tgIndex].spatialData.push(rowSaved[_i4]);\n                    }for (var _i5 = timePos + 1; _i5 < rowSaved.length; _i5++) {\n                        this.finalDataRows[mvcIndex][tgIndex].optionalData[_i5 - timePos - 1].push(rowSaved[_i5]);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n\n            this.dataRowsSaved = undefined; //Allows Garbage collection\n        }\n\n        /**\r\n         * Create the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @param {number} numberMVCs - Number of existing map variable combinations.\r\n         * @param {number} numberTGs - Number of existing temporal granules . \r\n         * @returns {Array<any>} - the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: \"_createFinalRows\",\n        value: function _createFinalRows(numberMVCs, numberTGs) {\n            var finalRows = [];\n\n            //Create arrays for optionalData\n            var optionalDataArrays = [];\n            for (var i = 0; i < this.optionalVariables.length; i++) {\n                //Create multiple arrays one for each optional variable\n                optionalDataArrays[i] = [];\n            }var continuosDataArrays = [];\n            for (var _i7 = 0; _i7 < this.continuousVariables.length; _i7++) {\n                //Create multiple arrays one for each optional variable\n                continuosDataArrays[_i7] = [];\n            } //Create array for final Rows\n            for (var _i8 = 0; _i8 < numberMVCs; _i8++) {\n                finalRows[_i8] = [];\n                for (var j = 0; j < numberTGs; j++) {\n                    finalRows[_i8][j] = {\n                        continuousData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(continuosDataArrays),\n                        spatialData: [],\n                        optionalData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(optionalDataArrays),\n                        RGBA: [],\n                        numberRGBA: []\n                    };\n                }\n            }\n            // console.log(finalRows);\n            return finalRows;\n        }\n\n        /**\r\n         * Recreate the variables sent by the main thread.\r\n         * @param {{continousVariables: Array<ContinuousVariable>, categoricalVariables: Array<CategoricalVariable>, timeVariable: TimeVariable}} data - Data sent by the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: \"_saveVariables\",\n        value: function _saveVariables(data) {\n            var contVars = [];\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n                for (var _iterator11 = data.continuousVariables[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                    var contVar = _step11.value;\n\n                    console.log(contVar);\n                    contVars.push(new _ContinuousVariable.ContinuousVariable(contVar.externalName, contVar.internalName, contVar.typeOfVisualVariable, contVar.shaderVariableQualifier, contVar.visualVariableMapping, contVar.classBreaks, contVar.numberOfClasses, contVar.classBreakMethod, contVar.classBreakMethodParams));\n                }\n                // let doa = true;\n                // if (doa) {\n            } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                        _iterator11.return();\n                    }\n                } finally {\n                    if (_didIteratorError11) {\n                        throw _iteratorError11;\n                    }\n                }\n            }\n\n            var catVars = [];\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = data.categoricalVariables[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var catVar = _step12.value;\n\n                    catVars.push(new _CategoricalVariable.CategoricalVariable(catVar.externalName, catVar.internalName, catVar.typeOfVisualVariable, catVar.shaderVariableQualifier, catVar.visualVariableMapping, null));\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n\n            var tVar = data.timeVariable;\n            var timeVariable = void 0;\n            if (tVar !== undefined) {\n                timeVariable = new _TimeVariable.TimeVariable(tVar.externalName, tVar.internalName, tVar.granularity, tVar.timeControl);\n            }\n            var optVars = [];\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n                for (var _iterator13 = data.optionalVariables[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                    var optVar = _step13.value;\n\n                    optVars.push(new _DataVariable.DataVariable(optVar.externalName, optVar.internalName));\n                } //TIME\n                // this.timeVariable = workerOptions.timeVariable;\n            } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                        _iterator13.return();\n                    }\n                } finally {\n                    if (_didIteratorError13) {\n                        throw _iteratorError13;\n                    }\n                }\n            }\n\n            this.timeVariable = timeVariable;\n            this.timeGranularity = this.timeVariable ? this.timeVariable.getGranularity() : '';\n            //CATEGORICAL\n            this.categoricalVariables = catVars; //workerOptions.categoricalVariables;\n            this.hasCategoricalVariables = this.categoricalVariables.length > 0;\n            //CONTINOUS \n            this.continuousVariables = contVars; //workerOptions.continuousVariables;\n            //OPTIONAL VARS\n            this.optionalVariables = optVars;\n            // }\n        }\n\n        /**\r\n         * Reads a chunk of bytes from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"readNextChunk\",\n        value: function readNextChunk() {\n            var start = Math.min(this.startByte, this.endByte);\n            var end = Math.min(this.startByte + this.chunkSize, this.endByte);\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Reads more 1000 bytes to finish the last line of the worker.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"readLastLine\",\n        value: function readLastLine() {\n            if (this.lastWorkerRow.length === 0) return true;\n            var start = Math.min(this.startByte, this.endByte);\n            var end = this.endByte + 1000;\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Called after a chunk is read from the file.\r\n         * @param {ProgressEvent} e - Event associated with the read data.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"chunkReadFromFile\",\n        value: function chunkReadFromFile(e) {\n            if (this.isLastLine) {\n                // console.warn(\"last line\", this.workerIndex, e.target.result);\n                var rows = (this.lastWorkerRow + e.target.result).split(this.rowDelimiter);\n                // console.warn(this.workerIndex, rows);\n                this.processRows(rows, 0, 1);\n                this.sendENDStartMessage();\n            } else {\n                this.startByte += this.chunkSize;\n                this.processChunk(e.target.result);\n                if (this.startByte >= this.endByte) {\n                    // console.log(\"END\");\n                    // console.log(\"NumRows Worker\", this.workerIndex, \"is:\", this.numRowsRead, \"\\nFIRSTROW = \", this.firstWorkerRow, \"\\nLASTROW = \", this.lastWorkerRow);\n                    //Post message with first and last row\n                    // console.warn(\"worker Terminated\", this.workerIndex, this.firstWorkerRow, this.lastWorkerRow);\n                    this.isLastLine = true;\n                    var isDone = this.readLastLine();\n                    if (isDone) //Only the ones that returned true from the readLastLine() method will send back to the \n                        this.sendENDStartMessage();\n                } else this.readNextChunk();\n            }\n        }\n    }, {\n        key: \"sendENDStartMessage\",\n        value: function sendENDStartMessage() {\n            console.warn(\"END\", this.workerIndex, this.dataRowsSaved.length);\n            worker.postMessage({\n                protocolMessage: _GisplayDefaults.GisplayDefaults.MESSAGES_CSV().END_START,\n                messageData: {\n                    workerIndex: this.workerIndex\n                    // firstWorkerRow: this.firstWorkerRow,\n                    // lastWorkerRow: this.lastWorkerRow\n                }\n            });\n        }\n\n        /**\r\n         * Process the chunk that was read from the file.\r\n         * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n         * @see https://image.prntscr.com/image/BkaRp8qSQuyt9phoSh71ZA.png\r\n         * @see https://image.prntscr.com/image/FAQ8CVH9S1W6X0RoZrOWfw.png - Edge case for \\r\\n.\r\n         * @see https://image.prntscr.com/image/yYXWcZwLQjSNYqIiuQEcKQ.png - Edge case example.\r\n         * @param {any} chunkText  - The text read from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"processChunk\",\n        value: function processChunk(chunkText) {\n            var rows = (this.remainingChunkRow + chunkText).split(this.rowDelimiter); //May not have the best performance (has to create new string due to string immutability). Could be changed but solution has to solve the EDGE CASE.\n            this.remainingChunkRow = rows[rows.length - 1];\n            var startRowIndex = 0,\n                endRowIndex = rows.length - 1; //The index to start and end the rows processing\n\n            if (!this.firstWorkerRow) {\n                //Save 1st row of this worker \n                this.firstWorkerRow = rows[0];\n                startRowIndex = 1; //Ignore first row of first chunk in any worker\n            }\n            if (!this.lastWorkerRow && this.startByte >= this.endByte) {\n                // console.log(this.workerIndex, this.lastWorkerRow);\n                this.lastWorkerRow = this.remainingChunkRow; //Save last row if it's the last chunk (See split image) \n                // console.log(this.workerIndex, rows, this.dataRowsSaved, this.firstWorkerRow, this.lastWorkerRow);\n\n                // console.error(this.workerIndex, this.remainingChunkRow);\n            }\n            this.processRows(rows, startRowIndex, endRowIndex);\n        }\n\n        /**\r\n         * Process the rows that are in the rows array. The first row of the 1st chunk read from the file should be ignored.\r\n         * @param {Array<string>} rows - The rows, each one in a position of the array. \r\n         * @param {number} startRowIndex - The row to start processing.\r\n         * @param {number} endRowIndex - The last row to process.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"processRows\",\n        value: function processRows(rows, startRowIndex, endRowIndex) {\n            var resRows = [];\n            // this.numRowsRead += (endRowIndex - startRowIndex); //DELETE\n            var categoricalIndices = this.headerIndices[0];\n            var continuousIndices = this.headerIndices[1];\n            var geometryIndices = this.headerIndices[2];\n            var hasIdGeometry = false;\n            if (+geometryIndices === +geometryIndices) {\n                geometryIndices = [geometryIndices];\n                hasIdGeometry = true;\n            }\n            var timeIndex = this.headerIndices[3];\n            var hasTime = this.timeGranularity !== ''; //OR this.timeVariable !== undefined\n            var optinalIndices = this.headerIndices[4];\n            for (var i = startRowIndex; i < endRowIndex; i++) {\n                this.numRowsRead++;\n                var columns = rows[i].split(this.columnDelimiter);\n                /* if (columns.length !== this.numColumnsPerRow) //Check for errors\r\n                    throw new Error(\"Wrong number of columns\");\r\n                 */\n                var row = [];\n\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = categoricalIndices.entries()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var _step14$value = _slicedToArray(_step14.value, 2),\n                            _i9 = _step14$value[0],\n                            catIndex = _step14$value[1];\n\n                        var category = columns[catIndex];\n                        if (this.categoricalVariables[_i9].classCalculationRequired()) this.categoricalVariables[_i9].addCategory(category);\n                        row.push(category);\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion15 = true;\n                var _didIteratorError15 = false;\n                var _iteratorError15 = undefined;\n\n                try {\n                    for (var _iterator15 = continuousIndices.entries()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var _step15$value = _slicedToArray(_step15.value, 2),\n                            _i10 = _step15$value[0],\n                            contIndex = _step15$value[1];\n\n                        var value = +columns[contIndex];\n                        /* if (value >= 80000.10)\r\n                            console.warn(\"WUUUT\"); */\n                        this.continuousVariables[_i10].setMinMax(value);\n                        row.push(value); //String to number\n                    }\n                } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                            _iterator15.return();\n                        }\n                    } finally {\n                        if (_didIteratorError15) {\n                            throw _iteratorError15;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = geometryIndices[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var geoIndex = _step16.value;\n\n                        if (hasIdGeometry) {\n                            var _value = columns[geoIndex];\n                            if (+_value === +_value) row.push(+_value);else row.push(_value.toUpperCase());\n                        } else row.push(+columns[geoIndex]);\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n\n                if (hasTime) {\n                    var granule = this.getGranule(columns[timeIndex]);\n                    this.timeVariable.addTemporalGranule(granule);\n                    this.timeVariable.addTemporalGranuleToSet(granule);\n                    row.push(granule);\n                }\n\n                var _iteratorNormalCompletion17 = true;\n                var _didIteratorError17 = false;\n                var _iteratorError17 = undefined;\n\n                try {\n                    for (var _iterator17 = optinalIndices[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                        var optionalIndex = _step17.value;\n\n                        if (+columns[optionalIndex] === +columns[optionalIndex]) //It's a number?\n                            row.push(+columns[optionalIndex]);else row.push(columns[optionalIndex]);\n                    }\n                    // resRows.push(row);\n                } catch (err) {\n                    _didIteratorError17 = true;\n                    _iteratorError17 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                            _iterator17.return();\n                        }\n                    } finally {\n                        if (_didIteratorError17) {\n                            throw _iteratorError17;\n                        }\n                    }\n                }\n\n                this.dataRowsSaved.push(row);\n            }\n            // console.log(this.workerIndex, this.dataRowsSaved.length);\n        }\n\n        /**\r\n         * TODO: DELETE AND Replace with GisplayDefaults.getGranule(timeString)\r\n         * Convert the time string to the granularity we want.\r\n         * @param {string} timeString - The time as it was read from the file. \r\n         * @returns {number} - The granul\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: \"getGranule\",\n        value: function getGranule(timeString) {\n            var value = void 0;\n            // console.warn(timeString, this.timeGranularity);\n            /*\r\n            //if cyclic then ...\r\n            day of year -> dayOfYear (n temos )\r\n            month of year -> monthOfYear (temos)\r\n            day of month -> dayOfMonth (temos)\r\n            hour of day -> hourOfDay (temos)\r\n            minute of hour -> minuteOfHour (temos)\r\n            \r\n            //else continuous\r\n            year -> 2015, 2016 ...\r\n            month -> 2015_01, 2015_02 ... 2016_01 etc\r\n            day -> 2015_01_01, 2015_01_02 ...\r\n            hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n            minute\r\n            value\r\n            */\n\n            switch (this.timeGranularity) {\n                //CYCLIC\n                case 'monthOfYear':\n                    //Mes do ano\n                    value = new Date(timeString).getMonth() + 1; //GOOD\n                    break;\n                case 'dayOfYear':\n                    value = -1; //CHANGE to calculate day of year\n                    break;\n                case 'dayOfMonth':\n                    value = new Date(timeString).getDate(); //GOOD\n                    break;\n                case 'hourOfDay':\n                    value = new Date(timeString).getHours(); //GOOD\n                    break;\n                case 'minuteOfHour':\n                    value = new Date(timeString).getMinutes(); //GOOD\n                    break;\n\n                //CONTINUOUS\n                case 'year':\n                    value = new Date(timeString).getFullYear();\n                    break;\n                case 'month':\n                    //Mes do ano\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\n                    break;\n                case 'day':\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\n                    // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\n                    break;\n                case 'value':\n                    value = +timeString;\n                    break;\n            }\n            // console.log(value);\n            return value;\n        }\n    }]);\n\n    return CSVFileWorker;\n}();\n\nnew CSVFileWorker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9QYXJzZXIvQ1NWL0ZpbGUvQ1NWRmlsZVdvcmtlci5qcz81NTFiIl0sInNvdXJjZXNDb250ZW50IjpbImxldCB3b3JrZXIgPSBzZWxmO1xyXG5cclxuaW1wb3J0IHsgRGF0YVZhcmlhYmxlIH0gZnJvbSBcIi4uLy4uLy4uL1ZWcy9EYXRhVmFyaWFibGVcIjtcclxuaW1wb3J0IHsgVVJMVmFyaWFibGUgfSBmcm9tIFwiLi4vLi4vLi4vVlZzL1VSTFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7IFRpbWVWYXJpYWJsZSB9IGZyb20gXCIuLi8uLi8uLi9WVnMvVGltZVZhcmlhYmxlXCI7XHJcbmltcG9ydCB7IENhdGVnb3JpY2FsVmFyaWFibGUgfSBmcm9tIFwiLi4vLi4vLi4vVlZzL0NhdGVnb3JpY2FsVmFyaWFibGVcIjtcclxuaW1wb3J0IHsgQ29udGludW91c1ZhcmlhYmxlIH0gZnJvbSBcIi4uLy4uLy4uL1ZWcy9Db250aW51b3VzVmFyaWFibGVcIjtcclxuaW1wb3J0IHsgR2lzcGxheURlZmF1bHRzIH0gZnJvbSBcIi4uLy4uLy4uL0dpc3BsYXlEZWZhdWx0c1wiO1xyXG5cclxuY2xhc3MgQ1NWRmlsZVdvcmtlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS1DU1YgRGF0YSBXb3JrZXItLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmaXJzdCByb3cgcmVhZCBieSB0aGlzIGRhdGEgd29ya2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maXJzdFdvcmtlclJvdyA9ICcnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXN0IHJvdyBvZiB0aGUgbGFzdCBjaHVuayByZWFkIGJ5IHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RXb3JrZXJSb3cgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlIHRoZSByZW1haW5pbmcgb2YgdGhlIGxhc3Qgcm93IGZyb20gdGhlIGNodW5rIHRoYXQgd2FzIHJlYWQuXHJcbiAgICAgICAgICogSXQncyB1c2VkIHdoZW4gYSBjaHVuayBkaWRuJ3QgZW5kIGluIGEgcm93IGRlbGltaXRpciBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbWFpbmluZ0NodW5rUm93ID0gJyc7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIGZpbGUuXHJcbiAgICAgICAgICogQHR5cGUge0ZpbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhRmlsZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHN0YXJ0IGJ5dGUgZm9yIHRoaXMgd29ya2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydEJ5dGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBlbmQgYnl0ZSBmb3IgdGhpcyB3b3JrZXIuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuZEJ5dGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIGVhY2ggY2h1bmsgdG8gcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGlzIHdvcmtlci4gREVMRVRFP1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53b3JrZXJJbmRleCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBjb2x1bW5zIGZvciBlYWNoIHJvdy4gREVMRVRFP1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zUGVyUm93ID0gLTE7IC8vTk9UIFVTRUQgQVRNXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByb3cgZGVsaW1pdGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb3dEZWxpbWl0ZXIgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sdW1uIGRlbGltaXRlci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sdW1uRGVsaW1pdGVyID0gJyc7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoZWFkZXIgaW5kaWNlcy4gXHJcbiAgICAgICAgICogVGhlIGFycmF5IGlzIHNwbGl0IGludG8gNSBwb3NpdGlvbnM6IFswXWNhdGVnb3JpY2FsLCBbMV1jb250aW51b3VzLCBbMl1nZW9tZXRyeSwgWzNddGltZSBhbmQgWzRdb3B0aW9uYWwgdmFyaWFibGVzLiBcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWFkZXJJbmRpY2VzID0gW107XHJcblxyXG4gICAgICAgIC8vVElNRSBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7VGltZVZhcmlhYmxlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGltZVZhcmlhYmxlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZ3JhbnVsYXJpdHkgb2YgdGhlIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVHcmFudWxhcml0eSA9ICcnO1xyXG5cclxuICAgICAgICAvL0NBVEVHT1JJQ0FMXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhdGVnb3JpY2FsIHZhcmlhYmxlcyBwcmVzZW50IGluIHRoZSB1c2VyIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PENhdGVnb3JpY2FsVmFyaWFibGU+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgb3B0aW9ucyBjb250YWluIGFueSBjYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhc0NhdGVnb3JpY2FsVmFyaWFibGVzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vQ09OVElOVU9VU1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb250aW51b3VzIHZhcmlhYmxlcy5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8Q29udGludW91c1ZhcmlhYmxlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy9PUFRJT05BTFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcHRpb25hbCB2YXJpYWJsZXMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PERhdGFWYXJpYWJsZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcHRpb25hbFZhcmlhYmxlcyA9IFtdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgRmlsZVJlYWRlciB1c2VkIHRvIHJlYWQgYSBwb3J0aW9uIG9mIHRoZSBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtGaWxlUmVhZGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5jcmVhdGVGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7IHRoaXMub25NZXNzYWdlKGUuZGF0YSk7IH07XHJcblxyXG4gICAgICAgIC8vU0FWRSBJTkZPUk1BVElPTlxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gc2F2ZSB0aGUgcm93cyBkaXJlY3RseSByZWFkIGZyb20gdGhlIGZpbGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8c3RyaW5nfG51bWJlcj4+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YVJvd3NTYXZlZCA9IFtdOyAvL1NhdmUgcm93cyByZWFkIGJ5IHRoaXMgV29ya2VyXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZpbmFsIGRhdGEgcm93cyB3aGljaCBjb250YWluIGFsbCBpbmZvcm1hdGlvbiB0byBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8e2NvbnRpbnVvdXNEYXRhOiBBcnJheTxBcnJheTxudW1iZXI+Piwgc3BhdGlhbERhdGE6IEFycmF5PG51bWJlcj4sb3B0aW9uYWxEYXRhOiBBcnJheTxBcnJheTxudW1iZXJ8c3RyaW5nPj4sIFJHQkE6IEFycmF5PG51bWJlcj4sIG51bWJlclJHQkE6IEFycmF5PG51bWJlcj59Pj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maW5hbERhdGFSb3dzID0gW107XHJcbiAgICAgICAgLy8gdGhpcy5udW1Sb3dzUmVhZCA9IDA7XHJcblxyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBXaWxsIGJlIHRydWUgd2hlbiB3ZSB3YW50IHRvIHByb2Nlc3MgdGhlIGxhc3QgbGluZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzTGFzdExpbmUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBmaWxlIHJlYWRlci5cclxuICAgICAqIEByZXR1cm5zIHtGaWxlUmVhZGVyfSAtIHRoZSBGaWxlUmVhZGVyIHVzZWQgdG8gcmVhZCBhIHBvcnRpb24gb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBjcmVhdGVGaWxlUmVhZGVyKCkge1xyXG4gICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4geyB0aGlzLmNodW5rUmVhZEZyb21GaWxlKGUpOyB9O1xyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGUpID0+IHsgY29uc29sZS5lcnJvcihlKTsgfTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgd29ya2VyIHJlY2VpdmVzIGEgbWVzc2FnZS4gXHJcbiAgICAgKiBAcGFyYW0ge3twcm90b2NvbE1lc3NhZ2U6IHN0cmluZywgbWVzc2FnZURhdGE6T2JqZWN0fX0gZGF0YU1lc3NhZ2UgLSBUaGUgZGF0YSBtZXNzYWdlIHRoYXQgd2FzIHNlbnQgYnkgdGhlIG1haW4gVGhyZWFkLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgb25NZXNzYWdlKGRhdGFNZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tQ1NWIERhdGEgV29ya2VyLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhTWVzc2FnZSk7XHJcbiAgICAgICAgbGV0IHByb3RvY29sTWVzc2FnZXMgPSBHaXNwbGF5RGVmYXVsdHMuTUVTU0FHRVNfQ1NWKCk7XHJcbiAgICAgICAgc3dpdGNoIChkYXRhTWVzc2FnZS5wcm90b2NvbE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX1NUQVJUOiB7IC8vV29ya2VyIHByb2Nlc3NlZCBpdCdzIHBhcnRcclxuICAgICAgICAgICAgICAgIC8vRmlsZSBhbmQgY2h1bmsgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgIGxldCB3b3JrZXJPcHRpb25zID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEud29ya2VyT3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUZpbGUgPSB3b3JrZXJPcHRpb25zLmRhdGFGaWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJ5dGUgPSB3b3JrZXJPcHRpb25zLnN0YXJ0Qnl0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kQnl0ZSA9IHdvcmtlck9wdGlvbnMuZW5kQnl0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtTaXplID0gd29ya2VyT3B0aW9ucy5jaHVua1NpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlckluZGV4ID0gd29ya2VyT3B0aW9ucy53b3JrZXJJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtQ29sdW1uc1BlclJvdyA9IHdvcmtlck9wdGlvbnMubnVtQ29sdW1uc1BlclJvdztcclxuICAgICAgICAgICAgICAgIHRoaXMucm93RGVsaW1pdGVyID0gd29ya2VyT3B0aW9ucy5yb3dEZWxpbWl0ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkRlbGltaXRlciA9IHdvcmtlck9wdGlvbnMuY29sdW1uRGVsaW1pdGVyO1xyXG4gICAgICAgICAgICAgICAgLy9JbmRpY2VzIGFuZCBjbGFzcyBjYWxjXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckluZGljZXMgPSB3b3JrZXJPcHRpb25zLmhlYWRlckluZGljZXM7XHJcbiAgICAgICAgICAgICAgICAvL1NhdmUgQ2F0ZWdvcmljYWwvQ29udGludW91cyBhbmQgdGltZSBWYXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlVmFyaWFibGVzKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLndvcmtlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgLy9TdGFydCByZWFkaW5nIGZpbGVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZE5leHRDaHVuaygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX0xJTUlUU19DQVQ6IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9fTElNSVRfQ0FUXCIpXHJcbiAgICAgICAgICAgICAgICBsZXQgY2F0VmFyc0NhdGVnb3JpZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhdFZhciBvZiB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdFZhcnNDYXRlZ29yaWVzTWFwLnNldChjYXRWYXIuZ2V0SW50ZXJuYWxOYW1lKCksIGNhdFZhci5nZXRDYXRlZ29yaWVzKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBjb250VmFyc01pbk1heE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udFZhciBvZiB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udFZhcnNNaW5NYXhNYXAuc2V0KGNvbnRWYXIuZ2V0SW50ZXJuYWxOYW1lKCksIFtjb250VmFyLmdldE1pbigpLCBjb250VmFyLmdldE1heCgpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgY2F0VmFyc0NhdGVnb3JpZXNNYXAsIGNvbnRWYXJzTWluTWF4TWFwLCB0aGlzLnRpbWVWYXJpYWJsZSwgdGhpcy50aW1lVmFyaWFibGUuZ2V0VGVtcG9yYWxHcmFudWxlc1NldCgpKVxyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9MSU1JVFNfQ0FULFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpY2FsVmFyaWFibGVzOiBjYXRWYXJzQ2F0ZWdvcmllc01hcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGlub3VzVmFyaWFibGVzOiBjb250VmFyc01pbk1heE1hcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVZhcmlhYmxlOiB0aGlzLnRpbWVWYXJpYWJsZSA/IHRoaXMudGltZVZhcmlhYmxlLmdldFRlbXBvcmFsR3JhbnVsZXNTZXQoKSA6IHRoaXMudGltZVZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fTElNSVRTX0NBVF9SRVM6IHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250aW5vdXNWYXJzTWluTWF4ID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbaSwgY29udFZhcl0gb2YgdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0TWluTWF4KGNvbnRpbm91c1ZhcnNNaW5NYXhbaV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0TWluTWF4KGNvbnRpbm91c1ZhcnNNaW5NYXhbaV1bMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXIuc2V0U3RlcCgpOyAvL1VwZGF0ZSBzdGVwIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Mb29wIHRocm91Z2ggZGF0YSBhbmQgY2FsY3VsYXRlIGJpbnMgZm9yIGVhY2ggY29udGludW91cyB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRQb3NTdGFydCA9IHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRQb3NFbmQgPSBjb250UG9zU3RhcnQgKyB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGF0YSBvZiB0aGlzLmRhdGFSb3dzU2F2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRQb3NTdGFydDsgaSA8IGNvbnRQb3NFbmQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51b3VzVmFyaWFibGVzW2kgLSBjb250UG9zU3RhcnRdLmFkZFZhbHVlVG9CaW5zKGRhdGFbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBoaXN0b2dyYW1zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRWYXIgb2YgdGhpcy5jb250aW51b3VzVmFyaWFibGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpc3RvZ3JhbXMucHVzaChjb250VmFyLmdldEhpc3RvZ3JhbSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXNbMF0uZ2V0SGlzdG9ncmFtKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9MSU1JVFNfQ0FUX1JFUyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b2dyYW1zOiBoaXN0b2dyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fSk9JTl9EQVRBOiB7XHJcbiAgICAgICAgICAgICAgICAvL1Byb2Nlc3MgZGF0YSBhbmQgdGhlbiBzZW5kIHRoZSByZXMgZGF0YVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud29ya2VySW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkkgd2lsbCBwcm9jZXNzIHRoZSBkYXRhLi4uLk5PVFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY2F0VmFycyA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLmNhdGVnb3JpY2FsVmFyaWFibGVzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgY2F0VmFyXSBvZiBjYXRWYXJzLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzW2ldLnZhbHVlVG9JbmRleE1hcCA9IGNhdFZhci52YWx1ZVRvSW5kZXhNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRWYXJzID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEuY29udGludW91c1ZhcmlhYmxlcztcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIGNvbnRWYXJdIG9mIGNvbnRWYXJzLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXNbaV0uY2xhc3NJbnRlcnZhbHMgPSBjb250VmFyLmNsYXNzSW50ZXJ2YWxzO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB0VmFyID0gZGF0YU1lc3NhZ2UubWVzc2FnZURhdGEudGltZVZhcmlhYmxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRWYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUudGVtcG9yYWxHcmFudWxlc01hcCA9IHRWYXIudGVtcG9yYWxHcmFudWxlc01hcDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnRGF0YSA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhO1xyXG4gICAgICAgICAgICAgICAgbGV0IG12Y3MgPSBtc2dEYXRhLm12Y3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyTVZDcyA9IG12Y3Muc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJUR3MgPSBtc2dEYXRhLm51bWJlclRHcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2pvaW5EYXRhKG12Y3MsIG51bWJlclRHcyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBudW1Ub3RhbEVsZW1lbnRzID0gMDsgLy9DcmVhdGUgYXJyYXkgdG8gc2VuZCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIHdvcmtlclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLmZpbmFsRGF0YVJvd3MpO1xyXG4gICAgICAgICAgICAgICAgLyogICAgaWYgKHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJNVkNzOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyVEdzOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3RhbEVsZW1lbnRzICs9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5jb250aW51b3VzRGF0YVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcIlwiKTsgKi9cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTVZDczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJUR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdGFsRWxlbWVudHMgKz0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3RhbEVsZW1lbnRzICs9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGg7IC8vSWRzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG51bVRvdGFsRWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9KT0lOX0RBVEEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtVG90YWxFbGVtZW50czogbnVtVG90YWxFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VySW5kZXg6IHRoaXMud29ya2VySW5kZXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19HRU5FUkFURV9SR0JBOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgR2VuZXJhdGUgUkdCQXMgZm9yIGFsbCBNVkNzL1RHcyBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlUkdCQUNvZGVzKGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhKTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfR0VORVJBVEVfUkdCQSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19TRU5EX0RBVEE6IHtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlOiBwcm90b2NvbE1lc3NhZ2VzLkVORF9TRU5EX0RBVEEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhUm93czogdGhpcy5maW5hbERhdGFSb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIFJHQkEgY29kZXMgZm9yIGVhY2ggZWxlbWVudCBpbiBlYWNoIE1WQy9URy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPn0gc3RhcnRSR0JBTnVtIC0gVGhlIHN0YXJ0IFJHQkEgbnVtYmVyIGZvciB0aGlzIHdvcmtlci4uIFxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ld0RhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgX2dlbmVyYXRlUkdCQUNvZGVzKHN0YXJ0UkdCQU51bSkge1xyXG4gICAgICAgIGxldCBudW1NVkNzID0gdGhpcy5maW5hbERhdGFSb3dzLmxlbmd0aCxcclxuICAgICAgICAgICAgbnVtVEdzID0gdGhpcy5maW5hbERhdGFSb3dzWzBdLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1WQ3M7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBsZXQgc3RhcnRSR0JBID0gc3RhcnRpbmdSR0JBTnVtYmVyW2ldLFxyXG4gICAgICAgICAgICAvLyBsZXQgc3RhcnRSR0JBTnVtID0gR2lzcGxheURlZmF1bHRzLlJHQkFUb051bWJlciguLi5zdGFydFJHQkEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVRHczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtYmVyT2ZFbGVtZW50cyA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkVsZW1lbnRzID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mRWxlbWVudHMgPSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uc3BhdGlhbERhdGEubGVuZ3RoOyAvL0lkc1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLmNvbnRpbnVvdXNEYXRhWzBdLmxlbmd0aDsgLy9Vc2luZyBjb250aW51b3VzIGRhdGEgdGhhdCBtaWdodCBub3QgZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZkVsZW1lbnRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtYmVyT2ZFbGVtZW50czsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSR0JBID0gR2lzcGxheURlZmF1bHRzLm51bWJlclRvUkdCQShzdGFydFJHQkFOdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uUkdCQS5wdXNoKC4uLlJHQkEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0ubnVtYmVyUkdCQS5wdXNoKHN0YXJ0UkdCQU51bSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZXJpZnlJbnRlZ3JpdHlSR0JBKG51bU1WQ3MsIG51bVRHcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmVyaWZ5SW50ZWdyaXR5UkdCQShudW1NVkNzLCBudW1UR3MpIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJWRVJJRlkgSU5URUdSSVRZXCIpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NVkNzOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1UR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlckluZGljZXNbMl0ubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aCAvIDI7IC8vTGF0L0xuZ1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhTGVuZ3RoID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aDsgLy9JZHNcclxuICAgICAgICAgICAgICAgIGlmIChjb250aW51b3VzRGF0YUxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb250aW51b3VzRGF0YUxlbmd0aCAtIDE7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLm51bWJlclJHQkFba10gKyAxID09PSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0ubnVtYmVyUkdCQVtrICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSm9pbiB0aGUgZGF0YSBpbnRvIE1WQ3MgYW5kIFRHcy5cclxuICAgICAqIEBwYXJhbSB7TWFwPHN0cmluZywgbnVtYmVyPn0gbXZjcyAtIFRoZSBnZW5lcmF0ZWQgTVZDcyBtYXAgYW5kIHJlc3BlY3RpdmUgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyVEdzIC0gVGhlIG51bWJlciBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZOZXdEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIF9qb2luRGF0YShtdmNzLCBudW1iZXJUR3MpIHtcclxuICAgICAgICAvL0xvb3AgdGhyb3VnaCByb3dzIGFuZCBjb3B5IHRoZW0gdG8gdGhlIGZpbmFsIGFycmF5XHJcbiAgICAgICAgLy9jYXRlZ29yaWNhbCB2YXJzIGFuZCB0aW1lIHZhciBjYW4gYmUgaWdub3JlZCAodGhleSBhcmUga25vd24gYnkgdGhlIGFycmF5cyBpbmRpY2VzKVxyXG4gICAgICAgIC8vU2F2ZSBjb250IHZhcnMsIGdlb21ldHJ5LCBvcHQgdmFycyBhbmQgUkdCQSB2YWx1ZVxyXG5cclxuICAgICAgICBsZXQgaGFzSWRzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aCA/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgICBsZXQgZ2VvUG9zaXRpb25zID0gaGFzSWRzID8gMSA6IDI7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2Fybih0aGlzLnRpbWVWYXJpYWJsZSwgbXZjcyk7XHJcbiAgICAgICAgbGV0IG51bWJlck1WQ3MgPSBtdmNzLnNpemUsXHJcbiAgICAgICAgICAgIG51bUNhdFZhcnMgPSB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgbnVtQ29udFZhcnMgPSB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBnZW9TdGFydFBvcyA9IG51bUNhdFZhcnMgKyBudW1Db250VmFycyxcclxuICAgICAgICAgICAgZ2VvRW5kUG9zID0gZ2VvU3RhcnRQb3MgKyBnZW9Qb3NpdGlvbnMsXHJcbiAgICAgICAgICAgIHRpbWVQb3MgPSBnZW9FbmRQb3M7XHJcblxyXG4gICAgICAgIHRoaXMuZmluYWxEYXRhUm93cyA9IHRoaXMuX2NyZWF0ZUZpbmFsUm93cyhudW1iZXJNVkNzLCBudW1iZXJUR3MpO1xyXG4gICAgICAgIC8vRm9yIGVhY2ggcm93IHNhdmVkIHRoZW4gc3BsaXQgaXQgdG8gaXRzIHBsYWNlXHJcbiAgICAgICAgZm9yIChjb25zdCByb3dTYXZlZCBvZiB0aGlzLmRhdGFSb3dzU2F2ZWQpIHtcclxuICAgICAgICAgICAgbGV0IGZpbmFsUm93ID0gW107XHJcbiAgICAgICAgICAgIGxldCBjb21iaW5hdGlvbiA9ICcnO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgW2ksIGNhdFZhcl0gb2YgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbiArPSBjYXRWYXIuZmluZEluZGV4KHJvd1NhdmVkW2ldKTtcclxuICAgICAgICAgICAgbGV0IGNvbnRWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgW2osIGNvbnRWYXJdIG9mIHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250VmFsdWUgPSByb3dTYXZlZFtqICsgbnVtQ2F0VmFyc107XHJcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbiArPSBjb250VmFyLmZpbmRDbGFzc0ludGVydmFsSW5kZXgoY29udFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRWYWx1ZXMucHVzaChjb250VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgbXZjSW5kZXggPSBtdmNzLmdldChjb21iaW5hdGlvbik7XHJcbiAgICAgICAgICAgIGxldCB0Z0luZGV4ID0gdGhpcy50aW1lVmFyaWFibGUgIT09IHVuZGVmaW5lZCA/IHRoaXMudGltZVZhcmlhYmxlLmdldFRHTWFwSW5kZXgocm93U2F2ZWRbdGltZVBvc10pIDogMDtcclxuICAgICAgICAgICAgaWYgKHRnSW5kZXggPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJIRVJFXCIpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udFZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxEYXRhUm93c1ttdmNJbmRleF1bdGdJbmRleF0uY29udGludW91c0RhdGFbaV0ucHVzaChjb250VmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGdlb1N0YXJ0UG9zOyBpIDwgZ2VvRW5kUG9zOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbbXZjSW5kZXhdW3RnSW5kZXhdLnNwYXRpYWxEYXRhLnB1c2gocm93U2F2ZWRbaV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGltZVBvcyArIDE7IGkgPCByb3dTYXZlZC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxEYXRhUm93c1ttdmNJbmRleF1bdGdJbmRleF0ub3B0aW9uYWxEYXRhW2kgLSB0aW1lUG9zIC0gMV0ucHVzaChyb3dTYXZlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YVJvd3NTYXZlZCA9IHVuZGVmaW5lZDsgLy9BbGxvd3MgR2FyYmFnZSBjb2xsZWN0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGZpbmFsIHJvdyB0byBob2xkIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHRoZSB3b3JrZXIgc2hvdWxkIHNlbmQgYXQgdGhlIGVuZCB0byB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyTVZDcyAtIE51bWJlciBvZiBleGlzdGluZyBtYXAgdmFyaWFibGUgY29tYmluYXRpb25zLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclRHcyAtIE51bWJlciBvZiBleGlzdGluZyB0ZW1wb3JhbCBncmFudWxlcyAuIFxyXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59IC0gdGhlIGZpbmFsIHJvdyB0byBob2xkIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHRoZSB3b3JrZXIgc2hvdWxkIHNlbmQgYXQgdGhlIGVuZCB0byB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWTmV3RGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBfY3JlYXRlRmluYWxSb3dzKG51bWJlck1WQ3MsIG51bWJlclRHcykge1xyXG4gICAgICAgIGxldCBmaW5hbFJvd3MgPSBbXTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgYXJyYXlzIGZvciBvcHRpb25hbERhdGFcclxuICAgICAgICBsZXQgb3B0aW9uYWxEYXRhQXJyYXlzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbmFsVmFyaWFibGVzLmxlbmd0aDsgaSsrKSAvL0NyZWF0ZSBtdWx0aXBsZSBhcnJheXMgb25lIGZvciBlYWNoIG9wdGlvbmFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIG9wdGlvbmFsRGF0YUFycmF5c1tpXSA9IFtdO1xyXG5cclxuICAgICAgICBsZXQgY29udGludW9zRGF0YUFycmF5cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmxlbmd0aDsgaSsrKSAvL0NyZWF0ZSBtdWx0aXBsZSBhcnJheXMgb25lIGZvciBlYWNoIG9wdGlvbmFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIGNvbnRpbnVvc0RhdGFBcnJheXNbaV0gPSBbXTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgYXJyYXkgZm9yIGZpbmFsIFJvd3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck1WQ3M7IGkrKykge1xyXG4gICAgICAgICAgICBmaW5hbFJvd3NbaV0gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJUR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgZmluYWxSb3dzW2ldW2pdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNEYXRhOiBHaXNwbGF5RGVmYXVsdHMuY2xvbmVOZXN0ZWRBcnJheShjb250aW51b3NEYXRhQXJyYXlzKSxcclxuICAgICAgICAgICAgICAgICAgICBzcGF0aWFsRGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxEYXRhOiBHaXNwbGF5RGVmYXVsdHMuY2xvbmVOZXN0ZWRBcnJheShvcHRpb25hbERhdGFBcnJheXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJHQkE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclJHQkE6IFtdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZmluYWxSb3dzKTtcclxuICAgICAgICByZXR1cm4gZmluYWxSb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGUgdGhlIHZhcmlhYmxlcyBzZW50IGJ5IHRoZSBtYWluIHRocmVhZC5cclxuICAgICAqIEBwYXJhbSB7e2NvbnRpbm91c1ZhcmlhYmxlczogQXJyYXk8Q29udGludW91c1ZhcmlhYmxlPiwgY2F0ZWdvcmljYWxWYXJpYWJsZXM6IEFycmF5PENhdGVnb3JpY2FsVmFyaWFibGU+LCB0aW1lVmFyaWFibGU6IFRpbWVWYXJpYWJsZX19IGRhdGEgLSBEYXRhIHNlbnQgYnkgdGhlIG1haW4gdGhyZWFkLlxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ld0RhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgX3NhdmVWYXJpYWJsZXMoZGF0YSkge1xyXG4gICAgICAgIGxldCBjb250VmFycyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udFZhciBvZiBkYXRhLmNvbnRpbnVvdXNWYXJpYWJsZXMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coY29udFZhcik7XHJcbiAgICAgICAgICAgIGNvbnRWYXJzLnB1c2gobmV3IENvbnRpbnVvdXNWYXJpYWJsZShcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuZXh0ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5pbnRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb250VmFyLnR5cGVPZlZpc3VhbFZhcmlhYmxlLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5zaGFkZXJWYXJpYWJsZVF1YWxpZmllcixcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIudmlzdWFsVmFyaWFibGVNYXBwaW5nLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrcyxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIubnVtYmVyT2ZDbGFzc2VzLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrTWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci5jbGFzc0JyZWFrTWV0aG9kUGFyYW1zXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXQgZG9hID0gdHJ1ZTtcclxuICAgICAgICAvLyBpZiAoZG9hKSB7XHJcbiAgICAgICAgbGV0IGNhdFZhcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhdFZhciBvZiBkYXRhLmNhdGVnb3JpY2FsVmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgIGNhdFZhcnMucHVzaChuZXcgQ2F0ZWdvcmljYWxWYXJpYWJsZShcclxuICAgICAgICAgICAgICAgIGNhdFZhci5leHRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjYXRWYXIuaW50ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnR5cGVPZlZpc3VhbFZhcmlhYmxlLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnNoYWRlclZhcmlhYmxlUXVhbGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLnZpc3VhbFZhcmlhYmxlTWFwcGluZyxcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdFZhciA9IGRhdGEudGltZVZhcmlhYmxlO1xyXG4gICAgICAgIGxldCB0aW1lVmFyaWFibGU7XHJcbiAgICAgICAgaWYgKHRWYXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aW1lVmFyaWFibGUgPSBuZXcgVGltZVZhcmlhYmxlKFxyXG4gICAgICAgICAgICAgICAgdFZhci5leHRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICB0VmFyLmludGVybmFsTmFtZSxcclxuICAgICAgICAgICAgICAgIHRWYXIuZ3JhbnVsYXJpdHksXHJcbiAgICAgICAgICAgICAgICB0VmFyLnRpbWVDb250cm9sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvcHRWYXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBvcHRWYXIgb2YgZGF0YS5vcHRpb25hbFZhcmlhYmxlcylcclxuICAgICAgICAgICAgb3B0VmFycy5wdXNoKG5ldyBEYXRhVmFyaWFibGUob3B0VmFyLmV4dGVybmFsTmFtZSwgb3B0VmFyLmludGVybmFsTmFtZSkpO1xyXG5cclxuICAgICAgICAvL1RJTUVcclxuICAgICAgICAvLyB0aGlzLnRpbWVWYXJpYWJsZSA9IHdvcmtlck9wdGlvbnMudGltZVZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMudGltZVZhcmlhYmxlID0gdGltZVZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMudGltZUdyYW51bGFyaXR5ID0gdGhpcy50aW1lVmFyaWFibGUgPyB0aGlzLnRpbWVWYXJpYWJsZS5nZXRHcmFudWxhcml0eSgpIDogJyc7XHJcbiAgICAgICAgLy9DQVRFR09SSUNBTFxyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMgPSBjYXRWYXJzOy8vd29ya2VyT3B0aW9ucy5jYXRlZ29yaWNhbFZhcmlhYmxlcztcclxuICAgICAgICB0aGlzLmhhc0NhdGVnb3JpY2FsVmFyaWFibGVzID0gdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIC8vQ09OVElOT1VTIFxyXG4gICAgICAgIHRoaXMuY29udGludW91c1ZhcmlhYmxlcyA9IGNvbnRWYXJzOy8vd29ya2VyT3B0aW9ucy5jb250aW51b3VzVmFyaWFibGVzO1xyXG4gICAgICAgIC8vT1BUSU9OQUwgVkFSU1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWxWYXJpYWJsZXMgPSBvcHRWYXJzO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgY2h1bmsgb2YgYnl0ZXMgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIHJlYWROZXh0Q2h1bmsoKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5taW4odGhpcy5zdGFydEJ5dGUsIHRoaXMuZW5kQnl0ZSk7XHJcbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMuc3RhcnRCeXRlICsgdGhpcy5jaHVua1NpemUsIHRoaXMuZW5kQnl0ZSk7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIucmVhZEFzVGV4dCh0aGlzLmRhdGFGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIG1vcmUgMTAwMCBieXRlcyB0byBmaW5pc2ggdGhlIGxhc3QgbGluZSBvZiB0aGUgd29ya2VyLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgcmVhZExhc3RMaW5lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RXb3JrZXJSb3cubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0Qnl0ZSwgdGhpcy5lbmRCeXRlKTtcclxuICAgICAgICBsZXQgZW5kID0gdGhpcy5lbmRCeXRlICsgMTAwMDtcclxuICAgICAgICB0aGlzLnJlYWRlci5yZWFkQXNUZXh0KHRoaXMuZGF0YUZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIGEgY2h1bmsgaXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBlIC0gRXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWFkIGRhdGEuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBjaHVua1JlYWRGcm9tRmlsZShlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0TGluZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJsYXN0IGxpbmVcIiwgdGhpcy53b3JrZXJJbmRleCwgZS50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgbGV0IHJvd3MgPSAodGhpcy5sYXN0V29ya2VyUm93ICsgZS50YXJnZXQucmVzdWx0KS5zcGxpdCh0aGlzLnJvd0RlbGltaXRlcik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2Fybih0aGlzLndvcmtlckluZGV4LCByb3dzKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUm93cyhyb3dzLCAwLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRU5EU3RhcnRNZXNzYWdlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydEJ5dGUgKz0gdGhpcy5jaHVua1NpemU7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NodW5rKGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Qnl0ZSA+PSB0aGlzLmVuZEJ5dGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRU5EXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJOdW1Sb3dzIFdvcmtlclwiLCB0aGlzLndvcmtlckluZGV4LCBcImlzOlwiLCB0aGlzLm51bVJvd3NSZWFkLCBcIlxcbkZJUlNUUk9XID0gXCIsIHRoaXMuZmlyc3RXb3JrZXJSb3csIFwiXFxuTEFTVFJPVyA9IFwiLCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG4gICAgICAgICAgICAgICAgLy9Qb3N0IG1lc3NhZ2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCByb3dcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIndvcmtlciBUZXJtaW5hdGVkXCIsIHRoaXMud29ya2VySW5kZXgsIHRoaXMuZmlyc3RXb3JrZXJSb3csIHRoaXMubGFzdFdvcmtlclJvdyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGFzdExpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzRG9uZSA9IHRoaXMucmVhZExhc3RMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSAvL09ubHkgdGhlIG9uZXMgdGhhdCByZXR1cm5lZCB0cnVlIGZyb20gdGhlIHJlYWRMYXN0TGluZSgpIG1ldGhvZCB3aWxsIHNlbmQgYmFjayB0byB0aGUgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRU5EU3RhcnRNZXNzYWdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkTmV4dENodW5rKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbmRFTkRTdGFydE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiRU5EXCIsIHRoaXMud29ya2VySW5kZXgsIHRoaXMuZGF0YVJvd3NTYXZlZC5sZW5ndGgpO1xyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogR2lzcGxheURlZmF1bHRzLk1FU1NBR0VTX0NTVigpLkVORF9TVEFSVCxcclxuICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgIHdvcmtlckluZGV4OiB0aGlzLndvcmtlckluZGV4LFxyXG4gICAgICAgICAgICAgICAgLy8gZmlyc3RXb3JrZXJSb3c6IHRoaXMuZmlyc3RXb3JrZXJSb3csXHJcbiAgICAgICAgICAgICAgICAvLyBsYXN0V29ya2VyUm93OiB0aGlzLmxhc3RXb3JrZXJSb3dcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgY2h1bmsgdGhhdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9wdC1QVC9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3BsaXRcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9pbWFnZS5wcm50c2NyLmNvbS9pbWFnZS9Ca2FScDhxU1F1eXQ5cGhvU2g3MVpBLnBuZ1xyXG4gICAgICogQHNlZSBodHRwczovL2ltYWdlLnBybnRzY3IuY29tL2ltYWdlL0ZBUThDVkg5UzFXNlgwUm9ack9XZncucG5nIC0gRWRnZSBjYXNlIGZvciBcXHJcXG4uXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vaW1hZ2UucHJudHNjci5jb20vaW1hZ2UveVlYV2Nad0xRalNOWXFJaXVRRWNLUS5wbmcgLSBFZGdlIGNhc2UgZXhhbXBsZS5cclxuICAgICAqIEBwYXJhbSB7YW55fSBjaHVua1RleHQgIC0gVGhlIHRleHQgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0NodW5rKGNodW5rVGV4dCkge1xyXG4gICAgICAgIGxldCByb3dzID0gKHRoaXMucmVtYWluaW5nQ2h1bmtSb3cgKyBjaHVua1RleHQpLnNwbGl0KHRoaXMucm93RGVsaW1pdGVyKTsgLy9NYXkgbm90IGhhdmUgdGhlIGJlc3QgcGVyZm9ybWFuY2UgKGhhcyB0byBjcmVhdGUgbmV3IHN0cmluZyBkdWUgdG8gc3RyaW5nIGltbXV0YWJpbGl0eSkuIENvdWxkIGJlIGNoYW5nZWQgYnV0IHNvbHV0aW9uIGhhcyB0byBzb2x2ZSB0aGUgRURHRSBDQVNFLlxyXG4gICAgICAgIHRoaXMucmVtYWluaW5nQ2h1bmtSb3cgPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IFtzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleF0gPSBbMCwgcm93cy5sZW5ndGggLSAxXTsgLy9UaGUgaW5kZXggdG8gc3RhcnQgYW5kIGVuZCB0aGUgcm93cyBwcm9jZXNzaW5nXHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0V29ya2VyUm93KSB7IC8vU2F2ZSAxc3Qgcm93IG9mIHRoaXMgd29ya2VyIFxyXG4gICAgICAgICAgICB0aGlzLmZpcnN0V29ya2VyUm93ID0gcm93c1swXTtcclxuICAgICAgICAgICAgc3RhcnRSb3dJbmRleCA9IDE7IC8vSWdub3JlIGZpcnN0IHJvdyBvZiBmaXJzdCBjaHVuayBpbiBhbnkgd29ya2VyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5sYXN0V29ya2VyUm93ICYmIHRoaXMuc3RhcnRCeXRlID49IHRoaXMuZW5kQnl0ZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLndvcmtlckluZGV4LCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RXb3JrZXJSb3cgPSB0aGlzLnJlbWFpbmluZ0NodW5rUm93OyAvL1NhdmUgbGFzdCByb3cgaWYgaXQncyB0aGUgbGFzdCBjaHVuayAoU2VlIHNwbGl0IGltYWdlKSBcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgcm93cywgdGhpcy5kYXRhUm93c1NhdmVkLCB0aGlzLmZpcnN0V29ya2VyUm93LCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcih0aGlzLndvcmtlckluZGV4LCB0aGlzLnJlbWFpbmluZ0NodW5rUm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUm93cyhyb3dzLCBzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIHRoZSByb3dzIHRoYXQgYXJlIGluIHRoZSByb3dzIGFycmF5LiBUaGUgZmlyc3Qgcm93IG9mIHRoZSAxc3QgY2h1bmsgcmVhZCBmcm9tIHRoZSBmaWxlIHNob3VsZCBiZSBpZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSByb3dzIC0gVGhlIHJvd3MsIGVhY2ggb25lIGluIGEgcG9zaXRpb24gb2YgdGhlIGFycmF5LiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFJvd0luZGV4IC0gVGhlIHJvdyB0byBzdGFydCBwcm9jZXNzaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFJvd0luZGV4IC0gVGhlIGxhc3Qgcm93IHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzUm93cyhyb3dzLCBzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCkge1xyXG4gICAgICAgIGxldCByZXNSb3dzID0gW107XHJcbiAgICAgICAgLy8gdGhpcy5udW1Sb3dzUmVhZCArPSAoZW5kUm93SW5kZXggLSBzdGFydFJvd0luZGV4KTsgLy9ERUxFVEVcclxuICAgICAgICBsZXQgY2F0ZWdvcmljYWxJbmRpY2VzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzBdO1xyXG4gICAgICAgIGxldCBjb250aW51b3VzSW5kaWNlcyA9IHRoaXMuaGVhZGVySW5kaWNlc1sxXTtcclxuICAgICAgICBsZXQgZ2VvbWV0cnlJbmRpY2VzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzJdO1xyXG4gICAgICAgIGxldCBoYXNJZEdlb21ldHJ5ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCtnZW9tZXRyeUluZGljZXMgPT09ICtnZW9tZXRyeUluZGljZXMpIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnlJbmRpY2VzID0gW2dlb21ldHJ5SW5kaWNlc107XHJcbiAgICAgICAgICAgIGhhc0lkR2VvbWV0cnkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGltZUluZGV4ID0gdGhpcy5oZWFkZXJJbmRpY2VzWzNdO1xyXG4gICAgICAgIGxldCBoYXNUaW1lID0gdGhpcy50aW1lR3JhbnVsYXJpdHkgIT09ICcnOyAvL09SIHRoaXMudGltZVZhcmlhYmxlICE9PSB1bmRlZmluZWRcclxuICAgICAgICBsZXQgb3B0aW5hbEluZGljZXMgPSB0aGlzLmhlYWRlckluZGljZXNbNF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPCBlbmRSb3dJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtUm93c1JlYWQrKztcclxuICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSByb3dzW2ldLnNwbGl0KHRoaXMuY29sdW1uRGVsaW1pdGVyKTtcclxuICAgICAgICAgICAgLyogaWYgKGNvbHVtbnMubGVuZ3RoICE9PSB0aGlzLm51bUNvbHVtbnNQZXJSb3cpIC8vQ2hlY2sgZm9yIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgbnVtYmVyIG9mIGNvbHVtbnNcIik7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBbaSwgY2F0SW5kZXhdIG9mIGNhdGVnb3JpY2FsSW5kaWNlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjYXRlZ29yeSA9IGNvbHVtbnNbY2F0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXNbaV0uY2xhc3NDYWxjdWxhdGlvblJlcXVpcmVkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlc1tpXS5hZGRDYXRlZ29yeShjYXRlZ29yeSk7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChjYXRlZ29yeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IFtpLCBjb250SW5kZXhdIG9mIGNvbnRpbnVvdXNJbmRpY2VzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gK2NvbHVtbnNbY29udEluZGV4XTtcclxuICAgICAgICAgICAgICAgIC8qIGlmICh2YWx1ZSA+PSA4MDAwMC4xMClcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXVVVVVFwiKTsgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludW91c1ZhcmlhYmxlc1tpXS5zZXRNaW5NYXgodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcm93LnB1c2godmFsdWUpOyAvL1N0cmluZyB0byBudW1iZXJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgZ2VvSW5kZXggb2YgZ2VvbWV0cnlJbmRpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzSWRHZW9tZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbHVtbnNbZ2VvSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgrdmFsdWUgPT09ICt2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goK3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHZhbHVlLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCtjb2x1bW5zW2dlb0luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChoYXNUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ3JhbnVsZSA9IHRoaXMuZ2V0R3JhbnVsZShjb2x1bW5zW3RpbWVJbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUuYWRkVGVtcG9yYWxHcmFudWxlKGdyYW51bGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lVmFyaWFibGUuYWRkVGVtcG9yYWxHcmFudWxlVG9TZXQoZ3JhbnVsZSk7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChncmFudWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uYWxJbmRleCBvZiBvcHRpbmFsSW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCtjb2x1bW5zW29wdGlvbmFsSW5kZXhdID09PSArY29sdW1uc1tvcHRpb25hbEluZGV4XSkgLy9JdCdzIGEgbnVtYmVyP1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCtjb2x1bW5zW29wdGlvbmFsSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChjb2x1bW5zW29wdGlvbmFsSW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNSb3dzLnB1c2gocm93KTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhUm93c1NhdmVkLnB1c2gocm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgdGhpcy5kYXRhUm93c1NhdmVkLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBERUxFVEUgQU5EIFJlcGxhY2Ugd2l0aCBHaXNwbGF5RGVmYXVsdHMuZ2V0R3JhbnVsZSh0aW1lU3RyaW5nKVxyXG4gICAgICogQ29udmVydCB0aGUgdGltZSBzdHJpbmcgdG8gdGhlIGdyYW51bGFyaXR5IHdlIHdhbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZVN0cmluZyAtIFRoZSB0aW1lIGFzIGl0IHdhcyByZWFkIGZyb20gdGhlIGZpbGUuIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgZ3JhbnVsXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBnZXRHcmFudWxlKHRpbWVTdHJpbmcpIHtcclxuICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKHRpbWVTdHJpbmcsIHRoaXMudGltZUdyYW51bGFyaXR5KTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIC8vaWYgY3ljbGljIHRoZW4gLi4uXHJcbiAgICAgICAgZGF5IG9mIHllYXIgLT4gZGF5T2ZZZWFyIChuIHRlbW9zIClcclxuICAgICAgICBtb250aCBvZiB5ZWFyIC0+IG1vbnRoT2ZZZWFyICh0ZW1vcylcclxuICAgICAgICBkYXkgb2YgbW9udGggLT4gZGF5T2ZNb250aCAodGVtb3MpXHJcbiAgICAgICAgaG91ciBvZiBkYXkgLT4gaG91ck9mRGF5ICh0ZW1vcylcclxuICAgICAgICBtaW51dGUgb2YgaG91ciAtPiBtaW51dGVPZkhvdXIgKHRlbW9zKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vZWxzZSBjb250aW51b3VzXHJcbiAgICAgICAgeWVhciAtPiAyMDE1LCAyMDE2IC4uLlxyXG4gICAgICAgIG1vbnRoIC0+IDIwMTVfMDEsIDIwMTVfMDIgLi4uIDIwMTZfMDEgZXRjXHJcbiAgICAgICAgZGF5IC0+IDIwMTVfMDFfMDEsIDIwMTVfMDFfMDIgLi4uXHJcbiAgICAgICAgaG91ciAtPiAyMDE1XzAxXzAxXzAxLCAyMDE1XzAxXzAxXzAxIC4uLlxyXG4gICAgICAgIG1pbnV0ZVxyXG4gICAgICAgIHZhbHVlXHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnRpbWVHcmFudWxhcml0eSkge1xyXG4gICAgICAgICAgICAvL0NZQ0xJQ1xyXG4gICAgICAgICAgICBjYXNlICdtb250aE9mWWVhcic6IC8vTWVzIGRvIGFub1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAobmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIDEpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXlPZlllYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTsgLy9DSEFOR0UgdG8gY2FsY3VsYXRlIGRheSBvZiB5ZWFyXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5T2ZNb250aCc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERhdGUoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaG91ck9mRGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0SG91cnMoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlT2ZIb3VyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0TWludXRlcygpOyAvL0dPT0RcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy9DT05USU5VT1VTXHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogLy9NZXMgZG8gYW5vXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIl9cIiArIChuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiX1wiICsgKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1vbnRoKCkgKyAxKSArIFwiX1wiICsgbmV3IERhdGUodGltZVN0cmluZykuZ2V0RGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgPSBOdW1iZXIobmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKSArIFwiXCIgKyBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgXCJcIiArIG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERheSgpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICt0aW1lU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxubmV3IENTVkZpbGVXb3JrZXIoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvUGFyc2VyL0NTVi9GaWxlL0NTVkZpbGVXb3JrZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBZkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWdCQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFYQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBWUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUEzSUE7QUE2SUE7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUVBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWtCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUVBO0FBekNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBaUJBO0FBbEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFtQkE7QUFBQTtBQUNBO0FBQUE7QUFRQTtBQTVCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBeENBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF5Q0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUlBO0FBN0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXVCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBakNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBMENBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBaERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** ./src/Gisplay/defaults.json ***!
  \***********************************/
/***/ (function(module, exports) {

eval("module.exports = {\"figures\":{\"cattle\":0,\"deaths\":1,\"deathsCross\":2,\"fire\":3,\"man\":4,\"person\":5,\"rectangle\":6,\"woman\":7},\"patterns\":{\"crossPattern\":0,\"diagonalLines\":1,\"plusPattern\":2,\"dotPattern\":3,\"wavePattern\":4},\"shapes\":{\"circle\":0,\"cross\":1,\"filled_circle\":2,\"filled_square\":3,\"plus\":4,\"square\":5,\"triangle\":6},\"figuresImageSize\":128,\"patternsImageSize\":32,\"shapesImageSize\":128,\"bgmapsProviders\":[\"Google Maps\",\"GM\",\"Mapbox\",\"MB\",\"Here Maps\",\"HM\",\"Bing Maps\",\"BM\"],\"availableClasssBreakMethods\":[\"quantiles\",\"equalintervals\",\"k-means\"],\"defaultClassBreakMethod\":\"quantiles\",\"reservedKeywords\":{\"longitude\":\"Longitude\",\"latitude\":\"Latitude\"},\"visualVariables\":{\"COLOR\":\"color\",\"SHAPE\":\"shape\",\"TEXTURE\":\"texture\",\"SIZE\":\"size\",\"ORIENTATION\":\"orientation\",\"POSITION\":\"position\",\"OPACITY\":\"opacity\"},\"defaultShadersVariables\":{\"position\":\"position\",\"projectionMatrix\":\"Mproj\"},\"defaultColor\":[0,0,0],\"defaultAlpha\":1,\"defaultShape\":\"triangle\",\"defaultTexture\":\"terrain\",\"defaultFigure\":\"deathsCross\",\"defaultOrientation\":0,\"defaultSize\":10,\"minSize\":15,\"maxSize\":100,\"timeVariables\":{\"INSTANT\":\"instant\",\"INTERVAL\":\"interval\",\"ANIMATION\":\"animation\"},\"bgmapsUrls\":{\"MB\":{\"css\":[\"https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.css\"],\"js\":[\"https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.js\"]},\"MBGL\":{\"css\":[\"https://api.tiles.mapbox.com/mapbox-gl-js/v0.41.0/mapbox-gl.css\"],\"js\":[\"https://api.tiles.mapbox.com/mapbox-gl-js/v0.41.0/mapbox-gl.js\"]},\"GM\":{\"js\":[\"https://maps.googleapis.com/maps/api/js?key=AIzaSyBU70aRzSHEkkEDGM54wxOfz6GBOffjzlE\"]},\"HM\":{\"js\":[\"http://js.api.here.com/v3/3.0/mapsjs-core.js\",\"http://js.api.here.com/v3/3.0/mapsjs-service.js\",\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"]},\"BM\":{\"js\":[\"http://www.bing.com/api/maps/mapcontrol?branch=release\"]}}}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9HaXNwbGF5L2RlZmF1bHRzLmpzb24/Mjg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcImZpZ3VyZXNcIjp7XCJjYXR0bGVcIjowLFwiZGVhdGhzXCI6MSxcImRlYXRoc0Nyb3NzXCI6MixcImZpcmVcIjozLFwibWFuXCI6NCxcInBlcnNvblwiOjUsXCJyZWN0YW5nbGVcIjo2LFwid29tYW5cIjo3fSxcInBhdHRlcm5zXCI6e1wiY3Jvc3NQYXR0ZXJuXCI6MCxcImRpYWdvbmFsTGluZXNcIjoxLFwicGx1c1BhdHRlcm5cIjoyLFwiZG90UGF0dGVyblwiOjMsXCJ3YXZlUGF0dGVyblwiOjR9LFwic2hhcGVzXCI6e1wiY2lyY2xlXCI6MCxcImNyb3NzXCI6MSxcImZpbGxlZF9jaXJjbGVcIjoyLFwiZmlsbGVkX3NxdWFyZVwiOjMsXCJwbHVzXCI6NCxcInNxdWFyZVwiOjUsXCJ0cmlhbmdsZVwiOjZ9LFwiZmlndXJlc0ltYWdlU2l6ZVwiOjEyOCxcInBhdHRlcm5zSW1hZ2VTaXplXCI6MzIsXCJzaGFwZXNJbWFnZVNpemVcIjoxMjgsXCJiZ21hcHNQcm92aWRlcnNcIjpbXCJHb29nbGUgTWFwc1wiLFwiR01cIixcIk1hcGJveFwiLFwiTUJcIixcIkhlcmUgTWFwc1wiLFwiSE1cIixcIkJpbmcgTWFwc1wiLFwiQk1cIl0sXCJhdmFpbGFibGVDbGFzc3NCcmVha01ldGhvZHNcIjpbXCJxdWFudGlsZXNcIixcImVxdWFsaW50ZXJ2YWxzXCIsXCJrLW1lYW5zXCJdLFwiZGVmYXVsdENsYXNzQnJlYWtNZXRob2RcIjpcInF1YW50aWxlc1wiLFwicmVzZXJ2ZWRLZXl3b3Jkc1wiOntcImxvbmdpdHVkZVwiOlwiTG9uZ2l0dWRlXCIsXCJsYXRpdHVkZVwiOlwiTGF0aXR1ZGVcIn0sXCJ2aXN1YWxWYXJpYWJsZXNcIjp7XCJDT0xPUlwiOlwiY29sb3JcIixcIlNIQVBFXCI6XCJzaGFwZVwiLFwiVEVYVFVSRVwiOlwidGV4dHVyZVwiLFwiU0laRVwiOlwic2l6ZVwiLFwiT1JJRU5UQVRJT05cIjpcIm9yaWVudGF0aW9uXCIsXCJQT1NJVElPTlwiOlwicG9zaXRpb25cIixcIk9QQUNJVFlcIjpcIm9wYWNpdHlcIn0sXCJkZWZhdWx0U2hhZGVyc1ZhcmlhYmxlc1wiOntcInBvc2l0aW9uXCI6XCJwb3NpdGlvblwiLFwicHJvamVjdGlvbk1hdHJpeFwiOlwiTXByb2pcIn0sXCJkZWZhdWx0Q29sb3JcIjpbMCwwLDBdLFwiZGVmYXVsdEFscGhhXCI6MSxcImRlZmF1bHRTaGFwZVwiOlwidHJpYW5nbGVcIixcImRlZmF1bHRUZXh0dXJlXCI6XCJ0ZXJyYWluXCIsXCJkZWZhdWx0RmlndXJlXCI6XCJkZWF0aHNDcm9zc1wiLFwiZGVmYXVsdE9yaWVudGF0aW9uXCI6MCxcImRlZmF1bHRTaXplXCI6MTAsXCJtaW5TaXplXCI6MTUsXCJtYXhTaXplXCI6MTAwLFwidGltZVZhcmlhYmxlc1wiOntcIklOU1RBTlRcIjpcImluc3RhbnRcIixcIklOVEVSVkFMXCI6XCJpbnRlcnZhbFwiLFwiQU5JTUFUSU9OXCI6XCJhbmltYXRpb25cIn0sXCJiZ21hcHNVcmxzXCI6e1wiTUJcIjp7XCJjc3NcIjpbXCJodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC5qcy92Mi40LjAvbWFwYm94LmNzc1wiXSxcImpzXCI6W1wiaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3guanMvdjIuNC4wL21hcGJveC5qc1wiXX0sXCJNQkdMXCI6e1wiY3NzXCI6W1wiaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDEuMC9tYXBib3gtZ2wuY3NzXCJdLFwianNcIjpbXCJodHRwczovL2FwaS50aWxlcy5tYXBib3guY29tL21hcGJveC1nbC1qcy92MC40MS4wL21hcGJveC1nbC5qc1wiXX0sXCJHTVwiOntcImpzXCI6W1wiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT1BSXphU3lCVTcwYVJ6U0hFa2tFREdNNTR3eE9mejZHQk9mZmp6bEVcIl19LFwiSE1cIjp7XCJqc1wiOltcImh0dHA6Ly9qcy5hcGkuaGVyZS5jb20vdjMvMy4wL21hcHNqcy1jb3JlLmpzXCIsXCJodHRwOi8vanMuYXBpLmhlcmUuY29tL3YzLzMuMC9tYXBzanMtc2VydmljZS5qc1wiLFwiaHR0cDovL2pzLmFwaS5oZXJlLmNvbS92My8zLjAvbWFwc2pzLW1hcGV2ZW50cy5qc1wiXX0sXCJCTVwiOntcImpzXCI6W1wiaHR0cDovL3d3dy5iaW5nLmNvbS9hcGkvbWFwcy9tYXBjb250cm9sP2JyYW5jaD1yZWxlYXNlXCJdfX19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvR2lzcGxheS9kZWZhdWx0cy5qc29uXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })
/******/ ]);